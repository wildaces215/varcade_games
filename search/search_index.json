{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Code Over Time What is Code Over Time? Code Over Time is all about software engineering. It\u2019s about building production ready software that can be maintained and extended over time. Software Engineering is a skill and it is more than just coding. It involves managing a system as it evolves over time. That system will have many different components, all interconnected. It will behave differently when many people are using it and it will break from time to time. There are a lot of variables at play here \u2013 a lot of tech to learn and understand. Over the course of two decades in the software industry I\u2019ve seen and heard of countless junior engineers experiencing explosive growth during their first six months working in the real world. I\u2019ve also heard from many experienced engineers that they experience most growth when changing job or project. Code Over Time aims to simulate that experience. To give you something real to work on \u2013 and to get you off the rails of coding tutorials. Here you will have your own project to manage, features to build and bugs to fix. There is a quote that I love, that I think sums this up nicely: 1 2 3 \u201cEducation is experience, and the essence of experience is self-reliance.\u201d -Merlyn, \u2018The Sword in the Stone\u2019 In order to be an effective Software Engineer you need to face the challenges that building and releasing real software brings. You can think of Code Over Time as your own personal Internship. A way for you to get real hands on experience, on a real product. Varcade Games Varcade Games is that real world product. It is an online gaming portal that allows game developers build and share their games while also taking advantage of built in functionality, such as a matchmaker and leaderboards. In order to build such a product you need to build and front end and a back end. You need databases and realtime networking. You need build tools and you need to write tests. You also need to get creative. Where there are games there are graphics, music and system design. The Tech In order to work on this project we\u2019ll primarily use Python and Javascript. You\u2019ll also be working with popular tech like Vue.js, Node.js, Django and Flask along with DevOps tech like Docker and Kubernetes Everything you need to be a well rounded engineer. Open Source This project is 100% free and open source. All of the code is available on Github . There are detailed READMEs there that explain how everything works. And of course there is this website that aims to guide you through the process of become confident enough to work on such a project. Who is Code Over Time for? Beginner - Intermediate Coders Have you learned how to write a bit of code? Maybe done a couple of small projects and followed some courses online or completed a year or two of college? Code Over Time is primarily for you. The goal is to give you some hands on experience with the type of project you might actually see when you get your first engineering job. Hopefully it also helps you uncover what you\u2019re actually interested in. Is it server programming? Automation? DevOps? Graphics? On this project you will get to dip your toe in a number of different specialties to see which one fits you best. Engineers changing field Have you been working primarily in Java, but looking to get a Python job? Or maybe doing a lot of front end web stuff but now want to understand exactly what is going on in the backend? Or maybe you want to make the jumps to DevOps and need some hands on experience with Kubernetes. With Code Over Time and Varcade Games you can build the skills you will need to do exactly that. Experienced engineers Are you and experienced engineer that wants to try your hand at Python? Maybe you\u2019ve never done web development and want to try out some of that tech. With Code Over Time you\u2019ve got a real project to jump into and experience those things first hand. Maybe you're interested in learning GoLang? You can try rewriting one of the Varcade Games services in Go to experience the language with real world use cases. Maybe you want to understand Docker a bit better \u2013 there\u2019s plenty of opportunity for that too. Maybe you like making games and would like to plug into and existing framework for hosting it and running multi-player games. Basically what you\u2019ve got is a sandbox, and sitting there on Github waiting for you. The Curious Interested in tech? Patient and willing to put in hours of work? You might find exploring Varcade Games fun. Get in and change things, see what happens. Hack at it and have fun. Who am I? At this point you may be wondering who I am and why you should care about what I have to say. My name is Kev and I\u2019m a Software Engineer from Dublin, Ireland. Well actually that might not be true anymore. At the time of writing I am VP of Engineering at Scopely (we build and publish games), and have been for some time. I still consider myself a software engineer, though it\u2019s been a few years since I\u2019ve been in the weeds, actively contributing code to the projects I\u2019ve been working on. In spite of that, \u2018I\u2019m a Software Engineer\u2019 is still the answer I always give to the question \u2018What do you do?\u2019 Earlier in my career I spent a few years working at IBM, doing some interesting stuff with developer tools and a social search engine. Then I took a pretty big leap from multi-national behemoth down to start-up land, working on mobile apps and websites in the early days of Android and IOS. While I was doing that I also built and ran my own location based Zombie game (think Pokemon Go, but with Zombies). It was called \u2018Outbreak: Zombie Apocalypse\u2019 and it turned out to be a stepping stone into the games industry. Shortly after I released \u2018Outbreak!\u2019 DIGIT Games opened in Dublin. A brand new start up that had ambitious plans to build cross platform strategy games. I joined their team as a game server engineer, working on their first title \u2018Kings of the Realm\u2019, which was a strategy MMO for mobile and browser. After that I became lead server engineer on their next title, and global hit mobile game, Star Trek Fleet Command. Eventually I ended up as VP of Engineering and have had the pleasure of working with many game teams, all across the world, on a number of exciting titles. Throughout that journey I\u2019ve done a little bit of everything. Client and server side development. Build, deployment and operations. Product and game design. Built teams, planned work and coached engineers. I\u2019ve also accidentally nuked live databases and done some horribly hacky things during crisis moments running live services. Over the years I\u2019ve become increasingly interested in training. More specifically: effective training. This project is a manifestation of that. I like to build things and had an itch to write some code so I spent the 2020 Covid-19 lockdown working on this in my spare time. Mostly early mornings before work and weekends. I genuinely believe that the most effective way to get good at software engineering is to do it. And not on small sample projects, like a to-do list, but on the real thing. Most new engineers I\u2019ve spoken to tend to see explosive growth in their first six months in the real world. That\u2019s what I wanted to simulate here \u2013 and I think Varcade Games is a great project to do it with. I also like music (particularly Metal) and Kettlebells. You won\u2019t find me on social media or anything like that \u2013 it seems like they\u2019re bad for you\u2026 but you can find me over on the Code Over Time Discord server . Thanks, -Kev","title":"Welcome"},{"location":"#code-over-time","text":"","title":"Code Over Time"},{"location":"#what-is-code-over-time","text":"Code Over Time is all about software engineering. It\u2019s about building production ready software that can be maintained and extended over time. Software Engineering is a skill and it is more than just coding. It involves managing a system as it evolves over time. That system will have many different components, all interconnected. It will behave differently when many people are using it and it will break from time to time. There are a lot of variables at play here \u2013 a lot of tech to learn and understand. Over the course of two decades in the software industry I\u2019ve seen and heard of countless junior engineers experiencing explosive growth during their first six months working in the real world. I\u2019ve also heard from many experienced engineers that they experience most growth when changing job or project. Code Over Time aims to simulate that experience. To give you something real to work on \u2013 and to get you off the rails of coding tutorials. Here you will have your own project to manage, features to build and bugs to fix. There is a quote that I love, that I think sums this up nicely: 1 2 3 \u201cEducation is experience, and the essence of experience is self-reliance.\u201d -Merlyn, \u2018The Sword in the Stone\u2019 In order to be an effective Software Engineer you need to face the challenges that building and releasing real software brings. You can think of Code Over Time as your own personal Internship. A way for you to get real hands on experience, on a real product.","title":"What is Code Over Time?"},{"location":"#varcade-games","text":"Varcade Games is that real world product. It is an online gaming portal that allows game developers build and share their games while also taking advantage of built in functionality, such as a matchmaker and leaderboards. In order to build such a product you need to build and front end and a back end. You need databases and realtime networking. You need build tools and you need to write tests. You also need to get creative. Where there are games there are graphics, music and system design.","title":"Varcade Games"},{"location":"#the-tech","text":"In order to work on this project we\u2019ll primarily use Python and Javascript. You\u2019ll also be working with popular tech like Vue.js, Node.js, Django and Flask along with DevOps tech like Docker and Kubernetes Everything you need to be a well rounded engineer.","title":"The Tech"},{"location":"#open-source","text":"This project is 100% free and open source. All of the code is available on Github . There are detailed READMEs there that explain how everything works. And of course there is this website that aims to guide you through the process of become confident enough to work on such a project.","title":"Open Source"},{"location":"#who-is-code-over-time-for","text":"","title":"Who is Code Over Time for?"},{"location":"#beginner-intermediate-coders","text":"Have you learned how to write a bit of code? Maybe done a couple of small projects and followed some courses online or completed a year or two of college? Code Over Time is primarily for you. The goal is to give you some hands on experience with the type of project you might actually see when you get your first engineering job. Hopefully it also helps you uncover what you\u2019re actually interested in. Is it server programming? Automation? DevOps? Graphics? On this project you will get to dip your toe in a number of different specialties to see which one fits you best.","title":"Beginner - Intermediate Coders"},{"location":"#engineers-changing-field","text":"Have you been working primarily in Java, but looking to get a Python job? Or maybe doing a lot of front end web stuff but now want to understand exactly what is going on in the backend? Or maybe you want to make the jumps to DevOps and need some hands on experience with Kubernetes. With Code Over Time and Varcade Games you can build the skills you will need to do exactly that.","title":"Engineers changing field"},{"location":"#experienced-engineers","text":"Are you and experienced engineer that wants to try your hand at Python? Maybe you\u2019ve never done web development and want to try out some of that tech. With Code Over Time you\u2019ve got a real project to jump into and experience those things first hand. Maybe you're interested in learning GoLang? You can try rewriting one of the Varcade Games services in Go to experience the language with real world use cases. Maybe you want to understand Docker a bit better \u2013 there\u2019s plenty of opportunity for that too. Maybe you like making games and would like to plug into and existing framework for hosting it and running multi-player games. Basically what you\u2019ve got is a sandbox, and sitting there on Github waiting for you.","title":"Experienced engineers"},{"location":"#the-curious","text":"Interested in tech? Patient and willing to put in hours of work? You might find exploring Varcade Games fun. Get in and change things, see what happens. Hack at it and have fun.","title":"The Curious"},{"location":"#who-am-i","text":"At this point you may be wondering who I am and why you should care about what I have to say. My name is Kev and I\u2019m a Software Engineer from Dublin, Ireland. Well actually that might not be true anymore. At the time of writing I am VP of Engineering at Scopely (we build and publish games), and have been for some time. I still consider myself a software engineer, though it\u2019s been a few years since I\u2019ve been in the weeds, actively contributing code to the projects I\u2019ve been working on. In spite of that, \u2018I\u2019m a Software Engineer\u2019 is still the answer I always give to the question \u2018What do you do?\u2019 Earlier in my career I spent a few years working at IBM, doing some interesting stuff with developer tools and a social search engine. Then I took a pretty big leap from multi-national behemoth down to start-up land, working on mobile apps and websites in the early days of Android and IOS. While I was doing that I also built and ran my own location based Zombie game (think Pokemon Go, but with Zombies). It was called \u2018Outbreak: Zombie Apocalypse\u2019 and it turned out to be a stepping stone into the games industry. Shortly after I released \u2018Outbreak!\u2019 DIGIT Games opened in Dublin. A brand new start up that had ambitious plans to build cross platform strategy games. I joined their team as a game server engineer, working on their first title \u2018Kings of the Realm\u2019, which was a strategy MMO for mobile and browser. After that I became lead server engineer on their next title, and global hit mobile game, Star Trek Fleet Command. Eventually I ended up as VP of Engineering and have had the pleasure of working with many game teams, all across the world, on a number of exciting titles. Throughout that journey I\u2019ve done a little bit of everything. Client and server side development. Build, deployment and operations. Product and game design. Built teams, planned work and coached engineers. I\u2019ve also accidentally nuked live databases and done some horribly hacky things during crisis moments running live services. Over the years I\u2019ve become increasingly interested in training. More specifically: effective training. This project is a manifestation of that. I like to build things and had an itch to write some code so I spent the 2020 Covid-19 lockdown working on this in my spare time. Mostly early mornings before work and weekends. I genuinely believe that the most effective way to get good at software engineering is to do it. And not on small sample projects, like a to-do list, but on the real thing. Most new engineers I\u2019ve spoken to tend to see explosive growth in their first six months in the real world. That\u2019s what I wanted to simulate here \u2013 and I think Varcade Games is a great project to do it with. I also like music (particularly Metal) and Kettlebells. You won\u2019t find me on social media or anything like that \u2013 it seems like they\u2019re bad for you\u2026 but you can find me over on the Code Over Time Discord server . Thanks, -Kev","title":"Who am I?"},{"location":"curriculum/","text":"In the pages that follow we will explore a range of different topics related to software engineering. Hardware, software, coding and of course work on a real world project. A combination of reading and doing. The menu on your left will provide you with reading material that covers various different software engineering related topics as well as detailed guides on how to work with Varcade Games, along with some tasks for you to do yourself. What you will need In order to work with Code Over Time you will need a computer, an internet connection and time. Computer You will not be able to follow this material on a tablet or phone, you will need a desktop or laptop computer. A PC or a Mac will do fine. Internet All of the content is online and you will need to download and install a number of different pieces of software. Time There are no shortcuts to learning how to program a computer, you will need to put in the time. It's also worth remembering that an hour per day is far more valuable than one 5 hour marathon session per week. Consistency is key. It's worth thinking about your motivations now. If you are looking to learn enough about coding to get a well paid job as quickly as possible then Code Over Time is not for you. If, on the other hand, you want to learn how to build software and are willing to put in the time - then this is definitely the right place for you. Reading Material This section covers many different but important topics related to computers and software engineering. Some of it technical, some of it more philosophical. The goal here is to help you really understand what is actually going on inside your computer and to get you thinking like a software engineer. Your Internship This section is all about Varcade Games. How to set up your development environment, how to configure the product and how to make changes. This is where you will experience what it is like to be a software engineer out there in the real world. An important Note This will be an ever-evolving curriculum. The project will grow and shift over time and new reading material will be added. You will find this is exactly what happens in the software industry. Nothing is static - and you will need to get used to that fact pretty quickly. What's next? I recommend jumping straight in to your internship. The 'Getting Set Up' and 'Onboarding' documentation will guide you through the process of downloading the project code and running it on your machine. As soon as you start that process you will be learning. If you get frustrated or want a break from the hands on side of things then jump over to the reading material. If you want some human support you can join me over on our dedicated Discord Server . Most importantly - have fun!","title":"Curriculum"},{"location":"curriculum/#what-you-will-need","text":"In order to work with Code Over Time you will need a computer, an internet connection and time.","title":"What you will need"},{"location":"curriculum/#computer","text":"You will not be able to follow this material on a tablet or phone, you will need a desktop or laptop computer. A PC or a Mac will do fine.","title":"Computer"},{"location":"curriculum/#internet","text":"All of the content is online and you will need to download and install a number of different pieces of software.","title":"Internet"},{"location":"curriculum/#time","text":"There are no shortcuts to learning how to program a computer, you will need to put in the time. It's also worth remembering that an hour per day is far more valuable than one 5 hour marathon session per week. Consistency is key. It's worth thinking about your motivations now. If you are looking to learn enough about coding to get a well paid job as quickly as possible then Code Over Time is not for you. If, on the other hand, you want to learn how to build software and are willing to put in the time - then this is definitely the right place for you.","title":"Time"},{"location":"curriculum/#reading-material","text":"This section covers many different but important topics related to computers and software engineering. Some of it technical, some of it more philosophical. The goal here is to help you really understand what is actually going on inside your computer and to get you thinking like a software engineer.","title":"Reading Material"},{"location":"curriculum/#your-internship","text":"This section is all about Varcade Games. How to set up your development environment, how to configure the product and how to make changes. This is where you will experience what it is like to be a software engineer out there in the real world.","title":"Your Internship"},{"location":"curriculum/#an-important-note","text":"This will be an ever-evolving curriculum. The project will grow and shift over time and new reading material will be added. You will find this is exactly what happens in the software industry. Nothing is static - and you will need to get used to that fact pretty quickly.","title":"An important Note"},{"location":"curriculum/#whats-next","text":"I recommend jumping straight in to your internship. The 'Getting Set Up' and 'Onboarding' documentation will guide you through the process of downloading the project code and running it on your machine. As soon as you start that process you will be learning. If you get frustrated or want a break from the hands on side of things then jump over to the reading material. If you want some human support you can join me over on our dedicated Discord Server . Most importantly - have fun!","title":"What's next?"},{"location":"resources/","text":"Below are some useful links to documentation and source code related to Code Over Time and Varcade Games. Code Over Time Varcade Games in Github Code Over Time Discord Server Documentation Vue.js Phaser 3 Docker Python Django Flask","title":"Resources"},{"location":"resources/#code-over-time","text":"Varcade Games in Github Code Over Time Discord Server","title":"Code Over Time"},{"location":"resources/#documentation","text":"Vue.js Phaser 3 Docker Python Django Flask","title":"Documentation"},{"location":"course_material/computers/001_how_computers_work/","text":"How computers work The not-so-bright Robot Whenever I encounter someone getting frustrated with a computer I always try to explain that a computer can only do what you tell it to do. That\u2019s it, nothing more. You provide instructions by pushing keys on your keyboard, clicking your mouse or touching a screen and the computer does its best to execute them. They are obedient, but they are obedient to a fault. They will follow your instructions even if the outcome is bad. Let\u2019s look at a simple example. Imagine someone gave you a robot for your birthday. This is a really cool present but the robot is not very smart. It will do whatever it is told but it cannot think for itself. It also has an understanding of the basic objects you find around your house, like furniture, food, pets etc, but it doesn\u2019t know how to interact with them, so you are going to have to teach it. Unboxing the robot has left you tired and hungry so you decide to teach it to make you some food. You say: \u2018Robot, make me a ham and cheese sandwich.\u2019 Nothing. It simply stands and stares back at you with its emotionless eyes. The robot knows what a sandwich is, it also knows what bread, ham and cheese are, but it hasn\u2019t yet learned how to combine them into a sandwich. It looks like you\u2019re going to stay hungry for a while, but teach the robot how to do it once and you will be sorted for ham and cheese sandwiches for life. So you roll up your sleeves and lead your soon-to-be personal chef to the kitchen. Programming Your Robot Having skimmed the robots manual you have enough knowledge to bluff your way through some training, so you begin: 1 2 3 \u201cRobot - enter training mode,\u201d you say. \u201cReady for training,\u201d responds the robot. \u201cOk, take two slices of bread and lay them on the counter.\u201d Nothing. The robots artificial eyebrows are now in the raised position, indicating that it doesn\u2019t understand the instructions. \u2018Ah,\u2019 you think to yourself \u2018it doesn\u2019t know where the bread is!\u2019 1 \u201cTake the bread from the bread bin\u201d Still nothing. The robot knows what a bread bin is, but does not yet know how to interact with it. 1 2 \u201cTake the lid off the bread bin.\u201d \u201cAffirmative.\u201d Success! Your robot has mastered step one of making your sandwich. 1 2 \u201cTake the bread out of the bread bin.\u201d \u201cAffirmative.\u201d You\u2019re getting the hang of this now, time to try the earlier command again.. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u201cTake two slices of bread and lay them on the counter.\u201d \u201cAffirmative.\u201d \u201cGo to fridge.\u201d \u201cAffirmative.\u201d \u201cOpen fridge door.\u201d \u201cAffirmative.\u201d \u201cTake butter, ham and cheese out of the fridge.\u201d \u201cAffirmative.\u201d \u201cGo to bread.\u201d \u201cAffirmative.\u201d \u201cTake the lid off the butter\u201d \u201cAffirmative.\u201d Everything seems to be going well, the robot understood all of your commands, or at least it appears that way. That last command, however, has a problem. The robot needs two hands to open the butter so it promptly drops your ham and cheese on the floor and takes the lid off the butter. This is a valuable lesson - the robot will do what it is told regardless of the consequences and in this case the consequences are ham and cheese on your floor. You clean up the mess and with angry determination you return to training your robot: 1 \u201cGo to drawer.\u201d The robots eyebrows have raised again. Your kitchen has several drawers and it has no idea which one you want it to go to. At this point you also realize that you never told the robot to put the butter and its lid down, so you issue those commands and try to send it to the cutlery drawer again. 1 2 3 4 5 6 7 8 9 10 11 \u201cGo to the top drawer, beside the sink.\u201d \u201cAffirmative.\u201d \u201cOpen drawer.\u201d \u201cAffirmative.\u201d \u201cTake butter knife.\u201d \u201cAffirmative.\u201d \u201cGo to bread.\u201d \u201cAffirmative.\u201d The robot now has everything it needs to make the sandwich. In the process of getting everything it left the fridge and the cutlery drawer open but the sandwich is the goal here, we can deal with the open fridge and drawer later (we will come back to this as it is important, but we are getting really hungry now, so back to the robot). 1 2 3 4 5 \u201cSwipe the knife across the butter.\u201d \u201cAffirmative.\u201d \u201cNow rub the butter on the slices of bread.\u201d \u201cAffirmative.\u201d The butter distribution on the bread isn\u2019t quite up to your standards, but not bad for a first try. 1 2 3 4 5 \u201cTake one slice of cheese from the packet of cheese.\u201d \u201cAffirmative.\u201d \u201cPlace it on the slice of bread on the left.\u201d \u201cAffirmative.\u201d Getting cocky now you decide to start combining instructions. 1 2 3 4 5 \u201cTake one slice of ham from the packet of ham and place it on the cheese already on the bread.\u201d \u201cAffirmative.\u201d \u201cPlace the slice of bread on the right hand side on top of the ham.\u201d \u201cAffirmative.\u201d The robot obeys here, but you have made another mistake. It didn\u2019t flip the second slice of bread so now the butter is facing up. 1 2 \u201cFlip the top slice of bread.\u201d \u201cAffirmative.\u201d And we\u2019re done! You\u2019ve probably never worked so hard for a sandwich in your life, but you have gained a personal sandwich maker. For the sake of brevity I have actually left out a lot of possible steps, such as telling the robot that it should steady the tub of butter with one hand before swiping the knife across it. I would imagine that it would probably just knock the tub off the counter if it followed the above steps precisely. There plenty more room for error in the above sequence, can you think of some more examples? Now that our robot has finished making our sandwich you can tell it to save that sequence of instructions for use in the future. We call this a \u2018program\u2019. You have programmed your robot and saved that program for use later on. In the future when you want a ham and cheese sandwich you simply need to tell the robot to run that program. The problem with this is that our program was pretty sloppy. Remember how our robot left the fridge and drawer open? Every time you run the program it will do the same again. It will also put the second slice of bread on top of the ham upside down and then flip it every time - not very efficient. Luckily we can go back to our program and change some of the instructions or add new ones. This is very important because over time our programs will get larger and more complex, so the more time we invest up front into making sure our robot does things in an efficient, but also neat and tidy, way the better. Our program was pretty simple, but that is because we made a lot of assumptions about the current state of our kitchen. But what if there is no cheese in the fridge? Should we make sure the bread is not stale? We definitely want to make sure that the ham hasn\u2019t gone bad before putting it in the sandwich. These are all things that we humans have learned to do instinctively over time or through experiences (like food poisoning), so when telling our robot what to do it is easy to overlook them. What we need to do with our robot is control the flow of instructions based on the current state of our kitchen and the items that we are interacting with. It\u2019s not particularly hard to do but it is easy to miss things. In order for our robot to do this we can issue commands like this: 1 2 3 4 5 6 7 8 \u201cOpen the fridge.\u201d \u201cAffirmative.\u201d \u201cIf there is no cheese then close the fridge and end the program.\u201d \u201cAffirmative.\u201d \u201cTake the cheese from the fridge.\u201d \u201cAffirmative.\u201d Now we have told our robot that if there is no cheese it should just close the fridge and stop the sandwich making program. The next instruction will only ever be reached if we have cheese because we would have just ended the program otherwise. But what if we want to continue making the sandwich without cheese? Then our instructions would have to look more like this: 1 2 3 4 5 6 7 8 9 10 11 \u201cOpen the fridge.\u201d \u201cAffirmative.\u201d \u201cIf there is cheese and it is not spoiled then pick it up.\u201d \u201cAffirmative.\u201d \u201cIf there is ham and it is not spoiled then pick it up.\u201d \u201cAffirmative.\u201d \u201cClose the fridge.\u201d \u201cAffirmative.\u201d But now we need to take the fact that there might not be cheese or ham later in the program into account. When adding the cheese and ham to the bread we will have to say: 1 2 \u201cIf there is cheese then put it on top of the slice of bread.\u201d \u201cAffirmative.\u201d And 1 2 \u201cIf there is ham put it on top of the cheese otherwise put it on top of the slice of bread.\u201d \u201cAffirmative.\u201d This is how our robot makes decisions. It can question its environment. Is there cheese? Is there butter? Is the bread stale? Based on the answers to those questions it can make a decision. This gives the illusion that the robot is thinking, but it\u2019s not. It\u2019s more like evaluating. At this point it should be pretty clear why computer programming can be so complicated, the more variables there are, ie. the different states that our various items can be in, the more we need to do this sort of questioning. Inevitably we will miss some state or some combination of states (what if there is no cheese and ham is spoiled, for example) and that is what we call a bug. Most people will have heard of computer bugs; this is how they are created. The next time you come across a bug, some situation where you computer is not running as expected, spare a thought for the developers who had to consider thousands of possible combinations of information when creating the software that you are using. A Note About Performance Another thing worth thinking about is what would happen if you started throwing a lot of different commands at the robot? 1 2 3 4 5 6 7 \u201cTake lid off bread bin.\u201d \u201cAffirmat\u2026\u201d \u201cGo to fridge.\u201d \u201cAffirm\u2026\u201d \u201cGo to top drawer beside the sink.\u201d \u201cAffi\u2026\u201d \u201cTake butter from the fridge.\u201d Our poor robot is frazzled. It can only effectively do one thing at a time and as you keep yelling commands without giving it the appropriate time to respond, it gets less and less responsive. Does this sound familiar? Have you ever sat at your computer clicking lots of different things and wondering why nothing is happening? Maybe you hear the fan on your machine starting up or the screen goes funny. This is the same principle - the computer is trying to do too much and the more you try to get it to do, the worse it gets. Final Thought So what was the point of all this? Well first of all, you have just learned a new way of thinking, of breaking down a task into a set of discrete steps and issuing them as commands one at a time in order to teach a machine how to behave. This is computer programming in a nutshell and is something all programmers must learn to do. As a computer user you generally don\u2019t need to think about this because programmers will have done the thinking for you. Just like you don\u2019t need to think much about your car\u2019s engine if you drive a car, you pay engineers to design it and a mechanic to look after it for you. At some point in the future you may upgrade your robot and that upgrade may come with a sandwich making program. Now you just need to tell your robot to make a sandwich and it will start the sandwich making program that it was given by someone else. You are still using the robot, but you don\u2019t need to worry about teaching it things anymore - other people have done it for you! And since it is their full time job they can make fancier programs. They would create a general sandwich making program where you could specify any filling and the robot would try to make it. Maybe they would even connect your robot to the internet so it could find different recipes for sandwiches online and then make them for you. What about scheduling a sandwich? Telling your robot to make you one at some point in the future. Maybe it would check that you have all of the ingredients and create a shopping list for you if you need anything. Think about what that program would look like. It would have thousands of instruction and take a lot of effort to test for bugs. This is why large complicated programs are usually created by teams of people with many different skill sets. Sometimes there will be hundreds of programmers working on different areas of a single program. We will come back to programming and software engineering (and the subtle differences between the two), but first we need to look at the anatomy of our robot. It will be much easier for you to set your robot up to do cool and interesting things if you understand a bit more about it. We already know that it can handle making a sandwich, but can it create a beautiful poem or paint a masterpiece?","title":"How computers work"},{"location":"course_material/computers/001_how_computers_work/#how-computers-work","text":"","title":"How computers work"},{"location":"course_material/computers/001_how_computers_work/#the-not-so-bright-robot","text":"Whenever I encounter someone getting frustrated with a computer I always try to explain that a computer can only do what you tell it to do. That\u2019s it, nothing more. You provide instructions by pushing keys on your keyboard, clicking your mouse or touching a screen and the computer does its best to execute them. They are obedient, but they are obedient to a fault. They will follow your instructions even if the outcome is bad. Let\u2019s look at a simple example. Imagine someone gave you a robot for your birthday. This is a really cool present but the robot is not very smart. It will do whatever it is told but it cannot think for itself. It also has an understanding of the basic objects you find around your house, like furniture, food, pets etc, but it doesn\u2019t know how to interact with them, so you are going to have to teach it. Unboxing the robot has left you tired and hungry so you decide to teach it to make you some food. You say: \u2018Robot, make me a ham and cheese sandwich.\u2019 Nothing. It simply stands and stares back at you with its emotionless eyes. The robot knows what a sandwich is, it also knows what bread, ham and cheese are, but it hasn\u2019t yet learned how to combine them into a sandwich. It looks like you\u2019re going to stay hungry for a while, but teach the robot how to do it once and you will be sorted for ham and cheese sandwiches for life. So you roll up your sleeves and lead your soon-to-be personal chef to the kitchen.","title":"The not-so-bright Robot"},{"location":"course_material/computers/001_how_computers_work/#programming-your-robot","text":"Having skimmed the robots manual you have enough knowledge to bluff your way through some training, so you begin: 1 2 3 \u201cRobot - enter training mode,\u201d you say. \u201cReady for training,\u201d responds the robot. \u201cOk, take two slices of bread and lay them on the counter.\u201d Nothing. The robots artificial eyebrows are now in the raised position, indicating that it doesn\u2019t understand the instructions. \u2018Ah,\u2019 you think to yourself \u2018it doesn\u2019t know where the bread is!\u2019 1 \u201cTake the bread from the bread bin\u201d Still nothing. The robot knows what a bread bin is, but does not yet know how to interact with it. 1 2 \u201cTake the lid off the bread bin.\u201d \u201cAffirmative.\u201d Success! Your robot has mastered step one of making your sandwich. 1 2 \u201cTake the bread out of the bread bin.\u201d \u201cAffirmative.\u201d You\u2019re getting the hang of this now, time to try the earlier command again.. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u201cTake two slices of bread and lay them on the counter.\u201d \u201cAffirmative.\u201d \u201cGo to fridge.\u201d \u201cAffirmative.\u201d \u201cOpen fridge door.\u201d \u201cAffirmative.\u201d \u201cTake butter, ham and cheese out of the fridge.\u201d \u201cAffirmative.\u201d \u201cGo to bread.\u201d \u201cAffirmative.\u201d \u201cTake the lid off the butter\u201d \u201cAffirmative.\u201d Everything seems to be going well, the robot understood all of your commands, or at least it appears that way. That last command, however, has a problem. The robot needs two hands to open the butter so it promptly drops your ham and cheese on the floor and takes the lid off the butter. This is a valuable lesson - the robot will do what it is told regardless of the consequences and in this case the consequences are ham and cheese on your floor. You clean up the mess and with angry determination you return to training your robot: 1 \u201cGo to drawer.\u201d The robots eyebrows have raised again. Your kitchen has several drawers and it has no idea which one you want it to go to. At this point you also realize that you never told the robot to put the butter and its lid down, so you issue those commands and try to send it to the cutlery drawer again. 1 2 3 4 5 6 7 8 9 10 11 \u201cGo to the top drawer, beside the sink.\u201d \u201cAffirmative.\u201d \u201cOpen drawer.\u201d \u201cAffirmative.\u201d \u201cTake butter knife.\u201d \u201cAffirmative.\u201d \u201cGo to bread.\u201d \u201cAffirmative.\u201d The robot now has everything it needs to make the sandwich. In the process of getting everything it left the fridge and the cutlery drawer open but the sandwich is the goal here, we can deal with the open fridge and drawer later (we will come back to this as it is important, but we are getting really hungry now, so back to the robot). 1 2 3 4 5 \u201cSwipe the knife across the butter.\u201d \u201cAffirmative.\u201d \u201cNow rub the butter on the slices of bread.\u201d \u201cAffirmative.\u201d The butter distribution on the bread isn\u2019t quite up to your standards, but not bad for a first try. 1 2 3 4 5 \u201cTake one slice of cheese from the packet of cheese.\u201d \u201cAffirmative.\u201d \u201cPlace it on the slice of bread on the left.\u201d \u201cAffirmative.\u201d Getting cocky now you decide to start combining instructions. 1 2 3 4 5 \u201cTake one slice of ham from the packet of ham and place it on the cheese already on the bread.\u201d \u201cAffirmative.\u201d \u201cPlace the slice of bread on the right hand side on top of the ham.\u201d \u201cAffirmative.\u201d The robot obeys here, but you have made another mistake. It didn\u2019t flip the second slice of bread so now the butter is facing up. 1 2 \u201cFlip the top slice of bread.\u201d \u201cAffirmative.\u201d And we\u2019re done! You\u2019ve probably never worked so hard for a sandwich in your life, but you have gained a personal sandwich maker. For the sake of brevity I have actually left out a lot of possible steps, such as telling the robot that it should steady the tub of butter with one hand before swiping the knife across it. I would imagine that it would probably just knock the tub off the counter if it followed the above steps precisely. There plenty more room for error in the above sequence, can you think of some more examples? Now that our robot has finished making our sandwich you can tell it to save that sequence of instructions for use in the future. We call this a \u2018program\u2019. You have programmed your robot and saved that program for use later on. In the future when you want a ham and cheese sandwich you simply need to tell the robot to run that program. The problem with this is that our program was pretty sloppy. Remember how our robot left the fridge and drawer open? Every time you run the program it will do the same again. It will also put the second slice of bread on top of the ham upside down and then flip it every time - not very efficient. Luckily we can go back to our program and change some of the instructions or add new ones. This is very important because over time our programs will get larger and more complex, so the more time we invest up front into making sure our robot does things in an efficient, but also neat and tidy, way the better. Our program was pretty simple, but that is because we made a lot of assumptions about the current state of our kitchen. But what if there is no cheese in the fridge? Should we make sure the bread is not stale? We definitely want to make sure that the ham hasn\u2019t gone bad before putting it in the sandwich. These are all things that we humans have learned to do instinctively over time or through experiences (like food poisoning), so when telling our robot what to do it is easy to overlook them. What we need to do with our robot is control the flow of instructions based on the current state of our kitchen and the items that we are interacting with. It\u2019s not particularly hard to do but it is easy to miss things. In order for our robot to do this we can issue commands like this: 1 2 3 4 5 6 7 8 \u201cOpen the fridge.\u201d \u201cAffirmative.\u201d \u201cIf there is no cheese then close the fridge and end the program.\u201d \u201cAffirmative.\u201d \u201cTake the cheese from the fridge.\u201d \u201cAffirmative.\u201d Now we have told our robot that if there is no cheese it should just close the fridge and stop the sandwich making program. The next instruction will only ever be reached if we have cheese because we would have just ended the program otherwise. But what if we want to continue making the sandwich without cheese? Then our instructions would have to look more like this: 1 2 3 4 5 6 7 8 9 10 11 \u201cOpen the fridge.\u201d \u201cAffirmative.\u201d \u201cIf there is cheese and it is not spoiled then pick it up.\u201d \u201cAffirmative.\u201d \u201cIf there is ham and it is not spoiled then pick it up.\u201d \u201cAffirmative.\u201d \u201cClose the fridge.\u201d \u201cAffirmative.\u201d But now we need to take the fact that there might not be cheese or ham later in the program into account. When adding the cheese and ham to the bread we will have to say: 1 2 \u201cIf there is cheese then put it on top of the slice of bread.\u201d \u201cAffirmative.\u201d And 1 2 \u201cIf there is ham put it on top of the cheese otherwise put it on top of the slice of bread.\u201d \u201cAffirmative.\u201d This is how our robot makes decisions. It can question its environment. Is there cheese? Is there butter? Is the bread stale? Based on the answers to those questions it can make a decision. This gives the illusion that the robot is thinking, but it\u2019s not. It\u2019s more like evaluating. At this point it should be pretty clear why computer programming can be so complicated, the more variables there are, ie. the different states that our various items can be in, the more we need to do this sort of questioning. Inevitably we will miss some state or some combination of states (what if there is no cheese and ham is spoiled, for example) and that is what we call a bug. Most people will have heard of computer bugs; this is how they are created. The next time you come across a bug, some situation where you computer is not running as expected, spare a thought for the developers who had to consider thousands of possible combinations of information when creating the software that you are using.","title":"Programming Your Robot"},{"location":"course_material/computers/001_how_computers_work/#a-note-about-performance","text":"Another thing worth thinking about is what would happen if you started throwing a lot of different commands at the robot? 1 2 3 4 5 6 7 \u201cTake lid off bread bin.\u201d \u201cAffirmat\u2026\u201d \u201cGo to fridge.\u201d \u201cAffirm\u2026\u201d \u201cGo to top drawer beside the sink.\u201d \u201cAffi\u2026\u201d \u201cTake butter from the fridge.\u201d Our poor robot is frazzled. It can only effectively do one thing at a time and as you keep yelling commands without giving it the appropriate time to respond, it gets less and less responsive. Does this sound familiar? Have you ever sat at your computer clicking lots of different things and wondering why nothing is happening? Maybe you hear the fan on your machine starting up or the screen goes funny. This is the same principle - the computer is trying to do too much and the more you try to get it to do, the worse it gets.","title":"A Note About Performance"},{"location":"course_material/computers/001_how_computers_work/#final-thought","text":"So what was the point of all this? Well first of all, you have just learned a new way of thinking, of breaking down a task into a set of discrete steps and issuing them as commands one at a time in order to teach a machine how to behave. This is computer programming in a nutshell and is something all programmers must learn to do. As a computer user you generally don\u2019t need to think about this because programmers will have done the thinking for you. Just like you don\u2019t need to think much about your car\u2019s engine if you drive a car, you pay engineers to design it and a mechanic to look after it for you. At some point in the future you may upgrade your robot and that upgrade may come with a sandwich making program. Now you just need to tell your robot to make a sandwich and it will start the sandwich making program that it was given by someone else. You are still using the robot, but you don\u2019t need to worry about teaching it things anymore - other people have done it for you! And since it is their full time job they can make fancier programs. They would create a general sandwich making program where you could specify any filling and the robot would try to make it. Maybe they would even connect your robot to the internet so it could find different recipes for sandwiches online and then make them for you. What about scheduling a sandwich? Telling your robot to make you one at some point in the future. Maybe it would check that you have all of the ingredients and create a shopping list for you if you need anything. Think about what that program would look like. It would have thousands of instruction and take a lot of effort to test for bugs. This is why large complicated programs are usually created by teams of people with many different skill sets. Sometimes there will be hundreds of programmers working on different areas of a single program. We will come back to programming and software engineering (and the subtle differences between the two), but first we need to look at the anatomy of our robot. It will be much easier for you to set your robot up to do cool and interesting things if you understand a bit more about it. We already know that it can handle making a sandwich, but can it create a beautiful poem or paint a masterpiece?","title":"Final Thought"},{"location":"course_material/computers/002_robot_anatomy/","text":"Robot Anatomy Everyone computer has a few core components, most of which you will no doubt have heard of: CPU Memory (or RAM) Hard drive Motherboard And most will have other components that you will definitely have heard of: Keyboard/Mouse Monitor Speakers So how do these familiar words apply to our robot? Let\u2019s start with the fact that we told our robot what to do by speaking to it. We issued commands one after another and our robot executed them. This means the robot must have ears right? The technical term for \u2018Robot Ears\u2019 is one we are all familiar with - a microphone. A mouse, keyboard or the touch screen on your phone will work the same way, except we do not use our voice, we interact through touch. These are all known as input devices. You may have seen the letters I and O used like this: I/O. You may have also guessed that the I stands for \u2018Input\u2019. The \u2018O\u2019 stands for \u2018Output\u2019. In the case of our Robot, the Output is the robot\u2019s actions. So when we told it to open the fridge, the command \u2018Open the fridge\u2019 is an input, and the output is the robot opening the fridge. When it comes to computers, the output devices we are most familiar with are our monitor, or screen, and our speakers. Have you ever looked at a picture on a computer? Chances are you did so by using your mouse to double click on a file, or clicked on a friend\u2019s Facebook post. This is your input; you are telling the computer you want to see the picture by clicking on it. The computer will then display that image on your screen; that is the output. We are implicitly familiar with the concept of inputs and outputs in our everyday lives. Have you ever bought a bottle of water from a vending machine? You input a coin and the vending machine outputs your water. Most of our daily actions consist of input and outputs, or actions and reactions - computers are no different. This gets this a little more complicated if we consider something like the humble text message. When you type a text message on your phone the input is your finger touching the onscreen keyboard (if you are using a touch screen), the output is a letter displayed on your screen. By tapping on the keyboard you are issuing a command - add this letter to my message. The command is received by the phone and it will obediently add the selected letter to your message. If you tap the send button you have issued a different command, one that causes the phone to send your message. The output in this case is a message sent from your phone. Interestingly, your output, the message, will become the input on the recipient's phone. Your phone, and your mobile network, have issued a command to their phone - saying \u2018notify this person that they have a message\u2019. That person can then tap the open button on their screen, which is a new input, and the phone will display that message, which is the final output. Let's worry about the complexity of sending messages between devices later, for now let's go back to our Robot. we know that if we tell it to do something it will do that thing, but how does it turn that command, the input, into the action of doing it, or the output. It needs some sort of transformation to happen in the middle. This is where it is easier just to think of it as magic but of course it isn\u2019t. Essentially it is a combination of two things: CPU (Central Processing Unit) Memory Robot Brain The CPU is one part of the Robot\u2019s brain. It is the thing that takes the input and performs the necessary actions to provide the expected output. Remember earlier on when we talked about the robot asking questions about its environment? Is there cheese in the fridge, is it spoiled etc... It is the CPU that is manages this this. It can be used to compare things and take certain actions depending on the state of those things. When we create a computer program we are actually creating a plan for the CPU to follow. Let's not worry about exactly how the CPU executes our plan right now, just know that it is the CPU that is processing the commands we submit to our robot. The other half of our robot's brain is its memory. In order to function effectively, a CPU needs memory. Our Robot remembers words like \u2018Open\u2019 and \u2018Fridge\u2019. It also remembers that \u2018Open\u2019 is an action and that \u2018Fridge\u2019 is a thing. So how is it all connected? Firstly the Robot\u2019s ears are connected to the CPU and when the ears detect sound that information is sent to the CPU. The CPU is also connected to the robot\u2019s memory. Once it gets the command from the ears it will send that information to memory. To understand why it does this imagine if I asked you add ten different numbers together and then listed the numbers off really quickly. You would probably want to write them down. Once they are written down it is easier for you to add them together. This is the same principle as the relationship between the CPU and Memory. The CPU can store information in memory so that it can work with it later. If we were to represent this as a conversation between the various components we might end up with something like this: 1 2 3 4 5 6 Ears: Hey, CPU! You\u2019ve gotta hear this! CPU: Ok ears, I\u2019ve got a second to listen to you. Ears: Our master said \u201cOpen the fridge\u201d. CPU: Ok, thanks - hey Memory, I need you to remember this: \u201cOpen the fridge.\u201d Memory: \u201cOpen the fridge\u201d? Got it. CPU: Thanks, now I can look at this command properly and figure out what to do So our command has now been added to memory - but it is not the only thing that is in memory. A robot\u2019s memory represents its understanding of the world in which it lives and how to interact with that world. If we tell it to go somewhere it will walk there because that action (ie. how to walk) is stored in it\u2019s memory. Once our command is in memory the CPU can look at it one word at a time. The first word is \u2018Open\u2019, so it will search its stored actions for that action. When it finds the action in memory it will also find out what it means. In this case it will let the Robot know that it will need to use its arms. It also knows that one of the next words in the command should be a thing that can be opened. In our case it is the fridge, which is fine because a fridge can be opened, but if we had said \u2018Open the cat\u2019 the Robot wouldn\u2019t know what to do (or it would do something horrible). Once it knows we are talking about the fridge it will need to find the fridge, scanning the kitchen for something that looks like a fridge. So it will also need to have a visual description of a fridge in memory so that it knows one when it sees it. If this is confusing, don\u2019t worry, it\u2019s a complex subject. I don\u2019t expect to turn you into a computer scientist just by reading this little analogy, the idea is simply to understand the role of these components in a computer. I think it would be helpful to stop and think about the implications of what we have learned so far. If the robot stores everything it knows in memory, you can safely assume we need a lot of memory. And if the CPU is coordinating inputs and outputs, interacting with multiple components then it had better be fast. Have you ever heard someone boast that their computer has \u201c16 gigs of RAM\"? This is the amount of memory their computer has, and it is quite a lot by current standards. It means their computer can store a lot of information and actions. How about \u201cThe all new iPhone has a 2 gigahertz processor\u201d? This is referring to the speed of its CPU - and just like our robot, the faster the better, because your phone is doing a lot of stuff. Let\u2019s get back to our robot. Once the CPU has found the information it needs in memory it sends it to the arms. This is not unlike how our own brains work. If I told you to open the fridge you will hear my words and your brain will need to think about it for a fraction of a second before it then sends the message, in the form of electrical signals, to your arms. This all happens subconsciously of course, but your brain needs to access your memory to see what a fridge is and what opening one involves. These are things you have learned over time, both the language used to describe the everyday items that surround you and what those items look like. A computer needs to be told what these things are, just like you did. A computer\u2019s memory is also like human memory in the sense that it has short term and long term memory. The short term memory is our RAM (Random Access Memory) and the long term memory is our hard drive. A good way to think about this is from the point of view of an actor. Lets imagine an actor has lots of scripts to learn. Sitting on their table is a stack of them. If our actor memorized each and every script then they would be able to recite lines really quickly. On the other hand, if they had not memorized each script they would have to find the script in the pile on the table, open it up and find a passage in order to recite the lines - which of course takes a lot longer. The problem that an actor has is that they cannot remember all of those scripts at once. So what do they do? They will likely memorize the script that they know they will be using next and leave the rest of them sitting idly on the table, meaning they can quickly and easily recite lines from the script that they need right now. The table is like a hard drive, we can put a lot of scripts there for later use. The scripts are the information that we are storing. In the case of a computer this would be music files, videos, photos or documents. Our actor\u2019s brain represents our RAM. It is limited in storage so it can only hold one script at a time, but it is much faster to work with. So what does this mean for our robot? Our sandwich making program would be stored on the hard drive because there is no need for it to be taking up the limited space in our RAM. When we tell the robot to run the program the CPU will then transfer it to short term memory so that it knows how to make the sandwich. Reading the instructions from short term memory is much faster than reading from the hard drive, so rather than reading and following each instruction one at a time from hard drive, we transfer the whole lot to short term memory and then follow each instruction. We\u2019re now ready to see the complete picture of what is happening when we tell our robot to make our sandwich: We issue the command: \u201cRun ham and cheese sandwich making program\u201d The command is picked up by the robots microphone ears The command is passed to the CPU and written down in short term memory The CPU reads the command one word at a time The words \u2018run\u2019 and \u2018program\u2019 tell us to search the hard drive, or long term memory, for a program by the name \u2018ham and cheese sandwich\u2019 The program is located and transferred from the hard drive to short term memory The robot reads and performs each instruction in the program from short term memory When the robot is finished making the sandwich the program is removed from short term memory The robot awaits the next command If we hadn\u2019t copied the program into our short term memory it would have taken thousands of times longer to actually read and follow each instruction. This short term memory is, however, much more expensive, which is why there is generally a lot less of it. More importantly than that, if we were to switch off our robot everything in short term memory will disappear. This is because it is \u2018transient\u2019 storage, meaning we lose all of the information in short term memory if the robot loses power. This could happen because we turn it off, or it\u2019s battery dies or it turns itself off for some reason. Our hard drive, or long term memory, does not work like this, it will remember everything even after losing power. I think it\u2019s about time to leave the robot to one side and talk about how all of this actually applies in the real world. How about we watch a video on our computer. In order to do this we will need two things: A video file (this could be a movie downloaded from the internet) A program that can player videos (usually already available on most computers) The video file will be represented as an icon on our computer screen. It will have a name and mostly likely a small image to go alongside it, we just need to open it and watch. To do this you will need to click with your mouse or touchpad (if on a laptop). That click is the input that tells the computer what to do. Whatever the CPU was doing at the time was interrupted by your request to open the video. It begins the process of loading the program into your short term memory, just like our sandwich maker program. You may have already guessed that the video file is also stored on our hard drive, so the next thing our CPU does is start the video player program, which then loads the video into short term memory so it can be played. The output of all this? You will see the video play on your monitor. Our video player program will use the CPU in order to process the information in the video file and send it to the monitor. There is of course a lot more going on behind the scenes but this is the basic principle of all programs. They are stored on the hard drive, loaded into memory and then often work with other information that is also stored on the hard drive. Have you ever had a computer that takes a long time to start up? You turn it on and have to wait forever before you can actually use it? This is because the computer is moving a lot of different programs into memory, getting ready for you to use it. Over time our computer seems to get slower and slower but this is more likely caused by more information being transferred between long and short term memory. You may install a new program that runs as soon as your computer starts (like anti-virus software). Now every time your computer starts it will need to move this program to short term memory, meaning it is that much slower at actually starting up. Now that we have seen how these important components all interact with each other it is worth throwing out a few honorable mentions. You may have heard of a \u2018motherboard\u2019. I have spoken a lot about the CPU transferring information between long and short term memory as well as coordinating inputs and outputs. It is the motherboard that facilitates all of these communications. Each component is connected to the motherboard in such a way that electrical signals can be sent between them. We also have components that are specifically designed to work with speakers and monitors. They handle playing music as displaying fancy 3D game graphics. They are called sound cards and graphics cards. The is also a PSU, or power supply unit, which is responsible for ensuring that all of these components have enough power (electrical power that is) to function properly. Final Thoughts Now that we have been through all of these core components we can think about answering the question we posed earlier on. Can our robot paint a beautiful picture or write a poem? The answer to that question is technically yes. However it would be a hugely complex program to write. Think about how careful we had to be when instructing our robot to make a simple sandwich. Also take into account that we only created a very basic version of that program. Now imagine what it would take to teach it to paint. First off we would teach it the mechanics of painting, ie. using a brush, dipping it in paint and rubbing it on the canvas etc\u2026 Everything beyond that will be an immense undertaking. I will let you go down that rabbit hole on your own if you wish; have a think about how you would command the robot to paint a picture or write a poem. The more simple version would be for the robot to simply copy existing images (ie. paint a picture of a person or a landscape that they are currently looking at. It is important to understand that there are things that computers are great at and other things that they are currently pretty bad at. Processing data and storing information is where they excel. A computer that can run a series of maths equations much faster and more accurately than a human can. If there is a well defined set of rules, or parameters, to operate within then a computer will likely do the job well (to learn this for yourself just try beating a super computer at chess!). Humans on the other hand are far better at things like designing solutions to problems (designing software for example, both technically and visually). We are also better at processing the space around us, whether that means cleaning our house or building a new one - we are incredibly efficient when it comes to navigating the world. We are also much better at just being human, sadness and laughter, joy and heartbreak are all uniquely human attributes that computers today cannot effectively simulate. There is a test named \u2018The Turing Test\u2019 (named after Alan Turing, a hugely important figure in the development of computer science) in which human participants are sat down at several different computers and must chat to one another. They are all in separate rooms while chatting. The trick is that one of the participants is actually a computer program. The challenge is to fool the human into thinking they are talking to another human when in fact they are talking to a computer. At the time of writing this there is a website you can go to in order to try this out for yourself: www.cleverbot.com. The website is a simple chat application where you can converse with a \u2018chatbot\u2019. A chat bot is an artificially intelligent computer program that will respond to the things you say. You can have full blown conversations with this bot, however it is pretty obvious that you are not talking to a human.","title":"Robot Anatomy"},{"location":"course_material/computers/002_robot_anatomy/#robot-anatomy","text":"Everyone computer has a few core components, most of which you will no doubt have heard of: CPU Memory (or RAM) Hard drive Motherboard And most will have other components that you will definitely have heard of: Keyboard/Mouse Monitor Speakers So how do these familiar words apply to our robot? Let\u2019s start with the fact that we told our robot what to do by speaking to it. We issued commands one after another and our robot executed them. This means the robot must have ears right? The technical term for \u2018Robot Ears\u2019 is one we are all familiar with - a microphone. A mouse, keyboard or the touch screen on your phone will work the same way, except we do not use our voice, we interact through touch. These are all known as input devices. You may have seen the letters I and O used like this: I/O. You may have also guessed that the I stands for \u2018Input\u2019. The \u2018O\u2019 stands for \u2018Output\u2019. In the case of our Robot, the Output is the robot\u2019s actions. So when we told it to open the fridge, the command \u2018Open the fridge\u2019 is an input, and the output is the robot opening the fridge. When it comes to computers, the output devices we are most familiar with are our monitor, or screen, and our speakers. Have you ever looked at a picture on a computer? Chances are you did so by using your mouse to double click on a file, or clicked on a friend\u2019s Facebook post. This is your input; you are telling the computer you want to see the picture by clicking on it. The computer will then display that image on your screen; that is the output. We are implicitly familiar with the concept of inputs and outputs in our everyday lives. Have you ever bought a bottle of water from a vending machine? You input a coin and the vending machine outputs your water. Most of our daily actions consist of input and outputs, or actions and reactions - computers are no different. This gets this a little more complicated if we consider something like the humble text message. When you type a text message on your phone the input is your finger touching the onscreen keyboard (if you are using a touch screen), the output is a letter displayed on your screen. By tapping on the keyboard you are issuing a command - add this letter to my message. The command is received by the phone and it will obediently add the selected letter to your message. If you tap the send button you have issued a different command, one that causes the phone to send your message. The output in this case is a message sent from your phone. Interestingly, your output, the message, will become the input on the recipient's phone. Your phone, and your mobile network, have issued a command to their phone - saying \u2018notify this person that they have a message\u2019. That person can then tap the open button on their screen, which is a new input, and the phone will display that message, which is the final output. Let's worry about the complexity of sending messages between devices later, for now let's go back to our Robot. we know that if we tell it to do something it will do that thing, but how does it turn that command, the input, into the action of doing it, or the output. It needs some sort of transformation to happen in the middle. This is where it is easier just to think of it as magic but of course it isn\u2019t. Essentially it is a combination of two things: CPU (Central Processing Unit) Memory","title":"Robot Anatomy"},{"location":"course_material/computers/002_robot_anatomy/#robot-brain","text":"The CPU is one part of the Robot\u2019s brain. It is the thing that takes the input and performs the necessary actions to provide the expected output. Remember earlier on when we talked about the robot asking questions about its environment? Is there cheese in the fridge, is it spoiled etc... It is the CPU that is manages this this. It can be used to compare things and take certain actions depending on the state of those things. When we create a computer program we are actually creating a plan for the CPU to follow. Let's not worry about exactly how the CPU executes our plan right now, just know that it is the CPU that is processing the commands we submit to our robot. The other half of our robot's brain is its memory. In order to function effectively, a CPU needs memory. Our Robot remembers words like \u2018Open\u2019 and \u2018Fridge\u2019. It also remembers that \u2018Open\u2019 is an action and that \u2018Fridge\u2019 is a thing. So how is it all connected? Firstly the Robot\u2019s ears are connected to the CPU and when the ears detect sound that information is sent to the CPU. The CPU is also connected to the robot\u2019s memory. Once it gets the command from the ears it will send that information to memory. To understand why it does this imagine if I asked you add ten different numbers together and then listed the numbers off really quickly. You would probably want to write them down. Once they are written down it is easier for you to add them together. This is the same principle as the relationship between the CPU and Memory. The CPU can store information in memory so that it can work with it later. If we were to represent this as a conversation between the various components we might end up with something like this: 1 2 3 4 5 6 Ears: Hey, CPU! You\u2019ve gotta hear this! CPU: Ok ears, I\u2019ve got a second to listen to you. Ears: Our master said \u201cOpen the fridge\u201d. CPU: Ok, thanks - hey Memory, I need you to remember this: \u201cOpen the fridge.\u201d Memory: \u201cOpen the fridge\u201d? Got it. CPU: Thanks, now I can look at this command properly and figure out what to do So our command has now been added to memory - but it is not the only thing that is in memory. A robot\u2019s memory represents its understanding of the world in which it lives and how to interact with that world. If we tell it to go somewhere it will walk there because that action (ie. how to walk) is stored in it\u2019s memory. Once our command is in memory the CPU can look at it one word at a time. The first word is \u2018Open\u2019, so it will search its stored actions for that action. When it finds the action in memory it will also find out what it means. In this case it will let the Robot know that it will need to use its arms. It also knows that one of the next words in the command should be a thing that can be opened. In our case it is the fridge, which is fine because a fridge can be opened, but if we had said \u2018Open the cat\u2019 the Robot wouldn\u2019t know what to do (or it would do something horrible). Once it knows we are talking about the fridge it will need to find the fridge, scanning the kitchen for something that looks like a fridge. So it will also need to have a visual description of a fridge in memory so that it knows one when it sees it. If this is confusing, don\u2019t worry, it\u2019s a complex subject. I don\u2019t expect to turn you into a computer scientist just by reading this little analogy, the idea is simply to understand the role of these components in a computer. I think it would be helpful to stop and think about the implications of what we have learned so far. If the robot stores everything it knows in memory, you can safely assume we need a lot of memory. And if the CPU is coordinating inputs and outputs, interacting with multiple components then it had better be fast. Have you ever heard someone boast that their computer has \u201c16 gigs of RAM\"? This is the amount of memory their computer has, and it is quite a lot by current standards. It means their computer can store a lot of information and actions. How about \u201cThe all new iPhone has a 2 gigahertz processor\u201d? This is referring to the speed of its CPU - and just like our robot, the faster the better, because your phone is doing a lot of stuff. Let\u2019s get back to our robot. Once the CPU has found the information it needs in memory it sends it to the arms. This is not unlike how our own brains work. If I told you to open the fridge you will hear my words and your brain will need to think about it for a fraction of a second before it then sends the message, in the form of electrical signals, to your arms. This all happens subconsciously of course, but your brain needs to access your memory to see what a fridge is and what opening one involves. These are things you have learned over time, both the language used to describe the everyday items that surround you and what those items look like. A computer needs to be told what these things are, just like you did. A computer\u2019s memory is also like human memory in the sense that it has short term and long term memory. The short term memory is our RAM (Random Access Memory) and the long term memory is our hard drive. A good way to think about this is from the point of view of an actor. Lets imagine an actor has lots of scripts to learn. Sitting on their table is a stack of them. If our actor memorized each and every script then they would be able to recite lines really quickly. On the other hand, if they had not memorized each script they would have to find the script in the pile on the table, open it up and find a passage in order to recite the lines - which of course takes a lot longer. The problem that an actor has is that they cannot remember all of those scripts at once. So what do they do? They will likely memorize the script that they know they will be using next and leave the rest of them sitting idly on the table, meaning they can quickly and easily recite lines from the script that they need right now. The table is like a hard drive, we can put a lot of scripts there for later use. The scripts are the information that we are storing. In the case of a computer this would be music files, videos, photos or documents. Our actor\u2019s brain represents our RAM. It is limited in storage so it can only hold one script at a time, but it is much faster to work with. So what does this mean for our robot? Our sandwich making program would be stored on the hard drive because there is no need for it to be taking up the limited space in our RAM. When we tell the robot to run the program the CPU will then transfer it to short term memory so that it knows how to make the sandwich. Reading the instructions from short term memory is much faster than reading from the hard drive, so rather than reading and following each instruction one at a time from hard drive, we transfer the whole lot to short term memory and then follow each instruction. We\u2019re now ready to see the complete picture of what is happening when we tell our robot to make our sandwich: We issue the command: \u201cRun ham and cheese sandwich making program\u201d The command is picked up by the robots microphone ears The command is passed to the CPU and written down in short term memory The CPU reads the command one word at a time The words \u2018run\u2019 and \u2018program\u2019 tell us to search the hard drive, or long term memory, for a program by the name \u2018ham and cheese sandwich\u2019 The program is located and transferred from the hard drive to short term memory The robot reads and performs each instruction in the program from short term memory When the robot is finished making the sandwich the program is removed from short term memory The robot awaits the next command If we hadn\u2019t copied the program into our short term memory it would have taken thousands of times longer to actually read and follow each instruction. This short term memory is, however, much more expensive, which is why there is generally a lot less of it. More importantly than that, if we were to switch off our robot everything in short term memory will disappear. This is because it is \u2018transient\u2019 storage, meaning we lose all of the information in short term memory if the robot loses power. This could happen because we turn it off, or it\u2019s battery dies or it turns itself off for some reason. Our hard drive, or long term memory, does not work like this, it will remember everything even after losing power. I think it\u2019s about time to leave the robot to one side and talk about how all of this actually applies in the real world. How about we watch a video on our computer. In order to do this we will need two things: A video file (this could be a movie downloaded from the internet) A program that can player videos (usually already available on most computers) The video file will be represented as an icon on our computer screen. It will have a name and mostly likely a small image to go alongside it, we just need to open it and watch. To do this you will need to click with your mouse or touchpad (if on a laptop). That click is the input that tells the computer what to do. Whatever the CPU was doing at the time was interrupted by your request to open the video. It begins the process of loading the program into your short term memory, just like our sandwich maker program. You may have already guessed that the video file is also stored on our hard drive, so the next thing our CPU does is start the video player program, which then loads the video into short term memory so it can be played. The output of all this? You will see the video play on your monitor. Our video player program will use the CPU in order to process the information in the video file and send it to the monitor. There is of course a lot more going on behind the scenes but this is the basic principle of all programs. They are stored on the hard drive, loaded into memory and then often work with other information that is also stored on the hard drive. Have you ever had a computer that takes a long time to start up? You turn it on and have to wait forever before you can actually use it? This is because the computer is moving a lot of different programs into memory, getting ready for you to use it. Over time our computer seems to get slower and slower but this is more likely caused by more information being transferred between long and short term memory. You may install a new program that runs as soon as your computer starts (like anti-virus software). Now every time your computer starts it will need to move this program to short term memory, meaning it is that much slower at actually starting up. Now that we have seen how these important components all interact with each other it is worth throwing out a few honorable mentions. You may have heard of a \u2018motherboard\u2019. I have spoken a lot about the CPU transferring information between long and short term memory as well as coordinating inputs and outputs. It is the motherboard that facilitates all of these communications. Each component is connected to the motherboard in such a way that electrical signals can be sent between them. We also have components that are specifically designed to work with speakers and monitors. They handle playing music as displaying fancy 3D game graphics. They are called sound cards and graphics cards. The is also a PSU, or power supply unit, which is responsible for ensuring that all of these components have enough power (electrical power that is) to function properly.","title":"Robot Brain"},{"location":"course_material/computers/002_robot_anatomy/#final-thoughts","text":"Now that we have been through all of these core components we can think about answering the question we posed earlier on. Can our robot paint a beautiful picture or write a poem? The answer to that question is technically yes. However it would be a hugely complex program to write. Think about how careful we had to be when instructing our robot to make a simple sandwich. Also take into account that we only created a very basic version of that program. Now imagine what it would take to teach it to paint. First off we would teach it the mechanics of painting, ie. using a brush, dipping it in paint and rubbing it on the canvas etc\u2026 Everything beyond that will be an immense undertaking. I will let you go down that rabbit hole on your own if you wish; have a think about how you would command the robot to paint a picture or write a poem. The more simple version would be for the robot to simply copy existing images (ie. paint a picture of a person or a landscape that they are currently looking at. It is important to understand that there are things that computers are great at and other things that they are currently pretty bad at. Processing data and storing information is where they excel. A computer that can run a series of maths equations much faster and more accurately than a human can. If there is a well defined set of rules, or parameters, to operate within then a computer will likely do the job well (to learn this for yourself just try beating a super computer at chess!). Humans on the other hand are far better at things like designing solutions to problems (designing software for example, both technically and visually). We are also better at processing the space around us, whether that means cleaning our house or building a new one - we are incredibly efficient when it comes to navigating the world. We are also much better at just being human, sadness and laughter, joy and heartbreak are all uniquely human attributes that computers today cannot effectively simulate. There is a test named \u2018The Turing Test\u2019 (named after Alan Turing, a hugely important figure in the development of computer science) in which human participants are sat down at several different computers and must chat to one another. They are all in separate rooms while chatting. The trick is that one of the participants is actually a computer program. The challenge is to fool the human into thinking they are talking to another human when in fact they are talking to a computer. At the time of writing this there is a website you can go to in order to try this out for yourself: www.cleverbot.com. The website is a simple chat application where you can converse with a \u2018chatbot\u2019. A chat bot is an artificially intelligent computer program that will respond to the things you say. You can have full blown conversations with this bot, however it is pretty obvious that you are not talking to a human.","title":"Final Thoughts"},{"location":"course_material/computers/003_hardware_software/","text":"Hardware VS. Software Hardware Now that we are more familiar with the anatomy of our robot and how to program it we should stop to look at some more common computer terms that are useful to know and various different types of software. In the last section we talked about our CPU, RAM and harddrive. These components are known as hardware. The word \u2018hardware\u2019 is used to describe all physical components of a computer, including our mouse, keyboard, monitor and graphics/sound cards. When it comes to hardware, people will generally be most interested in the CPU, RAM and graphics card. Knowing the specifications of these pieces of hardware is enough to tell us how fast we can expect the computer to run as well as how many programs it can handle running simultaneously before it starts to slow down and become unresponsive. CPU We briefly mentioned CPU performance earlier and used the word \u2018gigahertz\u2019. This word is actually composed to two words, the second being the most interesting: hertz. This is a word commonly used in physics and engineering and simply means \u2018cycles per second\u2019 or \u2018frequency\u2019. If you look at an ordinary clock, the seconds hand ticks once every second, so it could be said that it is running at 1 hertz. If you have any experience with music theory you will be familiar with the measure of beats per minute, which is a similar concept. If you use public transport and your bus comes once every hour, you could call that the frequency of your bus - or buses per hour. In fact we can invent a new unit of measurement right now: \u2018Burtz\u2019, which means buses per hour. The bus that I take every day runs at a frequency of 3 burtz, meaning three of them come within the space of an hour. I would have to wait around less if that frequency was increased. If the buses ran at 12 burtz it would mean there would be one every five minutes, which would be great! Back to our CPU and its \u2018cycles per second\u2019. For simplicity sake, lets think of a cycle as being the execution of a single instruction. So earlier on when we said our CPU transferred our sandwich program from the hard drive to RAM, this would have been millions of operations. Which means that it\u2019s a good thing that the first part of the word \u2018gigahertz\u2019 means \u2018billions\u2019. So then we say our CPU is running at \u20182 gigahertz\u2019 it means that it can perform a whopping 2 billion operations every second! Remember this the next time you get angry at your computer. That poor little processor is working incredibly hard trying to keep up with the demands of modern software. Each program running on your computer is like an angry customer in a packed restaurant shouting at a single waiter who is struggling to keep up with their orders. Bits and Bytes When it comes to memory and storage we used a different word: \u2018gigabytes\u2019, or \u2018gigs of RAM\u2019. The \u2018giga\u2019 in this word means the same thing but the \u2018bytes\u2019 is very different. You may have guessed that \u2018gigabytes\u2019 means \u2018billions of bytes\u2019, and if so then you guessed correctly. But what is a byte? Answering that question requires that we look at something called a \u2018bit\u2019 first. A \u2018bit\u2019 in computing is the smallest unit of information that a computer can work with. When thinking about human language, the smallest unit of information would be a letter. Words are made of letters, sentences of words, paragraphs of sentences, chapters of paragraphs and books of chapters. Letters aren\u2019t composed of anything else like sentences, paragraphs and chapters are. We can\u2019t break down a letter any further. A bit is to a computer what a single letter is to natural language. On it\u2019s own a letter cannot do much, but once we start creating sequences of letters we end up with books that contain huge amounts of information. In computing we do the same with bits. In the English alphabet there are 26 letters, but for a computer\u2019s alphabet there are only two bits: 1 and 0. A byte is just a sequence of eight of these bits. So one gigabyte is one billion bytes, which is actually eight billion bits. Don't worry about why we chose 8 bits for now, just know that it's a good number of computers. So how does a computer that stores a bunch of bits manage to display text and images to us? Well that is actually pretty simple. We use certain sequences of bits to represent things. A computer may represent the letter \u2018A\u2019 using this sequence of bits: \u201801000001\u2019. So in our RAM if we want to store the letter \u2018A\u2019 we will use that sequence, which uses up 8 bits of the billions of bits available to us. To illustrate this point let\u2019s imagine we are back in school. You are sitting in a particularly boring class and want to pass a note to your friend. You have been caught doing this before so you and your friend set up a code where you use bits to represent letters, this way your teacher won\u2019t know what you are saying if you get caught again: A 01000001 N 01001110 B 01000010 O 01001111 C 01000011 P 01010000 D 01000100 Q 01010001 E 01000101 R 01010010 F 01000110 S 01010011 G 01000111 T 01010100 H 01001000 U 01010101 I 01001001 V 01010110 J 01001010 W 01010111 K 01001011 X 01011000 L 01001100 Y 01011001 M 01001101 Z 01011010 As we can see, each letter of the alphabet is represented by a unique sequence of bits. To test your system you start by writing the most basic message you can think of: \u201cHello\u201d. Substituting each letter in the word hello for the bits in the above table we get this: 01001000 01000101 01001100 01001100 01001111 It\u2019s perfect! No one will be able to read our message unless they know that you have to take a sequence of eight bits and convert it to a letter before you move on to the next eight bits. Your friend knows that each group of eight bits represents a letter so they simply need to take each \u2018byte\u2019 and look it up in the table above. This sequence of bits is exactly how a computer would store that word in its memory. And while this is very time consuming for humans to read and work with, the same is not true for a computer. In fact, using modern RAM, a computer can transfer up to 20 billion of these bytes to and from RAM every second! A computer will store your images, music, videos and text files in the same way. The programs you use every day know how to read that information and display it on your monitor in a way that you understand, just like our friend was able to take our message and use the table of letters to figure out exactly what it said. You may now be thinking that the programs that allow us to watch videos and look at pictures must be insanely complex! Well the answer is yes and in fact it is probably even more complex than you think, so let\u2019s take a closer look at the world of software. Software Earlier on we created a sandwich making program for our robot. This is software. It is not a physical thing that we can touch like our hardware. Even though we only wrote one program for our robot, this does not mean that it only has one program to run. Our robot already knew how to walk so it must have had a program for that. It was also able to enter training mode when we told it to, so training mode must be another program. We also learned that in order to run our program it had to transfer that program from its harddrive to its RAM, so it needed a program to do that too. The software that manages all of these basic but crucial functions of our robot is known as the operating system, or OS. You will most likely be familiar with at least one operating system. If you use a computer it is likely running either Windows (on a PC) or OSX (on a Mac). There are many more operating systems (you may have heard of Linux), but Windows and OSX are by far the most common in consumer computing. At the time of writing this, if you have a smartphone chances are it is either an iPhone or an Android phone. IOS is the operating system that runs on an iPhone and Android is an operating system that many different companies use on their smartphones (Samsung, LG, Motorola, HTC etc\u2026). When you turn on your computer or phone or tablet you are starting the OS. This is a very complex piece of software that manages all of the information stored on your harddrive, how it is transferred to and from RAM and how all of this information is displayed on your screen. It is not one single program but a collection of programs that work together to allow you to use your computer. When you create your own program, like our sandwich making one, you are working within the bounds of the OS. This means you may be limited in what you can actually do based on the OS. If you write a program for an iPhone, for example, the OS will not let your program access other programs. If it did I could easily write an app that looks at all of your private emails and message. The OS will keep the apps isolated from each other for security reasons. Most operating systems will also come with some utility programs installed, such as a web browser for accessing the internet, a calculator, a video player and a music player. These are often created by the same company that built the OS, but aren\u2019t a core component of the OS itself. On top of that you have what would be known as \u2018third party software\u2019. This is software that is created by people or companies that are independent of the OS manufacturer. If you play games on your computer or phone they were most likely made by a third party and had to be built specifically to run on the device you are playing it on. This sort of software needs to be installed on your computer. Installation is simply the act of copying the software from some external location to your hard drive. Traditionally this was done using things like CDs, DVDs or floppy disks (some readers may not be old enough to remember floppy disks, but they did not hold very much information and you often needed several of them to install a single program). More recently the trend has moved towards downloading and installing programs from the internet. If you have ever installed an app from your phone then you have done this. In order for software to exist we need hardware and hardware without software is all but useless. It is a symbiotic relationship where both components depend entirely on eachother. As the software we build gets more and more complex this relationship is put under more and more strain as we push the hardware to its limits. Computer games are the perfect example of this. Games have gone from simple 2D boxes and basic sounds to photorealistic 3D worlds with amazing sound effects in a remarkably short period of time. Graphics programmers have been pushing the limits of hardware for decades. We have also made computers far more accessible than they ever were before. Most people today wouldn\u2019t even know how to begin interacting with a computer from the 1980s, so it is very clear that we have come a long long way. Just look at smartphones. They are computers, but the barrier to entry is a lot lower. Children and adults alike can pick one up and intuitively understand how to use it. Final Thoughts I hope that this has helped you to understand what is going on inside that magic little box that lets you go online and watch videos, or chat with friends while buying new clothes and accessories. You will hopefully have also learned why working with computers can be very challenging and that software engineers have a tough job to do. I am also hoping that the next time you are faced with a frustrating situation you will be better prepared to actually do something about it. If your computer is running slow it is likely doing too much. If something is not working as expected you may have found a bug. Next we should look a little more closely at what happens when we connect computers together. You likely use the internet on a near daily basis, so that is what we will talk about next.","title":"Hardware VS. Software"},{"location":"course_material/computers/003_hardware_software/#hardware-vs-software","text":"","title":"Hardware VS. Software"},{"location":"course_material/computers/003_hardware_software/#hardware","text":"Now that we are more familiar with the anatomy of our robot and how to program it we should stop to look at some more common computer terms that are useful to know and various different types of software. In the last section we talked about our CPU, RAM and harddrive. These components are known as hardware. The word \u2018hardware\u2019 is used to describe all physical components of a computer, including our mouse, keyboard, monitor and graphics/sound cards. When it comes to hardware, people will generally be most interested in the CPU, RAM and graphics card. Knowing the specifications of these pieces of hardware is enough to tell us how fast we can expect the computer to run as well as how many programs it can handle running simultaneously before it starts to slow down and become unresponsive.","title":"Hardware"},{"location":"course_material/computers/003_hardware_software/#cpu","text":"We briefly mentioned CPU performance earlier and used the word \u2018gigahertz\u2019. This word is actually composed to two words, the second being the most interesting: hertz. This is a word commonly used in physics and engineering and simply means \u2018cycles per second\u2019 or \u2018frequency\u2019. If you look at an ordinary clock, the seconds hand ticks once every second, so it could be said that it is running at 1 hertz. If you have any experience with music theory you will be familiar with the measure of beats per minute, which is a similar concept. If you use public transport and your bus comes once every hour, you could call that the frequency of your bus - or buses per hour. In fact we can invent a new unit of measurement right now: \u2018Burtz\u2019, which means buses per hour. The bus that I take every day runs at a frequency of 3 burtz, meaning three of them come within the space of an hour. I would have to wait around less if that frequency was increased. If the buses ran at 12 burtz it would mean there would be one every five minutes, which would be great! Back to our CPU and its \u2018cycles per second\u2019. For simplicity sake, lets think of a cycle as being the execution of a single instruction. So earlier on when we said our CPU transferred our sandwich program from the hard drive to RAM, this would have been millions of operations. Which means that it\u2019s a good thing that the first part of the word \u2018gigahertz\u2019 means \u2018billions\u2019. So then we say our CPU is running at \u20182 gigahertz\u2019 it means that it can perform a whopping 2 billion operations every second! Remember this the next time you get angry at your computer. That poor little processor is working incredibly hard trying to keep up with the demands of modern software. Each program running on your computer is like an angry customer in a packed restaurant shouting at a single waiter who is struggling to keep up with their orders.","title":"CPU"},{"location":"course_material/computers/003_hardware_software/#bits-and-bytes","text":"When it comes to memory and storage we used a different word: \u2018gigabytes\u2019, or \u2018gigs of RAM\u2019. The \u2018giga\u2019 in this word means the same thing but the \u2018bytes\u2019 is very different. You may have guessed that \u2018gigabytes\u2019 means \u2018billions of bytes\u2019, and if so then you guessed correctly. But what is a byte? Answering that question requires that we look at something called a \u2018bit\u2019 first. A \u2018bit\u2019 in computing is the smallest unit of information that a computer can work with. When thinking about human language, the smallest unit of information would be a letter. Words are made of letters, sentences of words, paragraphs of sentences, chapters of paragraphs and books of chapters. Letters aren\u2019t composed of anything else like sentences, paragraphs and chapters are. We can\u2019t break down a letter any further. A bit is to a computer what a single letter is to natural language. On it\u2019s own a letter cannot do much, but once we start creating sequences of letters we end up with books that contain huge amounts of information. In computing we do the same with bits. In the English alphabet there are 26 letters, but for a computer\u2019s alphabet there are only two bits: 1 and 0. A byte is just a sequence of eight of these bits. So one gigabyte is one billion bytes, which is actually eight billion bits. Don't worry about why we chose 8 bits for now, just know that it's a good number of computers. So how does a computer that stores a bunch of bits manage to display text and images to us? Well that is actually pretty simple. We use certain sequences of bits to represent things. A computer may represent the letter \u2018A\u2019 using this sequence of bits: \u201801000001\u2019. So in our RAM if we want to store the letter \u2018A\u2019 we will use that sequence, which uses up 8 bits of the billions of bits available to us. To illustrate this point let\u2019s imagine we are back in school. You are sitting in a particularly boring class and want to pass a note to your friend. You have been caught doing this before so you and your friend set up a code where you use bits to represent letters, this way your teacher won\u2019t know what you are saying if you get caught again: A 01000001 N 01001110 B 01000010 O 01001111 C 01000011 P 01010000 D 01000100 Q 01010001 E 01000101 R 01010010 F 01000110 S 01010011 G 01000111 T 01010100 H 01001000 U 01010101 I 01001001 V 01010110 J 01001010 W 01010111 K 01001011 X 01011000 L 01001100 Y 01011001 M 01001101 Z 01011010 As we can see, each letter of the alphabet is represented by a unique sequence of bits. To test your system you start by writing the most basic message you can think of: \u201cHello\u201d. Substituting each letter in the word hello for the bits in the above table we get this: 01001000 01000101 01001100 01001100 01001111 It\u2019s perfect! No one will be able to read our message unless they know that you have to take a sequence of eight bits and convert it to a letter before you move on to the next eight bits. Your friend knows that each group of eight bits represents a letter so they simply need to take each \u2018byte\u2019 and look it up in the table above. This sequence of bits is exactly how a computer would store that word in its memory. And while this is very time consuming for humans to read and work with, the same is not true for a computer. In fact, using modern RAM, a computer can transfer up to 20 billion of these bytes to and from RAM every second! A computer will store your images, music, videos and text files in the same way. The programs you use every day know how to read that information and display it on your monitor in a way that you understand, just like our friend was able to take our message and use the table of letters to figure out exactly what it said. You may now be thinking that the programs that allow us to watch videos and look at pictures must be insanely complex! Well the answer is yes and in fact it is probably even more complex than you think, so let\u2019s take a closer look at the world of software.","title":"Bits and Bytes"},{"location":"course_material/computers/003_hardware_software/#software","text":"Earlier on we created a sandwich making program for our robot. This is software. It is not a physical thing that we can touch like our hardware. Even though we only wrote one program for our robot, this does not mean that it only has one program to run. Our robot already knew how to walk so it must have had a program for that. It was also able to enter training mode when we told it to, so training mode must be another program. We also learned that in order to run our program it had to transfer that program from its harddrive to its RAM, so it needed a program to do that too. The software that manages all of these basic but crucial functions of our robot is known as the operating system, or OS. You will most likely be familiar with at least one operating system. If you use a computer it is likely running either Windows (on a PC) or OSX (on a Mac). There are many more operating systems (you may have heard of Linux), but Windows and OSX are by far the most common in consumer computing. At the time of writing this, if you have a smartphone chances are it is either an iPhone or an Android phone. IOS is the operating system that runs on an iPhone and Android is an operating system that many different companies use on their smartphones (Samsung, LG, Motorola, HTC etc\u2026). When you turn on your computer or phone or tablet you are starting the OS. This is a very complex piece of software that manages all of the information stored on your harddrive, how it is transferred to and from RAM and how all of this information is displayed on your screen. It is not one single program but a collection of programs that work together to allow you to use your computer. When you create your own program, like our sandwich making one, you are working within the bounds of the OS. This means you may be limited in what you can actually do based on the OS. If you write a program for an iPhone, for example, the OS will not let your program access other programs. If it did I could easily write an app that looks at all of your private emails and message. The OS will keep the apps isolated from each other for security reasons. Most operating systems will also come with some utility programs installed, such as a web browser for accessing the internet, a calculator, a video player and a music player. These are often created by the same company that built the OS, but aren\u2019t a core component of the OS itself. On top of that you have what would be known as \u2018third party software\u2019. This is software that is created by people or companies that are independent of the OS manufacturer. If you play games on your computer or phone they were most likely made by a third party and had to be built specifically to run on the device you are playing it on. This sort of software needs to be installed on your computer. Installation is simply the act of copying the software from some external location to your hard drive. Traditionally this was done using things like CDs, DVDs or floppy disks (some readers may not be old enough to remember floppy disks, but they did not hold very much information and you often needed several of them to install a single program). More recently the trend has moved towards downloading and installing programs from the internet. If you have ever installed an app from your phone then you have done this. In order for software to exist we need hardware and hardware without software is all but useless. It is a symbiotic relationship where both components depend entirely on eachother. As the software we build gets more and more complex this relationship is put under more and more strain as we push the hardware to its limits. Computer games are the perfect example of this. Games have gone from simple 2D boxes and basic sounds to photorealistic 3D worlds with amazing sound effects in a remarkably short period of time. Graphics programmers have been pushing the limits of hardware for decades. We have also made computers far more accessible than they ever were before. Most people today wouldn\u2019t even know how to begin interacting with a computer from the 1980s, so it is very clear that we have come a long long way. Just look at smartphones. They are computers, but the barrier to entry is a lot lower. Children and adults alike can pick one up and intuitively understand how to use it.","title":"Software"},{"location":"course_material/computers/003_hardware_software/#final-thoughts","text":"I hope that this has helped you to understand what is going on inside that magic little box that lets you go online and watch videos, or chat with friends while buying new clothes and accessories. You will hopefully have also learned why working with computers can be very challenging and that software engineers have a tough job to do. I am also hoping that the next time you are faced with a frustrating situation you will be better prepared to actually do something about it. If your computer is running slow it is likely doing too much. If something is not working as expected you may have found a bug. Next we should look a little more closely at what happens when we connect computers together. You likely use the internet on a near daily basis, so that is what we will talk about next.","title":"Final Thoughts"},{"location":"course_material/computers/004_connecting_computers/","text":"Connecting Computers In the first chapter we discussed the various components that make up a computer. We also learned that you need to be very specific when telling it what to do, as there may be unintended consequences. However, we only went as far as discussing a single computer. These days, more often than not, computers are connected to each other through the internet. People make video calls and send emails, photos and videos to each other. We comment on news articles and even sway elections through social media. This area of computing is know as \u2018networking\u2019, and our society is relying on it more with each passing day. Working with one computer is complicated enough and things don\u2019t get any easier when you connect two of them together. In this section we will focus on the most common relationship that exists between two computers: the client and the server. For this we will leave our robot behind and head out for dinner - I know I certainly can\u2019t stand the thought of another ham and cheese sandwich. Eating Out We decide to go for Italian, because there is generally something for everyone at an Italian restaurant. When we arrive we are seated at a nice table in a quiet section of the building and start to think about how a restaurant works. We take a lot of everyday things for granted, so what if we break it down and think a bit deeper about exactly what happens when we go out for food. At our table is a menu, this was brought to us by our waiter. Now the waiter didn\u2019t create the menu and doesn\u2019t prepare the food that is presented on it, but he brings it to us so that we know what is available from the kitchen. From our table we can\u2019t actually see the kitchen and can\u2019t tell where it is, but that doesn\u2019t matter because the waiter knows where it is, how to get there and how to get back to our table. He has shown us what is on offer from the kitchen by bringing us the menu, now it is up to us to decide what we want. Once we know what we want, we tell the waiter and he will scurry off to let the kitchen know. We decide to share a pizza, so we ask the waiter \u2018one large margherita pizza please.\u2019 In the kitchen is a chef. The chef knows as little about us as we do about her. It isn\u2019t of any real concern to her where our table is or even who is sitting at it. She knows that she can prepare the food and trust the waiter to get it to us. She will remain there waiting on orders to come from the waiter and once she has them she can begin her work. This work takes time of course, as she will need to prepare all of the ingredients and organize them into a dish that we can eat. She is taking our request for a margherita pizza and turning it into an actual pizza. In the meantime we have no idea what is going on in the kitchen. We assume that the chef has received our order and that they are working diligently to prepare our food. We know that sometimes it can take a while, but we quietly hope that our pizza will arrive quickly. Unless explicitly stated by the menu we don\u2019t know what type of ingredients are being used. Organic flour and locally grown tomatoes? Or something straight out of a can? Most of the time it doesn\u2019t really matter to us, there is a degree of trust there that we are being served quality. The kitchen could also be dirty, we generally never know. Nevertheless we sit and wait patiently and sure enough our food comes within fifteen minutes. Thankfully it is exactly what we wanted - a beautiful fresh pizza with golden mozzarella and a crust that is perfectly crisp. As we devour our pizza we think about what just happened. The kitchen presented us with options, we made a choice and got what we wanted some time later. We did all of this without actually knowing where the kitchen is or how it works by simply talking to the waiter. We note the fact that this is largely a one-way operation. The kitchen has asked nothing of us, simply delivered what we want. Sure we sent our order out, but it was from a predefined list, it was a selection. Finally we pay and tip the waiter and then go on our way. Altogether it was an entirely uneventful evening out, and there wasn\u2019t a ham and cheese sandwich in sight (though admittedly a cheese pizza isn\u2019t exactly a million miles away). Now it\u2019s time for the fun part - what the hell did the little story above have to do with modern software development? Well believe it or not it was my attempt at explaining how the internet works. Clients and Servers Earlier on I mentioned a type of relationship between two computers: the client-server relationship. You may be able to guess where I am going with this\u2026 in our story we were the client and the kitchen was the server. We are both computers, but one is requesting stuff (the menu, the food) and the other is serving stuff (the food, the bill). The hardworking waiter in this analogy is the internet. He is how information and data is exchanged between the client and server. He is a medium for us to communicate through, much like the air through which the sound travels when we speak. The internet itself is what is known as a network and it spans the entire globe, allowing people in the US to communicate with people in Australia instantaneously. Networks also exist on a smaller scale, like in an office for example - where every computer can share information, but only in that office. Your home may also have its own network. If you have wifi set up you have small network that is connected to the internet, allowing every phone/laptop/PC to communicate with each other and out over the internet. The word network isn\u2019t exclusive to computers. You may heard people refer to a road network, which is simply the system of interconnected roads that we drive on every day. How about a social network? This is a group of connected people, often communication through some shared medium (like Facebook or Twitter). How about networking at a conference or event, where you try to expand your professional circle and build a group of mutually beneficial relationships with other people in your particular industry. The key to all these different uses of the word is that it is all about connectivity. The World Wide Web In order to try and understand what is going on when we \u2018surf\u2019 the internet let\u2019s go back to our restaurant. To breakdown the interactions we had with the restaurant a little further let\u2019s start with how we got there. Imagine that the reason we chose this restaurant in the first place is because it was recommended to us by a friend. He told us that there is a restaurant called Mario\u2019s that does amazing food. That\u2019s all the information we had when we decided to go there but it wasn\u2019t enough information to actually get us there. We need an address. To get the address we went to Google maps and searched for Mario\u2019s, which promptly showed us it\u2019s location and even gave us directions to get there. This is not unlike what happens when we visit a website. If you want to visit a website you need to know its web address, which is usually in the form of \u2018www.thewebsitename.com\u2019. This web address is actually not enough information for our computer, just like the name of the restaurant was not enough information for us. The computer will need to look for a way to get to this website, so it finds what is called an IP address for the website, just like we looked up the address for Marios. This address takes the form of something like this \u2018192.168.1.1\u2019 ( would you like to know what the IP address of your computer is? Simply search google with the following \u2018what is my ip\u2019). Once it has this address the computer can actually begin the process of getting the website that we are looking for. Every computer that is connected to the internet must have an IP address (which stands for \u2018Internet Protocol address\u2019 and is not really important for us). If it didn\u2019t we wouldn\u2019t know how to communicate with it. Just like if our restaurant didn\u2019t have an address we wouldn\u2019t be able to find it. Knowing the address of the restaurant basically allows us to communicate with its kitchen, though we still need the waiter in order to do so. As soon as we arrive at the restaurant we are given a table and a menu. Having a table basically means that we have established a connection with the kitchen. We are now in a position to communicate with the kitchen. Getting our menu is just like viewing the homepage of a website. We are presented with a webpage that is showing us what is on offer from that website. If you go to your local news website, for example, you will likely see a list of recent news stories. A page full of headlines, and maybe an image per story, basically enough information to grab your attention. You can select any one of those news stories and you will then be given the whole article. By selecting from that list of news articles you were making a request. Just like we requested a pizza from the waiter in the restaurant, we are requesting a full news article from the news server. The news server will need to find the article you are looking for and send it back to you, not unlike how our Italian chef had to assemble our pizza. This will take some time, as you are no doubt probably aware. Some websites can take a frustratingly long time to display the content we want. There are several possible reasons for this that we will get into later, but for now we just need to be aware that there is some work happening on the other end and work always takes time.","title":"Connecting Computers"},{"location":"course_material/computers/004_connecting_computers/#connecting-computers","text":"In the first chapter we discussed the various components that make up a computer. We also learned that you need to be very specific when telling it what to do, as there may be unintended consequences. However, we only went as far as discussing a single computer. These days, more often than not, computers are connected to each other through the internet. People make video calls and send emails, photos and videos to each other. We comment on news articles and even sway elections through social media. This area of computing is know as \u2018networking\u2019, and our society is relying on it more with each passing day. Working with one computer is complicated enough and things don\u2019t get any easier when you connect two of them together. In this section we will focus on the most common relationship that exists between two computers: the client and the server. For this we will leave our robot behind and head out for dinner - I know I certainly can\u2019t stand the thought of another ham and cheese sandwich.","title":"Connecting Computers"},{"location":"course_material/computers/004_connecting_computers/#eating-out","text":"We decide to go for Italian, because there is generally something for everyone at an Italian restaurant. When we arrive we are seated at a nice table in a quiet section of the building and start to think about how a restaurant works. We take a lot of everyday things for granted, so what if we break it down and think a bit deeper about exactly what happens when we go out for food. At our table is a menu, this was brought to us by our waiter. Now the waiter didn\u2019t create the menu and doesn\u2019t prepare the food that is presented on it, but he brings it to us so that we know what is available from the kitchen. From our table we can\u2019t actually see the kitchen and can\u2019t tell where it is, but that doesn\u2019t matter because the waiter knows where it is, how to get there and how to get back to our table. He has shown us what is on offer from the kitchen by bringing us the menu, now it is up to us to decide what we want. Once we know what we want, we tell the waiter and he will scurry off to let the kitchen know. We decide to share a pizza, so we ask the waiter \u2018one large margherita pizza please.\u2019 In the kitchen is a chef. The chef knows as little about us as we do about her. It isn\u2019t of any real concern to her where our table is or even who is sitting at it. She knows that she can prepare the food and trust the waiter to get it to us. She will remain there waiting on orders to come from the waiter and once she has them she can begin her work. This work takes time of course, as she will need to prepare all of the ingredients and organize them into a dish that we can eat. She is taking our request for a margherita pizza and turning it into an actual pizza. In the meantime we have no idea what is going on in the kitchen. We assume that the chef has received our order and that they are working diligently to prepare our food. We know that sometimes it can take a while, but we quietly hope that our pizza will arrive quickly. Unless explicitly stated by the menu we don\u2019t know what type of ingredients are being used. Organic flour and locally grown tomatoes? Or something straight out of a can? Most of the time it doesn\u2019t really matter to us, there is a degree of trust there that we are being served quality. The kitchen could also be dirty, we generally never know. Nevertheless we sit and wait patiently and sure enough our food comes within fifteen minutes. Thankfully it is exactly what we wanted - a beautiful fresh pizza with golden mozzarella and a crust that is perfectly crisp. As we devour our pizza we think about what just happened. The kitchen presented us with options, we made a choice and got what we wanted some time later. We did all of this without actually knowing where the kitchen is or how it works by simply talking to the waiter. We note the fact that this is largely a one-way operation. The kitchen has asked nothing of us, simply delivered what we want. Sure we sent our order out, but it was from a predefined list, it was a selection. Finally we pay and tip the waiter and then go on our way. Altogether it was an entirely uneventful evening out, and there wasn\u2019t a ham and cheese sandwich in sight (though admittedly a cheese pizza isn\u2019t exactly a million miles away). Now it\u2019s time for the fun part - what the hell did the little story above have to do with modern software development? Well believe it or not it was my attempt at explaining how the internet works.","title":"Eating Out"},{"location":"course_material/computers/004_connecting_computers/#clients-and-servers","text":"Earlier on I mentioned a type of relationship between two computers: the client-server relationship. You may be able to guess where I am going with this\u2026 in our story we were the client and the kitchen was the server. We are both computers, but one is requesting stuff (the menu, the food) and the other is serving stuff (the food, the bill). The hardworking waiter in this analogy is the internet. He is how information and data is exchanged between the client and server. He is a medium for us to communicate through, much like the air through which the sound travels when we speak. The internet itself is what is known as a network and it spans the entire globe, allowing people in the US to communicate with people in Australia instantaneously. Networks also exist on a smaller scale, like in an office for example - where every computer can share information, but only in that office. Your home may also have its own network. If you have wifi set up you have small network that is connected to the internet, allowing every phone/laptop/PC to communicate with each other and out over the internet. The word network isn\u2019t exclusive to computers. You may heard people refer to a road network, which is simply the system of interconnected roads that we drive on every day. How about a social network? This is a group of connected people, often communication through some shared medium (like Facebook or Twitter). How about networking at a conference or event, where you try to expand your professional circle and build a group of mutually beneficial relationships with other people in your particular industry. The key to all these different uses of the word is that it is all about connectivity.","title":"Clients and Servers"},{"location":"course_material/computers/004_connecting_computers/#the-world-wide-web","text":"In order to try and understand what is going on when we \u2018surf\u2019 the internet let\u2019s go back to our restaurant. To breakdown the interactions we had with the restaurant a little further let\u2019s start with how we got there. Imagine that the reason we chose this restaurant in the first place is because it was recommended to us by a friend. He told us that there is a restaurant called Mario\u2019s that does amazing food. That\u2019s all the information we had when we decided to go there but it wasn\u2019t enough information to actually get us there. We need an address. To get the address we went to Google maps and searched for Mario\u2019s, which promptly showed us it\u2019s location and even gave us directions to get there. This is not unlike what happens when we visit a website. If you want to visit a website you need to know its web address, which is usually in the form of \u2018www.thewebsitename.com\u2019. This web address is actually not enough information for our computer, just like the name of the restaurant was not enough information for us. The computer will need to look for a way to get to this website, so it finds what is called an IP address for the website, just like we looked up the address for Marios. This address takes the form of something like this \u2018192.168.1.1\u2019 ( would you like to know what the IP address of your computer is? Simply search google with the following \u2018what is my ip\u2019). Once it has this address the computer can actually begin the process of getting the website that we are looking for. Every computer that is connected to the internet must have an IP address (which stands for \u2018Internet Protocol address\u2019 and is not really important for us). If it didn\u2019t we wouldn\u2019t know how to communicate with it. Just like if our restaurant didn\u2019t have an address we wouldn\u2019t be able to find it. Knowing the address of the restaurant basically allows us to communicate with its kitchen, though we still need the waiter in order to do so. As soon as we arrive at the restaurant we are given a table and a menu. Having a table basically means that we have established a connection with the kitchen. We are now in a position to communicate with the kitchen. Getting our menu is just like viewing the homepage of a website. We are presented with a webpage that is showing us what is on offer from that website. If you go to your local news website, for example, you will likely see a list of recent news stories. A page full of headlines, and maybe an image per story, basically enough information to grab your attention. You can select any one of those news stories and you will then be given the whole article. By selecting from that list of news articles you were making a request. Just like we requested a pizza from the waiter in the restaurant, we are requesting a full news article from the news server. The news server will need to find the article you are looking for and send it back to you, not unlike how our Italian chef had to assemble our pizza. This will take some time, as you are no doubt probably aware. Some websites can take a frustratingly long time to display the content we want. There are several possible reasons for this that we will get into later, but for now we just need to be aware that there is some work happening on the other end and work always takes time.","title":"The World Wide Web"},{"location":"course_material/html_css/001_html_intro/","text":"","title":"001 html intro"},{"location":"course_material/html_css/002_html_2/","text":"","title":"002 html 2"},{"location":"course_material/html_css/003_html_3/","text":"","title":"003 html 3"},{"location":"course_material/html_css/004_styling_html/","text":"","title":"004 styling html"},{"location":"internship/internship/","text":"Your Internship Welcome to your own personal internship. In this section you will go through a rite of passage that all engineers must go through when they find their first job. First you must set up your Development Environment . This is the process of taking a computer and installing all of the software that you will need in order to actually working on the project you've been hired to work on. I won't lie - this can be tedious and annoying. Often times the process is poorly documented and engineers tend to do it once and forget the steps, so when someone new comes along things will be broken and people won't have answers as to why. Furthermore, software ages - new versions of programs and operating systems are released all of the time and the combination of software versions on your computer might combine in just the right way to may sure that nothing works as expected on your machine. The reason I'm telling you all of this is that you know it's not just you . You are not an idiot. Sometimes things and just hard and annoying. But we persevere, learn and eventually get through it. Once your development environment is setup we will move on to Onboarding . Onboarding is the process of learning how to work on a project. The idea is to 'get on board'. In our case you are free to focus on the areas that are of most interest to you. If you are interested in frontend development, web tech or graphics then you can spend most of your time working on those aspects of Varcade Games. If you want to experience the dark art of server side development you can focus on that. Onboarding is general - it will give you a broad exposure to everything. It will give you enough information to actually start making changes to the code and seeing what happens. Once you get there you are ready to actually start working on the project. This means: Fixing bugs Cleaning up code Building new features Writing tests At this point you can call yourself a software engineer!","title":"Overview"},{"location":"internship/internship/#your-internship","text":"Welcome to your own personal internship. In this section you will go through a rite of passage that all engineers must go through when they find their first job. First you must set up your Development Environment . This is the process of taking a computer and installing all of the software that you will need in order to actually working on the project you've been hired to work on. I won't lie - this can be tedious and annoying. Often times the process is poorly documented and engineers tend to do it once and forget the steps, so when someone new comes along things will be broken and people won't have answers as to why. Furthermore, software ages - new versions of programs and operating systems are released all of the time and the combination of software versions on your computer might combine in just the right way to may sure that nothing works as expected on your machine. The reason I'm telling you all of this is that you know it's not just you . You are not an idiot. Sometimes things and just hard and annoying. But we persevere, learn and eventually get through it. Once your development environment is setup we will move on to Onboarding . Onboarding is the process of learning how to work on a project. The idea is to 'get on board'. In our case you are free to focus on the areas that are of most interest to you. If you are interested in frontend development, web tech or graphics then you can spend most of your time working on those aspects of Varcade Games. If you want to experience the dark art of server side development you can focus on that. Onboarding is general - it will give you a broad exposure to everything. It will give you enough information to actually start making changes to the code and seeing what happens. Once you get there you are ready to actually start working on the project. This means: Fixing bugs Cleaning up code Building new features Writing tests At this point you can call yourself a software engineer!","title":"Your Internship"},{"location":"internship/onboarding/","text":"Code Over Time Welcome to the Code Over Time Onboarding course! Course content Onboarding is a process that you will likely go through many times throughout your career. It's usually the first thing you'll do when you start a new job and throughout your career you will likely 'onboard' on to many different projects. Each experience will be different. Not every team does onboarding the same way and some won't even have a formal process for onboarding. Throughout your career you'll also likely find yourself 'onboarding' others onto various different projects too. So this is an ongoing and constant process for software engineering teams and one that is crucial for any team that wants to be able to grow and adapt to the dynamic environment around them - which is most high performing teams. Considering all of the above, I figured an onboarding focused course was worth doing. The process can itself be challenging because understanding another person's code can be like trying to understand the inner workings of their mind. There are potentially years worth of design and product decisions implicit in the project you'll be working on. You weren't there when those decisions were made, but that doesn't mean they won't have a significant impact on your day to day work. I call this historical context , and it's an important part of onboarding. The more you understand about the product you're working on and its history, the more effective you will be as an engineer working on that project. Over the years I've found that the most effective way to onboard new team members is with a combination of documentation and hands-on tasks, and that is exactly what you will be doing in this course. The Tech Throughout this course you will work with code, markup and scripts using: Javascript Python HTML CSS Bash script And you will use industry standard and modern technologies, such as: Vue.js Django Node.js Flask Docker Linux Phaser 3 These lists may look intimidating now, but don't worry, you will have a lot of support in your journey. Learning outcomes By the time you're finished this course you'll understand how to: Run a set of micro services using Docker Set up an efficient developer workflow using Linux Run a web application with Vue.js Run application servers with Django & Flask Run a multi-player game with websockets How to approach this course There are a few things I want you to keep in mind as you go through this course - some guiding principles. Runners run, throwers throw and engineers engineer When asked how he trains track and field athletes, renowned strength coach Dan John answers: 1 2 3 4 5 Throwers throw. Jumpers jump. Sprinters sprint. Runners run. Hurdlers hurdle. I would like to add Software Engineers engineer to this list. The premise here is simple. If you want to get better at running you need to run. If you want to get better at jumping, you need to jump. Similarly, if you want to become a better Software Engineer then you need to engineer. The progress you make as a software engineer is directly related to amount of time you spend doing actual engineering work. Reading books and blogs, following online courses and watching videos are all useful resources to have and they will help (especially good engineering books that focus on patterns and ideas). But that's all theory. The bulk of your time should be spent on practical. I often say that engineering is surprisingly similar to sport in that you can watch others play a game and read all of the books in the world about that game, but that won't make you an athlete. You have to go play the game. And every game will be different. The opposition, the playing surface, the weather etc... You need to get out there and experience it. This is exactly why I have created Code Over Time - it is an environment in which you can get this real hands on experience. Little and often over the long haul Practicing something for 30 minutes every day over many weeks is far better than practicing something for 4 hours once a week. Consistent exposure is key, so try and build a habit of sitting down for a few minutes as often as possible and getting your hands dirty. Ideally you'd make at least 30 minutes a day available to work on becoming a software engineer. A lot more if possible. Give yourself time This point leads on from the last. This is a marathon, not a sprint - you can't know everything so don't try to cram it all in there. Taking short cuts as a beginner is a sure fire way to hinder your future progress. Take the time to really understand what you are doing. The secret to becoming a really good software engineer? Read code, write code, test code, design systems, release products and repeat for about 8 years. RTFM RTFM is a less than polite way of telling someone to see if the official documentation can answer their question. Understanding how to extract the information you need from documentation is vital. You will depend on documentation written by other people at every turn throughout your career. Some of it will be great (like Redis and Vue.js) and some will be awful (not going to call anyone out here). But that doesn't matter - you still need to figure it out, so get some practice in - read the official docs first whenever you get stuck. Code Over Time courses all include several documentation tasks, where you will need to go read some docs and try to understand the tech you are using. Set some goals What would you like to be able to do? Maybe you like to build your own game and add it to your own Varcade Games? Or perhaps you are interested in server tech and want to be able to optimize and push server systems to their limits. What ever it is, keep it in mind - but in the back of your mind. Focus day to day on getting through this course - your goals will shift and become more defined as you learn more. Head, meet wall There will be many points throughout this course where you will feel as if you are just banging your head against a wall and not making any progress. Embrace this feeling - it's all part of the journey. Perhaps more importantly, it will never go away. It doesn't matter how experienced you are or how good an engineer you are - there will be days where it feels as if computers are conspiring against you. Also remember that there will be moments of joy, accomplishment and satisfaction. Those moments never go away either - embrace them too! And finally Please try to have fun - it's only code. - Kev","title":"Introduction"},{"location":"internship/onboarding/#code-over-time","text":"Welcome to the Code Over Time Onboarding course!","title":"Code Over Time"},{"location":"internship/onboarding/#course-content","text":"Onboarding is a process that you will likely go through many times throughout your career. It's usually the first thing you'll do when you start a new job and throughout your career you will likely 'onboard' on to many different projects. Each experience will be different. Not every team does onboarding the same way and some won't even have a formal process for onboarding. Throughout your career you'll also likely find yourself 'onboarding' others onto various different projects too. So this is an ongoing and constant process for software engineering teams and one that is crucial for any team that wants to be able to grow and adapt to the dynamic environment around them - which is most high performing teams. Considering all of the above, I figured an onboarding focused course was worth doing. The process can itself be challenging because understanding another person's code can be like trying to understand the inner workings of their mind. There are potentially years worth of design and product decisions implicit in the project you'll be working on. You weren't there when those decisions were made, but that doesn't mean they won't have a significant impact on your day to day work. I call this historical context , and it's an important part of onboarding. The more you understand about the product you're working on and its history, the more effective you will be as an engineer working on that project. Over the years I've found that the most effective way to onboard new team members is with a combination of documentation and hands-on tasks, and that is exactly what you will be doing in this course.","title":"Course content"},{"location":"internship/onboarding/#the-tech","text":"Throughout this course you will work with code, markup and scripts using: Javascript Python HTML CSS Bash script And you will use industry standard and modern technologies, such as: Vue.js Django Node.js Flask Docker Linux Phaser 3 These lists may look intimidating now, but don't worry, you will have a lot of support in your journey.","title":"The Tech"},{"location":"internship/onboarding/#learning-outcomes","text":"By the time you're finished this course you'll understand how to: Run a set of micro services using Docker Set up an efficient developer workflow using Linux Run a web application with Vue.js Run application servers with Django & Flask Run a multi-player game with websockets","title":"Learning outcomes"},{"location":"internship/onboarding/#how-to-approach-this-course","text":"There are a few things I want you to keep in mind as you go through this course - some guiding principles.","title":"How to approach this course"},{"location":"internship/onboarding/#runners-run-throwers-throw-and-engineers-engineer","text":"When asked how he trains track and field athletes, renowned strength coach Dan John answers: 1 2 3 4 5 Throwers throw. Jumpers jump. Sprinters sprint. Runners run. Hurdlers hurdle. I would like to add Software Engineers engineer to this list. The premise here is simple. If you want to get better at running you need to run. If you want to get better at jumping, you need to jump. Similarly, if you want to become a better Software Engineer then you need to engineer. The progress you make as a software engineer is directly related to amount of time you spend doing actual engineering work. Reading books and blogs, following online courses and watching videos are all useful resources to have and they will help (especially good engineering books that focus on patterns and ideas). But that's all theory. The bulk of your time should be spent on practical. I often say that engineering is surprisingly similar to sport in that you can watch others play a game and read all of the books in the world about that game, but that won't make you an athlete. You have to go play the game. And every game will be different. The opposition, the playing surface, the weather etc... You need to get out there and experience it. This is exactly why I have created Code Over Time - it is an environment in which you can get this real hands on experience.","title":"Runners run, throwers throw and engineers engineer"},{"location":"internship/onboarding/#little-and-often-over-the-long-haul","text":"Practicing something for 30 minutes every day over many weeks is far better than practicing something for 4 hours once a week. Consistent exposure is key, so try and build a habit of sitting down for a few minutes as often as possible and getting your hands dirty. Ideally you'd make at least 30 minutes a day available to work on becoming a software engineer. A lot more if possible.","title":"Little and often over the long haul"},{"location":"internship/onboarding/#give-yourself-time","text":"This point leads on from the last. This is a marathon, not a sprint - you can't know everything so don't try to cram it all in there. Taking short cuts as a beginner is a sure fire way to hinder your future progress. Take the time to really understand what you are doing. The secret to becoming a really good software engineer? Read code, write code, test code, design systems, release products and repeat for about 8 years.","title":"Give yourself time"},{"location":"internship/onboarding/#rtfm","text":"RTFM is a less than polite way of telling someone to see if the official documentation can answer their question. Understanding how to extract the information you need from documentation is vital. You will depend on documentation written by other people at every turn throughout your career. Some of it will be great (like Redis and Vue.js) and some will be awful (not going to call anyone out here). But that doesn't matter - you still need to figure it out, so get some practice in - read the official docs first whenever you get stuck. Code Over Time courses all include several documentation tasks, where you will need to go read some docs and try to understand the tech you are using.","title":"RTFM"},{"location":"internship/onboarding/#set-some-goals","text":"What would you like to be able to do? Maybe you like to build your own game and add it to your own Varcade Games? Or perhaps you are interested in server tech and want to be able to optimize and push server systems to their limits. What ever it is, keep it in mind - but in the back of your mind. Focus day to day on getting through this course - your goals will shift and become more defined as you learn more.","title":"Set some goals"},{"location":"internship/onboarding/#head-meet-wall","text":"There will be many points throughout this course where you will feel as if you are just banging your head against a wall and not making any progress. Embrace this feeling - it's all part of the journey. Perhaps more importantly, it will never go away. It doesn't matter how experienced you are or how good an engineer you are - there will be days where it feels as if computers are conspiring against you. Also remember that there will be moments of joy, accomplishment and satisfaction. Those moments never go away either - embrace them too!","title":"Head, meet wall"},{"location":"internship/onboarding/#and-finally","text":"Please try to have fun - it's only code. - Kev","title":"And finally"},{"location":"internship/onboarding/closing_words/","text":"Well that's it - you are onboarded. Hopefully the process has been interesting, educational and fun. Now it's time to head over to the Hands-on Tasks section of your internship to get some tasks to work on. This is where the real learning will happen - by solving real problems in a real codebase.","title":"Next Steps"},{"location":"internship/onboarding/backend/intro/","text":"Now we're entering the depths of the server side. It's dark and full of terrors and our only guiding light is the logging and metrics we have in place. We're back in Python land and it's time to have a look at the Matchmaker and the Stats Tracker. These services are pure backend, meaning there have no visual interface at all. No client to speak of. Changes to this code aren't always immediately visible in our product. So when we're working with our backend services we need to be sure we have good logging in place as well as metrics to help us understand exactly what is going on. We won't dive too deep into these services just yet as this is an onboarding course and the goal is to get a high level view of everything. But we will look at key sections and concerns, such as transactional data management for our matchmaker and Redis streams for passing data around between our services. But first, a quick overview of both of our backend services. Matchmaker The Matchmaker is a service that allows players to connect with each other and player games over the internet. Our implementation of a Matchmaker is very basic, it simply manages a central store of games that players have created. When a player creates a game the matchmaker will make it public so that other players can see and join it. Once all players have joined a game the matchmaker will remove it from public view as no new players can join. Our matchmaker is also responsible for handling error scenarios. For example, what happens if a player creates a game but never joins it? Or what happens if two players try to join the same game at the same time but there is only one slot available? Or worse still, what happens if multiple players join a game, start playing, but then one of them leaves? These are the sorts of things we need to be thinking about when it comes to matchmaking. Stats Tracker The stats tracker is a very simply service. All it does is listen out for game events and then record some of them. It supports leaderboard tracking and player stat tracking. This means that any game hosted on Varcade Games can hook into the service and have its own leaderboard and player stats. In our case we track interesting stats like 'how many times does a player select Rock'. Redis Streams Both of these services are built on top of an in-memory database system called Redis. More specifically, we're using Redis Streams . It's worth having a look at the Redis docs and getting a sense of what it is before continuing with this section as both of our backend services rely heavily on Redis.","title":"Introduction"},{"location":"internship/onboarding/backend/intro/#matchmaker","text":"The Matchmaker is a service that allows players to connect with each other and player games over the internet. Our implementation of a Matchmaker is very basic, it simply manages a central store of games that players have created. When a player creates a game the matchmaker will make it public so that other players can see and join it. Once all players have joined a game the matchmaker will remove it from public view as no new players can join. Our matchmaker is also responsible for handling error scenarios. For example, what happens if a player creates a game but never joins it? Or what happens if two players try to join the same game at the same time but there is only one slot available? Or worse still, what happens if multiple players join a game, start playing, but then one of them leaves? These are the sorts of things we need to be thinking about when it comes to matchmaking.","title":"Matchmaker"},{"location":"internship/onboarding/backend/intro/#stats-tracker","text":"The stats tracker is a very simply service. All it does is listen out for game events and then record some of them. It supports leaderboard tracking and player stat tracking. This means that any game hosted on Varcade Games can hook into the service and have its own leaderboard and player stats. In our case we track interesting stats like 'how many times does a player select Rock'.","title":"Stats Tracker"},{"location":"internship/onboarding/backend/intro/#redis-streams","text":"Both of these services are built on top of an in-memory database system called Redis. More specifically, we're using Redis Streams . It's worth having a look at the Redis docs and getting a sense of what it is before continuing with this section as both of our backend services rely heavily on Redis.","title":"Redis Streams"},{"location":"internship/onboarding/backend/matchmaker/","text":"Key Concepts Creating a Game Understanding how the Matchmaker works is a lot easier with pictures, but even then it can look complicated - but don't worry it's actually quite simple. The following diagram shows what happens when a game is created and then the creator of the game joins the game (by join I mean actually connects to the game server). Take a moment to study this image before proceeding to the explanation of each step: Ok there's quite a lot going on there so let's break it down and look at it step by step. Immediately you should notice that we've not got multiple different services involved here. The is the first time we're seeing all of the various different components of Varcade Games all working together. 1. [Game Portal] Create Game via Matchmaker The first step in this process is opening up Varcade Games. Then we select a game and select multi-player mode. This should open the Matchmaker UI, which is our gateway to the Matchmaker. When a player chooses to create a new multi-player game a request is sent to the Matchmaker server. 2. [Matchmaker] Create Game on Game Server The Matchmaker server then needs to connect to the game server for the selected game and ask it to create a game. 3. [Game Server] Get Token The game server will create the game for the matchmaker and then return a token that can be used to connect to that game. 4. [Matchmaker] Add Game to pending set Once the remote game has been created the Matchmaker them adds the game to something called the 'Pending set'. We do this because we don't consider a game actually active until the player that created it actually joins. We're trying to avoid the scenario where players can join a game but the person who created it in the first place is not there and ready to play. 5. [Matchmaker] Return game token and server URL Once the game is created and in the set of pending games the Matchmaker returns the token for the game and the URL for the server that the game is running on. This will allow a game client to actually connect to the game on the game server. 6. [Game Portal] Pass token and server URL to Game Client The game portal is what receives the token and server URL from the Matchmaker, then it passes them on to the game client (Rock Paper Scissors Apocalypse in our case). 7. [Game Client] Connect to game server with the token Now the game client can actually connect to the game server. It does so by taking the server URL and attaching the token to it before opening a websocket connection. 8. [Game Server] Send 'creator joined' event from game server Once the server verifies the token and actually attaches that players connection to the newly created game it fires an event . This event is a message that gets added to a Redis Stream. At this point the player that created the game can select their character and then must sit and wait for another player to join their game. 9. [Matchmaker] Consume 'creator joined' event in Matchmaker On the other side of the Redis Stream our Matchmaker will receive the 'creator joined' event and handle it. 10. [Matchmaker] Remove the game from the pending set The Matchmaker will remove the game from the pending set as it is no longer pending - the creator has joined, so we are happy to now make that game available for other players to join. 11. [Matchmaker] Add the game to the lobby set The Lobby Set is the set of all games that are ready to be joined. Any games in this set will be displayed in the matchmaker UI as available to join. Hosts Inside our matchmaker we call any player that creates a game the host of that game. This is to differentiate between players that start a game and players that join a game. This allows us to make some simple decisions about game state. As we've already seen, a game cannot move from pending to lobby until the host joins the game. This is because we don't want to advertise a game for others to join if the person that created that game hasn't joined. This distinction between creator/host and joiner also matters when it comes to disconnects. If a player disconnects from a game we can put it back in the lobby set. If a host disconnects the game is destroyed. We don't have to do it like this, but a few simple constraints like this can greatly simplify our concepts and our code. That's it for game creation. Next let's look at what happens when a player joins a game. Joining a Game Having been through the 'create game' flow, hopefully this one is a lot easier to understand. Let's break this one down too and think about some of the details. 1. [Game Portal] Get open games request Before joining a game you need to know if there are games available to join in the first place. When you open the Matchmaker UI in the game portal it will automatically send a request to the Matchmaker server to get a list of currently open games. 2. [Matchmaker] Fetch open games These games come from the Lobby set we discussed in the previous section. 3. [Matchmaker] Return open game list to the client The Matchmaker server then returns all of the games that are open to join to the game portal. 4. [Game Portal] Send join game request to matchmaker The game portal can now send a join request and does so by sending the ID of the game it wants to join to the Matchmaker server. 5. [Matchmaker] Send join game request to game server The Matchmaker then needs to verify that this player can join the game (the game is not at capacity already). 6. [Matchmaker] Return token and server URL to Game Portal If the player can join the Matchmaker server will return the token for the game and the URL of the game server back to the game portal. 7. [Game Portal] Pass token and server URL to Game Client The game portal hands the token and game server URL off to the game client so it game join the game. 8. [Game Client] Connect to game server with the token The game client connects to the game server and the player is presented with the character selection scene. 9. [Game Server] Send 'all players joined' event from game server The game server will now send an another event out on the event stream. This time it is 'all player joined', signifying that the game server now has everything it needs to progress with the game. 10. [Matchmaker] Consume 'all players joined' event in Matchmaker The Matchmaker server is listening out for the 'all players joined' event. 11. [Matchmaker] Move game to the active set Once received it will remove the game from the Lobby set and add it to the Active set . This means the game will no longer show up in the Matchmaker UI. Note The Matchmaker also listens out for 'disconnect' and 'game over' events. If a non-host disconnects the game will be placed back into the 'Lobby set', where a new player can join. Once a 'game over' event is received the game will be removed from the Matchmaker database. Summary Hopefully this all makes sense at this point. The Matchmaker is just a middleman. It creates multi-player games on game servers on behalf of the players and monitors the state of those games via messages coming from the Redis Stream. The goal of the Matchmaker is to offload the burden of managing a multi-player lobby from the games. Any games that want to make use of the Varcade Games Matchmaker just need to register with the Matchmaker and conform to some API requirements. With that in mind, let's take a look at how to actually work with it.","title":"The Matchmaker"},{"location":"internship/onboarding/backend/matchmaker/#key-concepts","text":"","title":"Key Concepts"},{"location":"internship/onboarding/backend/matchmaker/#creating-a-game","text":"Understanding how the Matchmaker works is a lot easier with pictures, but even then it can look complicated - but don't worry it's actually quite simple. The following diagram shows what happens when a game is created and then the creator of the game joins the game (by join I mean actually connects to the game server). Take a moment to study this image before proceeding to the explanation of each step: Ok there's quite a lot going on there so let's break it down and look at it step by step. Immediately you should notice that we've not got multiple different services involved here. The is the first time we're seeing all of the various different components of Varcade Games all working together. 1. [Game Portal] Create Game via Matchmaker The first step in this process is opening up Varcade Games. Then we select a game and select multi-player mode. This should open the Matchmaker UI, which is our gateway to the Matchmaker. When a player chooses to create a new multi-player game a request is sent to the Matchmaker server. 2. [Matchmaker] Create Game on Game Server The Matchmaker server then needs to connect to the game server for the selected game and ask it to create a game. 3. [Game Server] Get Token The game server will create the game for the matchmaker and then return a token that can be used to connect to that game. 4. [Matchmaker] Add Game to pending set Once the remote game has been created the Matchmaker them adds the game to something called the 'Pending set'. We do this because we don't consider a game actually active until the player that created it actually joins. We're trying to avoid the scenario where players can join a game but the person who created it in the first place is not there and ready to play. 5. [Matchmaker] Return game token and server URL Once the game is created and in the set of pending games the Matchmaker returns the token for the game and the URL for the server that the game is running on. This will allow a game client to actually connect to the game on the game server. 6. [Game Portal] Pass token and server URL to Game Client The game portal is what receives the token and server URL from the Matchmaker, then it passes them on to the game client (Rock Paper Scissors Apocalypse in our case). 7. [Game Client] Connect to game server with the token Now the game client can actually connect to the game server. It does so by taking the server URL and attaching the token to it before opening a websocket connection. 8. [Game Server] Send 'creator joined' event from game server Once the server verifies the token and actually attaches that players connection to the newly created game it fires an event . This event is a message that gets added to a Redis Stream. At this point the player that created the game can select their character and then must sit and wait for another player to join their game. 9. [Matchmaker] Consume 'creator joined' event in Matchmaker On the other side of the Redis Stream our Matchmaker will receive the 'creator joined' event and handle it. 10. [Matchmaker] Remove the game from the pending set The Matchmaker will remove the game from the pending set as it is no longer pending - the creator has joined, so we are happy to now make that game available for other players to join. 11. [Matchmaker] Add the game to the lobby set The Lobby Set is the set of all games that are ready to be joined. Any games in this set will be displayed in the matchmaker UI as available to join. Hosts Inside our matchmaker we call any player that creates a game the host of that game. This is to differentiate between players that start a game and players that join a game. This allows us to make some simple decisions about game state. As we've already seen, a game cannot move from pending to lobby until the host joins the game. This is because we don't want to advertise a game for others to join if the person that created that game hasn't joined. This distinction between creator/host and joiner also matters when it comes to disconnects. If a player disconnects from a game we can put it back in the lobby set. If a host disconnects the game is destroyed. We don't have to do it like this, but a few simple constraints like this can greatly simplify our concepts and our code. That's it for game creation. Next let's look at what happens when a player joins a game.","title":"Creating a Game"},{"location":"internship/onboarding/backend/matchmaker/#joining-a-game","text":"Having been through the 'create game' flow, hopefully this one is a lot easier to understand. Let's break this one down too and think about some of the details. 1. [Game Portal] Get open games request Before joining a game you need to know if there are games available to join in the first place. When you open the Matchmaker UI in the game portal it will automatically send a request to the Matchmaker server to get a list of currently open games. 2. [Matchmaker] Fetch open games These games come from the Lobby set we discussed in the previous section. 3. [Matchmaker] Return open game list to the client The Matchmaker server then returns all of the games that are open to join to the game portal. 4. [Game Portal] Send join game request to matchmaker The game portal can now send a join request and does so by sending the ID of the game it wants to join to the Matchmaker server. 5. [Matchmaker] Send join game request to game server The Matchmaker then needs to verify that this player can join the game (the game is not at capacity already). 6. [Matchmaker] Return token and server URL to Game Portal If the player can join the Matchmaker server will return the token for the game and the URL of the game server back to the game portal. 7. [Game Portal] Pass token and server URL to Game Client The game portal hands the token and game server URL off to the game client so it game join the game. 8. [Game Client] Connect to game server with the token The game client connects to the game server and the player is presented with the character selection scene. 9. [Game Server] Send 'all players joined' event from game server The game server will now send an another event out on the event stream. This time it is 'all player joined', signifying that the game server now has everything it needs to progress with the game. 10. [Matchmaker] Consume 'all players joined' event in Matchmaker The Matchmaker server is listening out for the 'all players joined' event. 11. [Matchmaker] Move game to the active set Once received it will remove the game from the Lobby set and add it to the Active set . This means the game will no longer show up in the Matchmaker UI. Note The Matchmaker also listens out for 'disconnect' and 'game over' events. If a non-host disconnects the game will be placed back into the 'Lobby set', where a new player can join. Once a 'game over' event is received the game will be removed from the Matchmaker database.","title":"Joining a Game"},{"location":"internship/onboarding/backend/matchmaker/#summary","text":"Hopefully this all makes sense at this point. The Matchmaker is just a middleman. It creates multi-player games on game servers on behalf of the players and monitors the state of those games via messages coming from the Redis Stream. The goal of the Matchmaker is to offload the burden of managing a multi-player lobby from the games. Any games that want to make use of the Varcade Games Matchmaker just need to register with the Matchmaker and conform to some API requirements. With that in mind, let's take a look at how to actually work with it.","title":"Summary"},{"location":"internship/onboarding/backend/stats_tracker/","text":"We have reached the final service on our whirlwind tour of Varcade Games. The Stats Tracker . This service uses all of the same tech as the Matchmaker so we won't need to spend to long here. Its job is to listen our for game events and use that data to build leaderboards and player statistics for any games registered on Varcade Games. The code for this project is located in the stats_tracker directory of your project root. The project structure should be immediately familiar after looking at the Matchmaker project. In this section we'll check out a interesting aspects of the Stats Tracker and at the end you will run the project tests and checks yourself, just as you've done before on other projects. High Level View This hopefully all makes sense given the fact that the Stats Tracker works much the same way as the Matchmaker. It has a public API for the game portal to connect to. It uses this API to fetch leaderboards and player stats for different games. It also have a worker that runs in the background consuming events from the event stream and updating leaderboards and stats based on those events. Key Concepts There's an api.py in both the stats_tracker/leaderboards and stats_tracker/player_stats . The Game Portal calls the leaderboard API to check the current leaderboard for a registered game. The Player Stats API is where the Game Portal gets per player, per game player statistics. To manage all of this we use a pluggable system for calculating scores based on game events. A game can provide its own scoring logic or us the default system logic. Let's look at leaderboards first. Leaderboards Open up leaderboards/leaderboards.py . You will find two important functions here. register_leaderboard_handler record_result The first function allows you to register a leaderboard 'handler' for a game. The second allows you to record the result of a multiplayer game so that the game's leaderboard gets updated. The registration process is very similar to the WorkerManager -> Worker relationship we saw earlier. In this case we create an instance of a Leaderboard handler and register it against the ID for any game we want to register. Then when we get a game event, we read the product ID from the event and look up the appropriate handler. Once we have a leaderboard handler we can record a result. The record result function signature looks like this: 1 def record_result ( product_id : str , winner_id : str , loser_id : str ) -> bool : What the system will do is get both player's current scores and then update them based on who won. The default system leaderboard handler simple adds 1 point for every win. You could change this behavior for other games by adding new handlers that run ELO calculations or other more advanced leaderboard scoring. If you open leaderboards/handler.py you will find the default handler: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class LeaderboardHandler : \"\"\"This class can be overridden and registered as a leaderboard handler. This gives individual games the ability to handle more complex scoring, such as ELO \"\"\" def get_updated_scores ( self , winner_id , winner_current_score , loser_id , loser_current_score ): \"\"\" Default implementation with return current score + 1 for the winner and current score for the loser returns: tuple containing the new score for the winner and the new scores for the loser \"\"\" if winner_current_score is None : winner_current_score = 0 if loser_current_score is None : loser_current_score = 0 return ( winner_current_score + 1 , loser_current_score ) A valid Leaderboard handler class must include the get_updated_scores method. As you can see the default logic is pretty simple. To register leaderboard handlers you can add them in stats_tracker/app.py : 1 2 3 4 5 6 7 def init_stats_tracker ( db_url_str : str ): initialise_db ( db_url_str ) # Add stats handlers for all products here. logging . info ( \"Registering player stats handlers.\" ) register_player_stats_handler ( \"default\" , PlayerStatsHandler ()) register_leaderboard_handler ( \"default\" , LeaderboardHandler ()) register_player_stats_handler ( \"exrps\" , EXRPSStatsHandler ()) We register a single Leaderboard handler there, but we register two 'Player Stats Handlers', so lets have a look at why that is. Player Stats Open up player_stats/player_stats.py . You'll notice that it is more or less the same setup as for our Leaderboards. For Player Stats however, we have a track_event function instead of a record_result function. It does however do more or less the same thing. It looks up a handler for the given product ID and uses it to process the given event. If you open up player_stats/handlers.py you will see exactly what the handlers do. The first handler you will find is the PlayerStatsHandler . This is a generic handler that can read 'game_over' events coming from the game servers. It has some simple logic that will update redis with a win/loss value for each player referenced in the event. Any two player multi-player game that just wants to track wins and losses could just use this simple handler. Rock Paper Scissors Apocalypse wanted more though, so it gets a dedicated handler: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class EXRPSStatsHandler ( PlayerStatsHandler ): \"\"\"Event handler for exRPS specific multiplayer stats.\"\"\" def process_event ( self , event ): try : if event . get ( \"event_name\" ) == \"select_weapon\" : logging . info ( f \"EXRPSStatsHandler: Handling event: { event } \" ) user_id = event [ \"user_id\" ] selection = { \"null\" : \"botch\" , \"0\" : \"rock\" , \"1\" : \"paper\" , \"2\" : \"scissors\" , }[ event [ \"event_data\" ]] get_stats_tracker_db () . hincrby ( f \"_pstats: { event [ 'user_id' ] } : { event [ 'product_id' ] } \" , f \" { selection } _selection_count\" , 1 , ) else : super () . process_event ( event ) except KeyError : logging . warning ( f \"Invalid exRPS event received: { event } \" ) We don't need to go through this code in details, but you should notice that this logic all references concepts that are specific to the game. This handler is not useful at all outside of Rock Paper Scissors. But for that one game it's great, because we get to track people's weapon selections across every multi-player game they play. This is why we registered this specific handler against the product ID for Rock Paper Scissors Apocalypse, as discussed earlier. Workers Workers are back! The stats tracker only has a single worker type - an event worker. The implementation of Workers is the exact same as the Matchmaker. In fact it is the same code, just duplicated across both locations. Note You might be thinking 'but that's a terrible idea - why have the same code in two places?' and you would be right to think that. This will be the focus of a future refactoring task for you. The stats tracker does add some specialization though. It needs to listen for some different events. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if event_data . get ( b \"type\" , None ) == b \"game_over\" : logging . info ( f \"Processing Stream Event: { event_data } \" ) product_id = event_data [ b \"product_id\" ] . decode ( \"utf-8\" ) winner_id = event_data [ b \"winner_id\" ] . decode ( \"utf-8\" ) loser_id = event_data [ b \"loser_id\" ] . decode ( \"utf-8\" ) record_result ( product_id , winner_id , loser_id ) processed_event_count += 1 if event_data . get ( b \"product_id\" , None ) is not None : product_id = event_data [ b \"product_id\" ] . decode ( \"utf-8\" ) track_event ( product_id , { a . decode ( \"utf-8\" ): b . decode ( \"utf-8\" ) for a , b in event_data . items () }, ) The above code sample comes from stats_tracker/workers/event_stream_workers.py . This is where the worker decides if it needs to call record_result to update a leaderboard, which it does by checking if the event is a game_over type event. It also decides whether to call track_event in our player_stats package. If there is a product_id field specified we will attempt to track the events. In both cases it's up to the handlers we discussed earlier how to handle the data coming from the event. They might decide to do nothing with it or they might decide to save information to the database. That's all implementation specific. Running the tests At this point I think it's a good idea you to figure out this part on your own. The commands are all the same as for the Matchmaker, and the Game Portal server before that. You need to build and run a test image then run the tests, coverage and type checking.","title":"The Stats Tracker"},{"location":"internship/onboarding/backend/stats_tracker/#high-level-view","text":"This hopefully all makes sense given the fact that the Stats Tracker works much the same way as the Matchmaker. It has a public API for the game portal to connect to. It uses this API to fetch leaderboards and player stats for different games. It also have a worker that runs in the background consuming events from the event stream and updating leaderboards and stats based on those events.","title":"High Level View"},{"location":"internship/onboarding/backend/stats_tracker/#key-concepts","text":"There's an api.py in both the stats_tracker/leaderboards and stats_tracker/player_stats . The Game Portal calls the leaderboard API to check the current leaderboard for a registered game. The Player Stats API is where the Game Portal gets per player, per game player statistics. To manage all of this we use a pluggable system for calculating scores based on game events. A game can provide its own scoring logic or us the default system logic. Let's look at leaderboards first.","title":"Key Concepts"},{"location":"internship/onboarding/backend/stats_tracker/#leaderboards","text":"Open up leaderboards/leaderboards.py . You will find two important functions here. register_leaderboard_handler record_result The first function allows you to register a leaderboard 'handler' for a game. The second allows you to record the result of a multiplayer game so that the game's leaderboard gets updated. The registration process is very similar to the WorkerManager -> Worker relationship we saw earlier. In this case we create an instance of a Leaderboard handler and register it against the ID for any game we want to register. Then when we get a game event, we read the product ID from the event and look up the appropriate handler. Once we have a leaderboard handler we can record a result. The record result function signature looks like this: 1 def record_result ( product_id : str , winner_id : str , loser_id : str ) -> bool : What the system will do is get both player's current scores and then update them based on who won. The default system leaderboard handler simple adds 1 point for every win. You could change this behavior for other games by adding new handlers that run ELO calculations or other more advanced leaderboard scoring. If you open leaderboards/handler.py you will find the default handler: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class LeaderboardHandler : \"\"\"This class can be overridden and registered as a leaderboard handler. This gives individual games the ability to handle more complex scoring, such as ELO \"\"\" def get_updated_scores ( self , winner_id , winner_current_score , loser_id , loser_current_score ): \"\"\" Default implementation with return current score + 1 for the winner and current score for the loser returns: tuple containing the new score for the winner and the new scores for the loser \"\"\" if winner_current_score is None : winner_current_score = 0 if loser_current_score is None : loser_current_score = 0 return ( winner_current_score + 1 , loser_current_score ) A valid Leaderboard handler class must include the get_updated_scores method. As you can see the default logic is pretty simple. To register leaderboard handlers you can add them in stats_tracker/app.py : 1 2 3 4 5 6 7 def init_stats_tracker ( db_url_str : str ): initialise_db ( db_url_str ) # Add stats handlers for all products here. logging . info ( \"Registering player stats handlers.\" ) register_player_stats_handler ( \"default\" , PlayerStatsHandler ()) register_leaderboard_handler ( \"default\" , LeaderboardHandler ()) register_player_stats_handler ( \"exrps\" , EXRPSStatsHandler ()) We register a single Leaderboard handler there, but we register two 'Player Stats Handlers', so lets have a look at why that is.","title":"Leaderboards"},{"location":"internship/onboarding/backend/stats_tracker/#player-stats","text":"Open up player_stats/player_stats.py . You'll notice that it is more or less the same setup as for our Leaderboards. For Player Stats however, we have a track_event function instead of a record_result function. It does however do more or less the same thing. It looks up a handler for the given product ID and uses it to process the given event. If you open up player_stats/handlers.py you will see exactly what the handlers do. The first handler you will find is the PlayerStatsHandler . This is a generic handler that can read 'game_over' events coming from the game servers. It has some simple logic that will update redis with a win/loss value for each player referenced in the event. Any two player multi-player game that just wants to track wins and losses could just use this simple handler. Rock Paper Scissors Apocalypse wanted more though, so it gets a dedicated handler: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class EXRPSStatsHandler ( PlayerStatsHandler ): \"\"\"Event handler for exRPS specific multiplayer stats.\"\"\" def process_event ( self , event ): try : if event . get ( \"event_name\" ) == \"select_weapon\" : logging . info ( f \"EXRPSStatsHandler: Handling event: { event } \" ) user_id = event [ \"user_id\" ] selection = { \"null\" : \"botch\" , \"0\" : \"rock\" , \"1\" : \"paper\" , \"2\" : \"scissors\" , }[ event [ \"event_data\" ]] get_stats_tracker_db () . hincrby ( f \"_pstats: { event [ 'user_id' ] } : { event [ 'product_id' ] } \" , f \" { selection } _selection_count\" , 1 , ) else : super () . process_event ( event ) except KeyError : logging . warning ( f \"Invalid exRPS event received: { event } \" ) We don't need to go through this code in details, but you should notice that this logic all references concepts that are specific to the game. This handler is not useful at all outside of Rock Paper Scissors. But for that one game it's great, because we get to track people's weapon selections across every multi-player game they play. This is why we registered this specific handler against the product ID for Rock Paper Scissors Apocalypse, as discussed earlier.","title":"Player Stats"},{"location":"internship/onboarding/backend/stats_tracker/#workers","text":"Workers are back! The stats tracker only has a single worker type - an event worker. The implementation of Workers is the exact same as the Matchmaker. In fact it is the same code, just duplicated across both locations. Note You might be thinking 'but that's a terrible idea - why have the same code in two places?' and you would be right to think that. This will be the focus of a future refactoring task for you. The stats tracker does add some specialization though. It needs to listen for some different events. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if event_data . get ( b \"type\" , None ) == b \"game_over\" : logging . info ( f \"Processing Stream Event: { event_data } \" ) product_id = event_data [ b \"product_id\" ] . decode ( \"utf-8\" ) winner_id = event_data [ b \"winner_id\" ] . decode ( \"utf-8\" ) loser_id = event_data [ b \"loser_id\" ] . decode ( \"utf-8\" ) record_result ( product_id , winner_id , loser_id ) processed_event_count += 1 if event_data . get ( b \"product_id\" , None ) is not None : product_id = event_data [ b \"product_id\" ] . decode ( \"utf-8\" ) track_event ( product_id , { a . decode ( \"utf-8\" ): b . decode ( \"utf-8\" ) for a , b in event_data . items () }, ) The above code sample comes from stats_tracker/workers/event_stream_workers.py . This is where the worker decides if it needs to call record_result to update a leaderboard, which it does by checking if the event is a game_over type event. It also decides whether to call track_event in our player_stats package. If there is a product_id field specified we will attempt to track the events. In both cases it's up to the handlers we discussed earlier how to handle the data coming from the event. They might decide to do nothing with it or they might decide to save information to the database. That's all implementation specific.","title":"Workers"},{"location":"internship/onboarding/backend/stats_tracker/#running-the-tests","text":"At this point I think it's a good idea you to figure out this part on your own. The commands are all the same as for the Matchmaker, and the Game Portal server before that. You need to build and run a test image then run the tests, coverage and type checking.","title":"Running the tests"},{"location":"internship/onboarding/backend/workers/","text":"Back when you being introduced to the matchmaker you saw some diagrams that spoke of Redis Streams and Events. You were told the Matchmaker consumes data from an event stream and uses that data to move games around between the pending, lobby and active sets. The Matchmaker Worker is what is responsible for all of this. It is another application, distinct from our server code but using the same codebase, that we run on it's on server whose only job is to process these events. Entry Point Our Matchmaker Worker is just a Python process running on a Linux container. A worker can be started by running the code in matchmaker/game_worker.py . Most of the code in there is processing application args, setting up logging and metrics. The bits we're interested in are: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 worker_manager = WorkerManager () # 1. Create worker manager worker_manager . register_worker ( GameCurationWorker ( config )) # 2. Add worker worker_manager . register_worker ( GameEventWorker ( config . EVENT_STREAM_URL ) ) # 3. Add another one < snip > logging . info ( \"Starting worker main loop...\" ) while not sigHandler . terminate : # 4. Loop until terminate signal is received events_processed = 0 with s . time (): events_processed = worker_manager . run_workers () # 5.Run workers c . inc ( events_processed ) logging . info ( \"Termination signal received - stopping worker\" ) All we're doing here is creating an instance of something called a 'WorkerManager', adding some 'workers' to it and then running an infinite loop (until a terminate signal is received) and telling the 'worker manager' to 'run workers'. Lets run through the code, following the numbered comments: 'WorkerManager' is a custom class. It manages a collection of 'Worker' objects. Here we add a 'GameCurationWorker' to our WorkerManager. It's job is to look through the Pending, Lobby and Active sets to see if it needs to clean up any old or expired games. For example, a player may create a game but not join, which would leave that game sitting in the pending set forever. Here we add a 'GameEventWorker'. This worker listens for game events, specifically the 'creator_joined', 'all_players_joined' and 'game_over' events. It uses these events to update Matchmaker game data so that it has an accurate picture of the current game state. We run a loop until the application is closed. In this loop we call a method 'run_workers' of our worker manager. This method loops through all registered workers and runs their code. So essentially all this program does is call a set of functions over and over and over and over until the application is forcefully closed. The code for our workers is in matchmakers/workers . The Worker code The WorkerManager itself is very simple. Open up worker_manager.py . The first thing you'll find is an interface: 1 2 3 4 5 6 7 8 9 10 class AsyncWorker : \"\"\"Base class that needs to be implemented in order for an object to be registered with the Worker Manager. \"\"\" def run ( self ): raise NotImplementedError () def get_name ( self ): raise NotImplementedError () As the docstring says, in order for a worker to be registered with our WorkerManager it needs to implement a 'run' method and a 'get_name' method. The WorkerManager itself only has two methods: register_worker run_workers Registering a worker adds it to a list. Calling run_workers iterates over that list calling the 'run' method of the worker. Game Curation Open up game_management_workers.py . This is where our Game Curation Worker lives. The method we're most interested in is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def purge_expired_games ( self , product_id , batch_size = 10 ) -> int : \"\"\"Remove any games from the pending/lobby/active sets that have been inactive for too long. The oldest games are read from the three sets and deleted if the 'is_expired' property of the game object returns True. product_id (str):The ID of the product whose games are being cleaned up batch_size (int):The number of games to process on each run \"\"\" purged_game_count = 0 for game_id in self . dao . get_oldest_pending_games ( product_id , result_set_size = batch_size ): if self . purge_game_if_expired ( product_id , game_id ): purged_game_count += 1 for game_id in self . dao . get_oldest_lobby_games ( product_id , result_set_size = batch_size ): if self . purge_game_if_expired ( product_id , game_id ): purged_game_count += 1 for game_id in self . dao . get_oldest_active_games ( product_id , result_set_size = batch_size ): if self . purge_game_if_expired ( product_id , game_id ): purged_game_count += 1 return purged_game_count The code should be pretty self explanatory. It reads the oldest entries from from the Pending, Lobby and Active sets, checks if they have expired and purges them from the DB if they have. Each set has an expiry time that is configurable (see STATE_EXPIRY in matchmaker/game_data/models.py ). For example, a pending game will expire if the creator doesn't join within 60 seconds of creating it. Once the creator has joined their game will expire if no other player joins for 10 minutes. This worker's job is to keep our database nice and clean. Game Events The Game Event worker is another place in which the Matchmaker interfaces with the actual games that are using it. We saw earlier that our Matchmaker server will send HTTP requests to the game servers to create, join and remove games. But now the Matchmaker needs to listen to what is going on with the game servers, rather than issuing requests to them. Our Game Event worker is a bit more complex. It is reading events directly from a Redis Stream and depending on the event it will perform certain actions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 if event_data . get ( b \"type\" , None ) == b \"state_change\" : logging . info ( f \"Processing Stream Event: { event_data } \" ) self . update_game_state ( event_data [ b \"product_id\" ] . decode ( \"utf-8\" ), event_data [ b \"game_id\" ] . decode ( \"utf-8\" ), event_data [ b \"new_state\" ] . decode ( \"utf-8\" ), ) processed_event_count += 1 elif event_data . get ( b \"type\" , None ) == b \"game_removed\" : self . handle_game_removal ( event_data [ b \"product_id\" ] . decode ( \"utf-8\" ), event_data [ b \"game_id\" ] . decode ( \"utf-8\" ), ) processed_event_count += 1 elif event_data . get ( b \"type\" , None ) == b \"player_disconnect\" : self . handle_player_disconnect ( event_data [ b \"product_id\" ] . decode ( \"utf-8\" ), event_data [ b \"game_id\" ] . decode ( \"utf-8\" ), event_data [ b \"player_id\" ] . decode ( \"utf-8\" ), ) It cares about three events: state_change game_removed player_disconnect State Change The Matchmaker maintains it's own internal state for games: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # The game has been created CREATED = \"created\" # The creator of the game has joined the game # on the actual game server. Other players can # now join. CREATOR_JOINED = \"creator_joined\" # All required players have now joined. This signifies # that the game can be started ALL_PLAYERS_JOINED = \"all_players_joined\" # The game is in progress - the duration will vary from # game to game IN_PROGRESS = \"in_progress\" # The game has ended ENDED = \"ended\" We've talked about all of these states already. The game server sends out state_change events that the matchmaker uses to updates it's own state. Any game that wants to hook into the matchmaker should send these events. This worker will also take more specific action when the state changes to CREATOR_JOINED'. At this point the game needs to move to the Lobby set from the Pending set. Game Removed This event is a notification from the game server to say a game has been removed from the game server. The worker will try to remove any records of the game that it currently has. Player Disconnect In this case a non-host disconnected from an active game. Our worker needs to respond by placing the game back in the Lobby set so that they can try join again, or allow someone else to join. Working with the Workers From your build_tools directory run: 1 make ps You should see something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Name Command State Ports ----------------------------------------------------------------------------------------------------------------- game-portal /bin/sh -c gunicorn game_p ... Up 0 .0.0.0:8000->8000/tcp game-portal-client docker-entrypoint.sh npm r ... Up 0 .0.0.0:8002->8002/tcp game-rps docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8080->8080/tcp, 0 .0.0.0:8085->8085/tcp game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp gameportaldb docker-entrypoint.sh mysqld Up 0 .0.0.0:3306->3306/tcp, 33060 /tcp grafana /run.sh Up 0 .0.0.0:3001->3000/tcp matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp prometheus /bin/prometheus --config.f ... Up 0 .0.0.0:9090->9090/tcp redis-db docker-entrypoint.sh redis ... Up 0 .0.0.0:6379->6379/tcp stats-tracker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5000->5000/tcp stats-tracker-worker /bin/sh -c python stats_wo ... Up 0 .0.0.0:5002->5002/tcp The line we're interested in now is: 1 matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp This is the container that is running our Matchmaker worker. Note Note that there is a port exposed on this container 0.0.0.0:5051->5051/tcp . This isn't our worker exactly, it is a metrics server that were using to share metrics about the worker so that we can monitor its performance. All the usual commands work for this container: 1 2 3 4 5 make logs a=matchmaker-worker make build a=matchmaker-worker make start a=matchmaker-worker make restart a=matchmaker-worker make stop a=matchmaker-worker Tests You have already run the tests for the workers. Since our worker and server live in the one codebase, everything you did in the last section around running tests, coverage and type checking was also covering the worker code. You've now go enough information about the Matchmaker system to go exploring and hopefully make some sense of it all. There will be may more courses on this stuff available on codeovertime.com , so don't worry if this part is hard to follow. The onboarding course is just meant to get everything up and running with a general understanding of how it all works. Just enough so that you know where to look and what you need to learn.","title":"The Workers"},{"location":"internship/onboarding/backend/workers/#entry-point","text":"Our Matchmaker Worker is just a Python process running on a Linux container. A worker can be started by running the code in matchmaker/game_worker.py . Most of the code in there is processing application args, setting up logging and metrics. The bits we're interested in are: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 worker_manager = WorkerManager () # 1. Create worker manager worker_manager . register_worker ( GameCurationWorker ( config )) # 2. Add worker worker_manager . register_worker ( GameEventWorker ( config . EVENT_STREAM_URL ) ) # 3. Add another one < snip > logging . info ( \"Starting worker main loop...\" ) while not sigHandler . terminate : # 4. Loop until terminate signal is received events_processed = 0 with s . time (): events_processed = worker_manager . run_workers () # 5.Run workers c . inc ( events_processed ) logging . info ( \"Termination signal received - stopping worker\" ) All we're doing here is creating an instance of something called a 'WorkerManager', adding some 'workers' to it and then running an infinite loop (until a terminate signal is received) and telling the 'worker manager' to 'run workers'. Lets run through the code, following the numbered comments: 'WorkerManager' is a custom class. It manages a collection of 'Worker' objects. Here we add a 'GameCurationWorker' to our WorkerManager. It's job is to look through the Pending, Lobby and Active sets to see if it needs to clean up any old or expired games. For example, a player may create a game but not join, which would leave that game sitting in the pending set forever. Here we add a 'GameEventWorker'. This worker listens for game events, specifically the 'creator_joined', 'all_players_joined' and 'game_over' events. It uses these events to update Matchmaker game data so that it has an accurate picture of the current game state. We run a loop until the application is closed. In this loop we call a method 'run_workers' of our worker manager. This method loops through all registered workers and runs their code. So essentially all this program does is call a set of functions over and over and over and over until the application is forcefully closed. The code for our workers is in matchmakers/workers .","title":"Entry Point"},{"location":"internship/onboarding/backend/workers/#the-worker-code","text":"The WorkerManager itself is very simple. Open up worker_manager.py . The first thing you'll find is an interface: 1 2 3 4 5 6 7 8 9 10 class AsyncWorker : \"\"\"Base class that needs to be implemented in order for an object to be registered with the Worker Manager. \"\"\" def run ( self ): raise NotImplementedError () def get_name ( self ): raise NotImplementedError () As the docstring says, in order for a worker to be registered with our WorkerManager it needs to implement a 'run' method and a 'get_name' method. The WorkerManager itself only has two methods: register_worker run_workers Registering a worker adds it to a list. Calling run_workers iterates over that list calling the 'run' method of the worker.","title":"The Worker code"},{"location":"internship/onboarding/backend/workers/#game-curation","text":"Open up game_management_workers.py . This is where our Game Curation Worker lives. The method we're most interested in is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def purge_expired_games ( self , product_id , batch_size = 10 ) -> int : \"\"\"Remove any games from the pending/lobby/active sets that have been inactive for too long. The oldest games are read from the three sets and deleted if the 'is_expired' property of the game object returns True. product_id (str):The ID of the product whose games are being cleaned up batch_size (int):The number of games to process on each run \"\"\" purged_game_count = 0 for game_id in self . dao . get_oldest_pending_games ( product_id , result_set_size = batch_size ): if self . purge_game_if_expired ( product_id , game_id ): purged_game_count += 1 for game_id in self . dao . get_oldest_lobby_games ( product_id , result_set_size = batch_size ): if self . purge_game_if_expired ( product_id , game_id ): purged_game_count += 1 for game_id in self . dao . get_oldest_active_games ( product_id , result_set_size = batch_size ): if self . purge_game_if_expired ( product_id , game_id ): purged_game_count += 1 return purged_game_count The code should be pretty self explanatory. It reads the oldest entries from from the Pending, Lobby and Active sets, checks if they have expired and purges them from the DB if they have. Each set has an expiry time that is configurable (see STATE_EXPIRY in matchmaker/game_data/models.py ). For example, a pending game will expire if the creator doesn't join within 60 seconds of creating it. Once the creator has joined their game will expire if no other player joins for 10 minutes. This worker's job is to keep our database nice and clean.","title":"Game Curation"},{"location":"internship/onboarding/backend/workers/#game-events","text":"The Game Event worker is another place in which the Matchmaker interfaces with the actual games that are using it. We saw earlier that our Matchmaker server will send HTTP requests to the game servers to create, join and remove games. But now the Matchmaker needs to listen to what is going on with the game servers, rather than issuing requests to them. Our Game Event worker is a bit more complex. It is reading events directly from a Redis Stream and depending on the event it will perform certain actions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 if event_data . get ( b \"type\" , None ) == b \"state_change\" : logging . info ( f \"Processing Stream Event: { event_data } \" ) self . update_game_state ( event_data [ b \"product_id\" ] . decode ( \"utf-8\" ), event_data [ b \"game_id\" ] . decode ( \"utf-8\" ), event_data [ b \"new_state\" ] . decode ( \"utf-8\" ), ) processed_event_count += 1 elif event_data . get ( b \"type\" , None ) == b \"game_removed\" : self . handle_game_removal ( event_data [ b \"product_id\" ] . decode ( \"utf-8\" ), event_data [ b \"game_id\" ] . decode ( \"utf-8\" ), ) processed_event_count += 1 elif event_data . get ( b \"type\" , None ) == b \"player_disconnect\" : self . handle_player_disconnect ( event_data [ b \"product_id\" ] . decode ( \"utf-8\" ), event_data [ b \"game_id\" ] . decode ( \"utf-8\" ), event_data [ b \"player_id\" ] . decode ( \"utf-8\" ), ) It cares about three events: state_change game_removed player_disconnect","title":"Game Events"},{"location":"internship/onboarding/backend/workers/#state-change","text":"The Matchmaker maintains it's own internal state for games: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # The game has been created CREATED = \"created\" # The creator of the game has joined the game # on the actual game server. Other players can # now join. CREATOR_JOINED = \"creator_joined\" # All required players have now joined. This signifies # that the game can be started ALL_PLAYERS_JOINED = \"all_players_joined\" # The game is in progress - the duration will vary from # game to game IN_PROGRESS = \"in_progress\" # The game has ended ENDED = \"ended\" We've talked about all of these states already. The game server sends out state_change events that the matchmaker uses to updates it's own state. Any game that wants to hook into the matchmaker should send these events. This worker will also take more specific action when the state changes to CREATOR_JOINED'. At this point the game needs to move to the Lobby set from the Pending set.","title":"State Change"},{"location":"internship/onboarding/backend/workers/#game-removed","text":"This event is a notification from the game server to say a game has been removed from the game server. The worker will try to remove any records of the game that it currently has.","title":"Game Removed"},{"location":"internship/onboarding/backend/workers/#player-disconnect","text":"In this case a non-host disconnected from an active game. Our worker needs to respond by placing the game back in the Lobby set so that they can try join again, or allow someone else to join.","title":"Player Disconnect"},{"location":"internship/onboarding/backend/workers/#working-with-the-workers","text":"From your build_tools directory run: 1 make ps You should see something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Name Command State Ports ----------------------------------------------------------------------------------------------------------------- game-portal /bin/sh -c gunicorn game_p ... Up 0 .0.0.0:8000->8000/tcp game-portal-client docker-entrypoint.sh npm r ... Up 0 .0.0.0:8002->8002/tcp game-rps docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8080->8080/tcp, 0 .0.0.0:8085->8085/tcp game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp gameportaldb docker-entrypoint.sh mysqld Up 0 .0.0.0:3306->3306/tcp, 33060 /tcp grafana /run.sh Up 0 .0.0.0:3001->3000/tcp matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp prometheus /bin/prometheus --config.f ... Up 0 .0.0.0:9090->9090/tcp redis-db docker-entrypoint.sh redis ... Up 0 .0.0.0:6379->6379/tcp stats-tracker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5000->5000/tcp stats-tracker-worker /bin/sh -c python stats_wo ... Up 0 .0.0.0:5002->5002/tcp The line we're interested in now is: 1 matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp This is the container that is running our Matchmaker worker. Note Note that there is a port exposed on this container 0.0.0.0:5051->5051/tcp . This isn't our worker exactly, it is a metrics server that were using to share metrics about the worker so that we can monitor its performance. All the usual commands work for this container: 1 2 3 4 5 make logs a=matchmaker-worker make build a=matchmaker-worker make start a=matchmaker-worker make restart a=matchmaker-worker make stop a=matchmaker-worker","title":"Working with the Workers"},{"location":"internship/onboarding/backend/workers/#tests","text":"You have already run the tests for the workers. Since our worker and server live in the one codebase, everything you did in the last section around running tests, coverage and type checking was also covering the worker code. You've now go enough information about the Matchmaker system to go exploring and hopefully make some sense of it all. There will be may more courses on this stuff available on codeovertime.com , so don't worry if this part is hard to follow. The onboarding course is just meant to get everything up and running with a general understanding of how it all works. Just enough so that you know where to look and what you need to learn.","title":"Tests"},{"location":"internship/onboarding/backend/working_with_matchmaker/","text":"In this section we'll take a high level tour of the Matchmaker could, pointing out key some key areas and concepts. Prerequisites At this point you should have your full Varcade Games stack up and running, but before proceeding let's double check. From your build_tools directory run: 1 make ps You should see something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Name Command State Ports ----------------------------------------------------------------------------------------------------------------- game-portal /bin/sh -c gunicorn game_p ... Up 0 .0.0.0:8000->8000/tcp game-portal-client docker-entrypoint.sh npm r ... Up 0 .0.0.0:8002->8002/tcp game-rps docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8080->8080/tcp, 0 .0.0.0:8085->8085/tcp game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp gameportaldb docker-entrypoint.sh mysqld Up 0 .0.0.0:3306->3306/tcp, 33060 /tcp grafana /run.sh Up 0 .0.0.0:3001->3000/tcp matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp prometheus /bin/prometheus --config.f ... Up 0 .0.0.0:9090->9090/tcp redis-db docker-entrypoint.sh redis ... Up 0 .0.0.0:6379->6379/tcp stats-tracker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5000->5000/tcp stats-tracker-worker /bin/sh -c python stats_wo ... Up 0 .0.0.0:5002->5002/tcp The line you're interested in is: 1 matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp This is our dev build of the game client. Notice at the end of the line: 1 0 .0.0.0:5050 This is telling us that the container is listening on port 5050... so let's try it. In your browser enter 'localhost:5050' in the URL bar and hit enter. If your setup is working you should see an error. But why would you see an error if the setup is working? The error should look like this: 1 2 3 Not Found The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again. This is because when using the Matchmaker you need to interact with it using specific URLs that we have defined in our Application Programming Interface (API). More on this below! Entry point The Matchmaker code is located in varcade_games/matchmaker/matchmaker . The actual entry point to the code is in app.py . This is the code we run to start the server. It creates and initializes a ' Flask app. It is a 'micro framework' that allows us to run a lightweight HTTP server. We will use it to create the endpoints that the Matchmaker UI will send create/join game requests to. This is the Matchmaker API . API The definition of the Matchmaker API can be found in matchmaker/lobby/api.py . There you will find functions with signatures like this: 1 2 3 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) def create_new_game ( product_id ): ... This is how we register an endpoint with Flask and it is using the concepts of ' Blueprints ' in Flask. The blueprint for our lobby is defined earlier in the api.py file: 1 game_lobby = Blueprint ( \"game_lobby\" , __name__ ) Here we simple create a blueprint called 'game_lobby'. Back in app.py you can see where this blueprint gets registered with Flask: 1 app . register_blueprint ( game_lobby , url_prefix = \"/game_lobby\" ) This is basically our way to telling Flask \"I have a bunch of endpoints I'd like you know know about, they're group conceptually into something I'm calling a lobby\". Once you run the serve you can access your endpoint by visiting the URL of you server and giving the path for your blueprint. So in the above example we register our blueprint with a url_prefix . This means that when ever we access our lobby we will have to use a path like this: 1 http://localhost/game_lobby Now lets jump back to the endpoint mentioned earlier: 1 2 3 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) def create_new_game ( product_id ): ... Here we use a decorator to add a route to our blueprint. We also give a path for this endpoint. Let's deconstruct this decorator: 1 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) Basically we are adding a 'route' or and endpoint to our game_lobby blueprint. We are giving that endpoint a path /<product_id>/create_game . The bit inside the <angled brackets> is important here. This endpoint is about creating a game, but what game? Our Matchmaker is generic so we could be trying to create a multi-player game for any game that is registered with the game portal. We've only registered one game so far, Rock Paper Scissors, and we gave it the ID 'exrps'. So if we want to create a game our endpoint now looks like this: 1 http://localhost/game_lobby/exrps/create_game So a request to this URL will connect to the local server, hit the game_lobby blueprint and then get mapped to the <product_id>/create_game route. Once Flask has matched a URL to a route it will extract that product ID and give it as an argument to the function the route is attached to: 1 2 3 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) def create_new_game ( product_id ): ... So our create_new_game function is passed the 'product_id' that gets extracted from the URL, which is enough information for it to go ahead and create a game. Lobby Endpoints We've defined three endpoints in our Matchmaker API: 1 2 3 4 5 6 7 8 # Create a new multi-player game @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) # Join and existing multi-player game @game_lobby . route ( \"/<product_id>/join_game/<game_id>\" , methods = [ \"POST\" ]) # Fetch all games that are currently open to join @game_lobby . route ( \"/<product_id>/open_games\" , methods = [ \"GET\" ]) These endpoints provide the functionality we discussed in the previous section. All of them require that we specify a product ID so that Matchmaker knows what game it is working with. The create and join are the more interesting endpoints because, as mentioned in the last section, they need to talk to the game server. Game Server API In matchmaker/core/game_server_api.py you will find the the code that allows the Matchmaker to send requests to the game servers. In order for a game to use this Matchmaker for managing games and player connections to those games it must provide a set of endpoints that conform to what is defined here. For example, the first function in this file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def send_create_game_request ( user_id , user_name , game_id , game_server ): \"\"\"Sends a 'create game' request to the remote game server. :param str user_id: The ID of the user creating the game :param str user_name: The username of the user creating the game :param str game_id: UID of the new game being created :param matchmaker.core.GameServer game_server: the target game server :returns: A dict containing the 'token' for the game that was created :rtype: dict :raises GameServerNetworkError: If the response from the remote game server is not a 200 \"\"\" request_data = { \"gameId\" : game_id , \"userId\" : user_id , \"username\" : user_name } return _send_request ( game_server , \"create_game\" , request_data ) This function with send a 'create_game' request to a game server, just like we saw in the diagrams in the previous section. The Matchmaker expects that any game server that has been registered with it has some endpoint: <game_server_url>/create_game The endpoint should also take a gameId , userId and username as input data. If the game server does not have this endpoint then the Matchmaker will not be able to interact with it. The game server API has four endpoints that are expected to be implemented by game servers: 1 2 3 4 create_game - Create a new game on the remote game server join_game - Join an existing game on the remote server remove_game - Remove a game from the remote server remove_player - Remove a player from a remote game on a remote server If you open up game_rps/server/game_server/app.js you will find all of these endpoints are defined there: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 app . post ( '/create_game' , function ( req , res ) { ... }) app . post ( '/join_game' , function ( req , res ) { ... }) app . post ( '/remove_game' , function ( req , res ) { ... }) app . post ( '/remove_player' , function ( req , res ) { ... }) This is why our Matchmaker is able to create games on the Rock Paper Scissors Apocalypse server. But our Matchmaker doesn't just send requests to game servers in order to organize games, it needs to keep its own records of the games it have created and it needs to curate those records. Time to take a look at the data layer. DAO A DAO or Data Access Object gives us an abstracted interface to manage Matchmaker game data. It is one of the more complex parts of the code and also the most important. With the matchmaker we have to account for a lot data consistency challenges, like what happens if two players try to join the same game at the exact same time? The DAO aims to account for that while also providing a relatively straight forward interface to us in the Matchmaker API. The DAO code is in matchmaker/game_data/dao.py , but before we dig in there let's take a look at it in action. Here is the the code that creates a game using the DAO in our Matchmaker API: 1 2 3 4 5 6 7 8 9 10 11 12 new_game = Game ( uuid . uuid4 () . hex , product_id , game_server . game_server_url , user_profile . user_id , user_profile . username , ** game_server . settings , ) < snip > get_game_dao () . create_game ( new_game ) All we need to do is create a Game object with the required attributes and then called get_game_dao() to get a reference to our DAO and then call the create_game() function on it. This DAO function will take care of adding our game data to our database as well as adding it to the pending set. In fact anyone using the DAO doesn't need to know anything about pending, active or lobby sets. As the user of the DAO you are just creating, joining and fetching lists of games. You don't need to know anything about how that data is managed behind the scenes. I'm not going to say much more about the DAO - there will be a dedicated course for that. For now you can explore yourself and see if you can figure out what is going on. Making Changes Making changes to our backend services is a bit different since it doesn't have some UI you can test directly. In order to test to Matchmaker you need the whole Varcade Games stack running so you can verify that it is talking to game server correctly, listening out for events correctly and that its API is working as expected. A robust set of tests is essential for any server side application, and our Matchmaker is not exception. Running the Tests In your terminal navigate over to the server directory for the website. For example, if your code is located in ~/code/varcade_games then you'd run: 1 cd ~/code/varcade_games/matchmaker Just like the Game Portal tests we ran earlier, our tests use a docker image. We build an image with all of the code and tests, then we run the container and run the tests. This gives us a consistent environment to run our tests in - us and everyone else running these tests will be running with the same dependencies and configurations. If we just ran the tests on our dev machine we could get different results due to different configuration. I've abstracted away most of the complexity of running the tests so all you need to do is run: 1 make build_test_image This may take a while... Next we run the image as follows: 1 make run_test_image_mounted Once it's done you can run the following make commands to run the actual tests: 1 make run_tests You should see a whole lot of output after running that command, and it hopefully ends with something like the following: 1 ======== 97 passed, 44 warnings in 2 .55s ======== (There are a few warnings... but the tests pass!) These tests test the functionality of the matchmaker - they tell us if something functional broke. So let's break something... Open up matchmaker/lobby/api.py . Find the function called get_open_games . This is the API endpoint that returns the list of open games that players can join. Change the following line: 1 2 3 4 5 available_games = get_game_dao () . get_available_games ( product_id , page_index , min ( entry_count , current_app . config [ \"LOBBY_MAX_PAGE_SIZE\" ]), ) to 1 2 3 4 5 available_games = get_game_dao () . get_available_games ( 'test, page_index , min ( entry_count , current_app . config [ \"LOBBY_MAX_PAGE_SIZE\" ]), ) All we're doing here is making it so the endpoint ignores the product ID given to it and simply inserts 'test'. We should expect this to break some stuff since we need a valid product ID in order to fetch any open games for that product. Run the tests again with make run_tests . The out put should have changed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #<snip> self = <test_api.TestFindGameAPI object at 0x7f4ae7c64f90>, test_client = <FlaskClient <Flask 'app' >> def test_view_available_games_success ( self, test_client ) : response = test_client.get ( f \"game_lobby/{self.test_game.product_id}/open_games\" , headers =[( \"Content-Type\" , \"application/json\" )] , ) # No games create yet assert len ( json.loads ( response.data )) == 0 self.dao.create_game ( self.test_game ) self.dao.publish_game ( self.test_game ) response = test_client.get ( f \"game_lobby/{self.test_game.product_id}/open_games\" , headers =[( \"Content-Type\" , \"application/json\" )] , ) game_list = json.loads ( response.data ) > assert len ( game_list ) == 1 E assert 0 == 1 E +0 E -1 tests/lobby/test_api.py:446: AssertionError #<snip> ========== 2 failed, 95 passed, 42 warnings in 2 .63s =================== In this output we can see that we now have a failing test. It is failing for the exact reason we made it fail. We have a test that tries to fetch a list of open games for a specific game: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def test_view_available_games_success ( self , test_client ): # Send a request to the 'open_games' endpoint response = test_client . get ( f \"game_lobby/ { self . test_game . product_id } /open_games\" , headers = [( \"Content-Type\" , \"application/json\" )], ) # No games create yet assert len ( json . loads ( response . data )) == 0 # Manually create a game self . dao . create_game ( self . test_game ) self . dao . publish_game ( self . test_game ) # Fetch list of available games response = test_client . get ( f \"game_lobby/ { self . test_game . product_id } /open_games\" , headers = [( \"Content-Type\" , \"application/json\" )], ) game_list = json . loads ( response . data ) # Our test fails here assert len ( game_list ) == 1 assert game_list [ 0 ][ \"game_id\" ] == self . test_game . game_id The reason our test is now failing is because it creates a game with a product ID of 'test_game.product_id', BUT our change just overwrites the actual product ID with 'test'. This results in our endpoint returning an empty list since 'test' is not a valid game and therefore can't have any open games. Revert the change and run the tests again to see them passing once again. Coverage Now try running: 1 make run_coverage This tells us how much of our code is covered by tests: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ----------- coverage: platform linux, python 3 .7.8-final-0 ----------- Name Stmts Miss Cover Missing ----------------------------------------------------------------------------- matchmaker/__init__.py 0 0 100 % matchmaker/app.py 28 2 93 % 25 , 49 matchmaker/config.py 34 4 88 % 53 , 56 -58 matchmaker/core/__init__.py 0 0 100 % matchmaker/core/game_server_api.py 30 0 100 % matchmaker/core/game_servers.py 29 0 100 % matchmaker/game_data/__init__.py 0 0 100 % matchmaker/game_data/dao.py 110 0 100 % matchmaker/game_data/models.py 122 2 98 % 69 , 168 matchmaker/game_worker.py 40 40 0 % 1 -67 matchmaker/lobby/__init__.py 0 0 100 % matchmaker/lobby/api.py 94 0 100 % matchmaker/workers/__init__.py 0 0 100 % matchmaker/workers/event_stream_workers.py 79 4 95 % 89 -93, 103 -107 matchmaker/workers/game_management_workers.py 60 1 98 % 115 matchmaker/workers/worker_manager.py 33 2 94 % 61 -62 ----------------------------------------------------------------------------- TOTAL 659 55 92 % AS I mentioned before, code coverage is a useful indicator about how much test coverage you have but it's important to understand that 100% coverage doesn't mean you have bug free or high quality code. Don't use coverage it as a target, use it as a guide. Type Checking For our Python projects we also have some type checking. Python is a dynamically typed language, meaning we have no compiler to tell us about errors and we often have to wait until we are running the code to know whether it even runs. Enter Mypy. Mypy is a static type checker that will analyze our code and tell us if there is any in there that might be problematic. You can run the type checker against the game portal by running: 1 make run_type_checking Which should result in some output like: 1 2 3 4 5 6 7 8 echo \"Running Mypy against web app\" && \\ mypy --ignore-missing-imports app.py && \\ echo \"Running Mypy against game worker\" && \\ mypy --ignore-missing-imports game_worker.py ' Running Mypy against web app Success: no issues found in 1 source file Running Mypy against game worker Success: no issues found in 1 source file You should run your tests and type checking before you commit any changes to the repository. That's it for the Matchmaker for now. The Matchmaker server at least - you may have noticed that I have yet to mention anything about the event stream events we looked at in the last section. We need to talk about workers...","title":"Working with the Matchmaker"},{"location":"internship/onboarding/backend/working_with_matchmaker/#prerequisites","text":"At this point you should have your full Varcade Games stack up and running, but before proceeding let's double check. From your build_tools directory run: 1 make ps You should see something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Name Command State Ports ----------------------------------------------------------------------------------------------------------------- game-portal /bin/sh -c gunicorn game_p ... Up 0 .0.0.0:8000->8000/tcp game-portal-client docker-entrypoint.sh npm r ... Up 0 .0.0.0:8002->8002/tcp game-rps docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8080->8080/tcp, 0 .0.0.0:8085->8085/tcp game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp gameportaldb docker-entrypoint.sh mysqld Up 0 .0.0.0:3306->3306/tcp, 33060 /tcp grafana /run.sh Up 0 .0.0.0:3001->3000/tcp matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp prometheus /bin/prometheus --config.f ... Up 0 .0.0.0:9090->9090/tcp redis-db docker-entrypoint.sh redis ... Up 0 .0.0.0:6379->6379/tcp stats-tracker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5000->5000/tcp stats-tracker-worker /bin/sh -c python stats_wo ... Up 0 .0.0.0:5002->5002/tcp The line you're interested in is: 1 matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp This is our dev build of the game client. Notice at the end of the line: 1 0 .0.0.0:5050 This is telling us that the container is listening on port 5050... so let's try it. In your browser enter 'localhost:5050' in the URL bar and hit enter. If your setup is working you should see an error. But why would you see an error if the setup is working? The error should look like this: 1 2 3 Not Found The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again. This is because when using the Matchmaker you need to interact with it using specific URLs that we have defined in our Application Programming Interface (API). More on this below!","title":"Prerequisites"},{"location":"internship/onboarding/backend/working_with_matchmaker/#entry-point","text":"The Matchmaker code is located in varcade_games/matchmaker/matchmaker . The actual entry point to the code is in app.py . This is the code we run to start the server. It creates and initializes a ' Flask app. It is a 'micro framework' that allows us to run a lightweight HTTP server. We will use it to create the endpoints that the Matchmaker UI will send create/join game requests to. This is the Matchmaker API .","title":"Entry point"},{"location":"internship/onboarding/backend/working_with_matchmaker/#api","text":"The definition of the Matchmaker API can be found in matchmaker/lobby/api.py . There you will find functions with signatures like this: 1 2 3 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) def create_new_game ( product_id ): ... This is how we register an endpoint with Flask and it is using the concepts of ' Blueprints ' in Flask. The blueprint for our lobby is defined earlier in the api.py file: 1 game_lobby = Blueprint ( \"game_lobby\" , __name__ ) Here we simple create a blueprint called 'game_lobby'. Back in app.py you can see where this blueprint gets registered with Flask: 1 app . register_blueprint ( game_lobby , url_prefix = \"/game_lobby\" ) This is basically our way to telling Flask \"I have a bunch of endpoints I'd like you know know about, they're group conceptually into something I'm calling a lobby\". Once you run the serve you can access your endpoint by visiting the URL of you server and giving the path for your blueprint. So in the above example we register our blueprint with a url_prefix . This means that when ever we access our lobby we will have to use a path like this: 1 http://localhost/game_lobby Now lets jump back to the endpoint mentioned earlier: 1 2 3 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) def create_new_game ( product_id ): ... Here we use a decorator to add a route to our blueprint. We also give a path for this endpoint. Let's deconstruct this decorator: 1 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) Basically we are adding a 'route' or and endpoint to our game_lobby blueprint. We are giving that endpoint a path /<product_id>/create_game . The bit inside the <angled brackets> is important here. This endpoint is about creating a game, but what game? Our Matchmaker is generic so we could be trying to create a multi-player game for any game that is registered with the game portal. We've only registered one game so far, Rock Paper Scissors, and we gave it the ID 'exrps'. So if we want to create a game our endpoint now looks like this: 1 http://localhost/game_lobby/exrps/create_game So a request to this URL will connect to the local server, hit the game_lobby blueprint and then get mapped to the <product_id>/create_game route. Once Flask has matched a URL to a route it will extract that product ID and give it as an argument to the function the route is attached to: 1 2 3 @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) def create_new_game ( product_id ): ... So our create_new_game function is passed the 'product_id' that gets extracted from the URL, which is enough information for it to go ahead and create a game.","title":"API"},{"location":"internship/onboarding/backend/working_with_matchmaker/#lobby-endpoints","text":"We've defined three endpoints in our Matchmaker API: 1 2 3 4 5 6 7 8 # Create a new multi-player game @game_lobby . route ( \"/<product_id>/create_game\" , methods = [ \"POST\" ]) # Join and existing multi-player game @game_lobby . route ( \"/<product_id>/join_game/<game_id>\" , methods = [ \"POST\" ]) # Fetch all games that are currently open to join @game_lobby . route ( \"/<product_id>/open_games\" , methods = [ \"GET\" ]) These endpoints provide the functionality we discussed in the previous section. All of them require that we specify a product ID so that Matchmaker knows what game it is working with. The create and join are the more interesting endpoints because, as mentioned in the last section, they need to talk to the game server.","title":"Lobby Endpoints"},{"location":"internship/onboarding/backend/working_with_matchmaker/#game-server-api","text":"In matchmaker/core/game_server_api.py you will find the the code that allows the Matchmaker to send requests to the game servers. In order for a game to use this Matchmaker for managing games and player connections to those games it must provide a set of endpoints that conform to what is defined here. For example, the first function in this file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def send_create_game_request ( user_id , user_name , game_id , game_server ): \"\"\"Sends a 'create game' request to the remote game server. :param str user_id: The ID of the user creating the game :param str user_name: The username of the user creating the game :param str game_id: UID of the new game being created :param matchmaker.core.GameServer game_server: the target game server :returns: A dict containing the 'token' for the game that was created :rtype: dict :raises GameServerNetworkError: If the response from the remote game server is not a 200 \"\"\" request_data = { \"gameId\" : game_id , \"userId\" : user_id , \"username\" : user_name } return _send_request ( game_server , \"create_game\" , request_data ) This function with send a 'create_game' request to a game server, just like we saw in the diagrams in the previous section. The Matchmaker expects that any game server that has been registered with it has some endpoint: <game_server_url>/create_game The endpoint should also take a gameId , userId and username as input data. If the game server does not have this endpoint then the Matchmaker will not be able to interact with it. The game server API has four endpoints that are expected to be implemented by game servers: 1 2 3 4 create_game - Create a new game on the remote game server join_game - Join an existing game on the remote server remove_game - Remove a game from the remote server remove_player - Remove a player from a remote game on a remote server If you open up game_rps/server/game_server/app.js you will find all of these endpoints are defined there: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 app . post ( '/create_game' , function ( req , res ) { ... }) app . post ( '/join_game' , function ( req , res ) { ... }) app . post ( '/remove_game' , function ( req , res ) { ... }) app . post ( '/remove_player' , function ( req , res ) { ... }) This is why our Matchmaker is able to create games on the Rock Paper Scissors Apocalypse server. But our Matchmaker doesn't just send requests to game servers in order to organize games, it needs to keep its own records of the games it have created and it needs to curate those records. Time to take a look at the data layer.","title":"Game Server API"},{"location":"internship/onboarding/backend/working_with_matchmaker/#dao","text":"A DAO or Data Access Object gives us an abstracted interface to manage Matchmaker game data. It is one of the more complex parts of the code and also the most important. With the matchmaker we have to account for a lot data consistency challenges, like what happens if two players try to join the same game at the exact same time? The DAO aims to account for that while also providing a relatively straight forward interface to us in the Matchmaker API. The DAO code is in matchmaker/game_data/dao.py , but before we dig in there let's take a look at it in action. Here is the the code that creates a game using the DAO in our Matchmaker API: 1 2 3 4 5 6 7 8 9 10 11 12 new_game = Game ( uuid . uuid4 () . hex , product_id , game_server . game_server_url , user_profile . user_id , user_profile . username , ** game_server . settings , ) < snip > get_game_dao () . create_game ( new_game ) All we need to do is create a Game object with the required attributes and then called get_game_dao() to get a reference to our DAO and then call the create_game() function on it. This DAO function will take care of adding our game data to our database as well as adding it to the pending set. In fact anyone using the DAO doesn't need to know anything about pending, active or lobby sets. As the user of the DAO you are just creating, joining and fetching lists of games. You don't need to know anything about how that data is managed behind the scenes. I'm not going to say much more about the DAO - there will be a dedicated course for that. For now you can explore yourself and see if you can figure out what is going on.","title":"DAO"},{"location":"internship/onboarding/backend/working_with_matchmaker/#making-changes","text":"Making changes to our backend services is a bit different since it doesn't have some UI you can test directly. In order to test to Matchmaker you need the whole Varcade Games stack running so you can verify that it is talking to game server correctly, listening out for events correctly and that its API is working as expected. A robust set of tests is essential for any server side application, and our Matchmaker is not exception.","title":"Making Changes"},{"location":"internship/onboarding/backend/working_with_matchmaker/#running-the-tests","text":"In your terminal navigate over to the server directory for the website. For example, if your code is located in ~/code/varcade_games then you'd run: 1 cd ~/code/varcade_games/matchmaker Just like the Game Portal tests we ran earlier, our tests use a docker image. We build an image with all of the code and tests, then we run the container and run the tests. This gives us a consistent environment to run our tests in - us and everyone else running these tests will be running with the same dependencies and configurations. If we just ran the tests on our dev machine we could get different results due to different configuration. I've abstracted away most of the complexity of running the tests so all you need to do is run: 1 make build_test_image This may take a while... Next we run the image as follows: 1 make run_test_image_mounted Once it's done you can run the following make commands to run the actual tests: 1 make run_tests You should see a whole lot of output after running that command, and it hopefully ends with something like the following: 1 ======== 97 passed, 44 warnings in 2 .55s ======== (There are a few warnings... but the tests pass!) These tests test the functionality of the matchmaker - they tell us if something functional broke. So let's break something... Open up matchmaker/lobby/api.py . Find the function called get_open_games . This is the API endpoint that returns the list of open games that players can join. Change the following line: 1 2 3 4 5 available_games = get_game_dao () . get_available_games ( product_id , page_index , min ( entry_count , current_app . config [ \"LOBBY_MAX_PAGE_SIZE\" ]), ) to 1 2 3 4 5 available_games = get_game_dao () . get_available_games ( 'test, page_index , min ( entry_count , current_app . config [ \"LOBBY_MAX_PAGE_SIZE\" ]), ) All we're doing here is making it so the endpoint ignores the product ID given to it and simply inserts 'test'. We should expect this to break some stuff since we need a valid product ID in order to fetch any open games for that product. Run the tests again with make run_tests . The out put should have changed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #<snip> self = <test_api.TestFindGameAPI object at 0x7f4ae7c64f90>, test_client = <FlaskClient <Flask 'app' >> def test_view_available_games_success ( self, test_client ) : response = test_client.get ( f \"game_lobby/{self.test_game.product_id}/open_games\" , headers =[( \"Content-Type\" , \"application/json\" )] , ) # No games create yet assert len ( json.loads ( response.data )) == 0 self.dao.create_game ( self.test_game ) self.dao.publish_game ( self.test_game ) response = test_client.get ( f \"game_lobby/{self.test_game.product_id}/open_games\" , headers =[( \"Content-Type\" , \"application/json\" )] , ) game_list = json.loads ( response.data ) > assert len ( game_list ) == 1 E assert 0 == 1 E +0 E -1 tests/lobby/test_api.py:446: AssertionError #<snip> ========== 2 failed, 95 passed, 42 warnings in 2 .63s =================== In this output we can see that we now have a failing test. It is failing for the exact reason we made it fail. We have a test that tries to fetch a list of open games for a specific game: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def test_view_available_games_success ( self , test_client ): # Send a request to the 'open_games' endpoint response = test_client . get ( f \"game_lobby/ { self . test_game . product_id } /open_games\" , headers = [( \"Content-Type\" , \"application/json\" )], ) # No games create yet assert len ( json . loads ( response . data )) == 0 # Manually create a game self . dao . create_game ( self . test_game ) self . dao . publish_game ( self . test_game ) # Fetch list of available games response = test_client . get ( f \"game_lobby/ { self . test_game . product_id } /open_games\" , headers = [( \"Content-Type\" , \"application/json\" )], ) game_list = json . loads ( response . data ) # Our test fails here assert len ( game_list ) == 1 assert game_list [ 0 ][ \"game_id\" ] == self . test_game . game_id The reason our test is now failing is because it creates a game with a product ID of 'test_game.product_id', BUT our change just overwrites the actual product ID with 'test'. This results in our endpoint returning an empty list since 'test' is not a valid game and therefore can't have any open games. Revert the change and run the tests again to see them passing once again.","title":"Running the Tests"},{"location":"internship/onboarding/backend/working_with_matchmaker/#coverage","text":"Now try running: 1 make run_coverage This tells us how much of our code is covered by tests: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ----------- coverage: platform linux, python 3 .7.8-final-0 ----------- Name Stmts Miss Cover Missing ----------------------------------------------------------------------------- matchmaker/__init__.py 0 0 100 % matchmaker/app.py 28 2 93 % 25 , 49 matchmaker/config.py 34 4 88 % 53 , 56 -58 matchmaker/core/__init__.py 0 0 100 % matchmaker/core/game_server_api.py 30 0 100 % matchmaker/core/game_servers.py 29 0 100 % matchmaker/game_data/__init__.py 0 0 100 % matchmaker/game_data/dao.py 110 0 100 % matchmaker/game_data/models.py 122 2 98 % 69 , 168 matchmaker/game_worker.py 40 40 0 % 1 -67 matchmaker/lobby/__init__.py 0 0 100 % matchmaker/lobby/api.py 94 0 100 % matchmaker/workers/__init__.py 0 0 100 % matchmaker/workers/event_stream_workers.py 79 4 95 % 89 -93, 103 -107 matchmaker/workers/game_management_workers.py 60 1 98 % 115 matchmaker/workers/worker_manager.py 33 2 94 % 61 -62 ----------------------------------------------------------------------------- TOTAL 659 55 92 % AS I mentioned before, code coverage is a useful indicator about how much test coverage you have but it's important to understand that 100% coverage doesn't mean you have bug free or high quality code. Don't use coverage it as a target, use it as a guide.","title":"Coverage"},{"location":"internship/onboarding/backend/working_with_matchmaker/#type-checking","text":"For our Python projects we also have some type checking. Python is a dynamically typed language, meaning we have no compiler to tell us about errors and we often have to wait until we are running the code to know whether it even runs. Enter Mypy. Mypy is a static type checker that will analyze our code and tell us if there is any in there that might be problematic. You can run the type checker against the game portal by running: 1 make run_type_checking Which should result in some output like: 1 2 3 4 5 6 7 8 echo \"Running Mypy against web app\" && \\ mypy --ignore-missing-imports app.py && \\ echo \"Running Mypy against game worker\" && \\ mypy --ignore-missing-imports game_worker.py ' Running Mypy against web app Success: no issues found in 1 source file Running Mypy against game worker Success: no issues found in 1 source file You should run your tests and type checking before you commit any changes to the repository. That's it for the Matchmaker for now. The Matchmaker server at least - you may have noticed that I have yet to mention anything about the event stream events we looked at in the last section. We need to talk about workers...","title":"Type Checking"},{"location":"internship/onboarding/instrumentation/grafana/","text":"When you run make ps from your build_tools directory, there are two entries that we have yet to look at: 1 2 grafana /run.sh Up 0 .0.0.0:3001->3000/tcp prometheus /bin/prometheus --config.f ... Up 0 .0.0.0:9090->9090/tcp Notice that both are exposing port numbers. Grafana on 3000 and Promehteus on 9090 . Why not try pointing your browser at localhost:9090 and localhost:3000 to see what's there? Prometheus On 9090 you will see a basic interface with some text fields and buttons. We're actually going to completely ignore this interface - but it's good that it's there, it means Prometheus is up and running. Grafana When you connect to localhost:3030 you should be greeted by a screen that looks something like this (you will be running whatever the latest version is so the UI might change): You can log in with username admin and password password . This password is set in build_tools/grafana/config.monitoring . Once we can log in we need to tell Grafana where is can find Prometheus so that it can pull metrics from there and make them look pretty. So we need to add a data source. On the left hand side of the Grafana interface there is a cog icon: Click this icon to access the configuration options. Under the Data Sources heading select Add Data Source and select Prometheus from the list of options: Next you will have the option to specify some options. There are three that we care about: URL Access HTTP Method URL The URL should be set to http://localhost:9090 . Notice that this is the port number you connected your browser to earlier. It's our Prometheus server. Access Access should be set to Browser . HTTP Method HTTP Method should be set to Get Your options should look something like this: Hit the Save and Test button. It should turn green if everything went as expected. If not double check your settings. Adding a Dashboard Now that we've established a connection to Prometheus we need to start gathering some metrics and displaying them somewhere. I have created a dashboard that you can use to get started. First of all open up the Dashboards menu option and select Manage : Which should display a screen that looks like this: On the right hand side of the screen is an Import button. Click this button and then select the Upload JSoN file option that is presented. The file you need to upload is in build_tools/grafana and is called vcg_grafana_dashboard.json . Once that's done you should be presented with a screen that looks something like this: This view is showing you the last 15 minutes worth of activity on your system, so if you haven't been using it then nothing will show up here. Try opening up your local Varcade games at localhost:8002 and clicking around for a while. Refresh the game list page a few times, log in, log out, player a multi-player game etc... Once you do that you will see more activity: Have a read through some of the metrics. We're mostly interested in tracking things like: All Servers Request latency (how long each request takes to process) Volume of requests Error responses Game Server Number of active games Number of active connections (should be at least 1 per game) Workers Number of events processed Have a play around on the website and see what impact it has on the metrics. Once you've done that you will notice that a lot of the numbers are very low. It's just difficult to generate the amount of load a busy website might experience by yourself. Next we'll look at load testing.","title":"Setting up Grafana"},{"location":"internship/onboarding/instrumentation/grafana/#prometheus","text":"On 9090 you will see a basic interface with some text fields and buttons. We're actually going to completely ignore this interface - but it's good that it's there, it means Prometheus is up and running.","title":"Prometheus"},{"location":"internship/onboarding/instrumentation/grafana/#grafana","text":"When you connect to localhost:3030 you should be greeted by a screen that looks something like this (you will be running whatever the latest version is so the UI might change): You can log in with username admin and password password . This password is set in build_tools/grafana/config.monitoring . Once we can log in we need to tell Grafana where is can find Prometheus so that it can pull metrics from there and make them look pretty. So we need to add a data source. On the left hand side of the Grafana interface there is a cog icon: Click this icon to access the configuration options. Under the Data Sources heading select Add Data Source and select Prometheus from the list of options: Next you will have the option to specify some options. There are three that we care about: URL Access HTTP Method","title":"Grafana"},{"location":"internship/onboarding/instrumentation/grafana/#url","text":"The URL should be set to http://localhost:9090 . Notice that this is the port number you connected your browser to earlier. It's our Prometheus server.","title":"URL"},{"location":"internship/onboarding/instrumentation/grafana/#access","text":"Access should be set to Browser .","title":"Access"},{"location":"internship/onboarding/instrumentation/grafana/#http-method","text":"HTTP Method should be set to Get Your options should look something like this: Hit the Save and Test button. It should turn green if everything went as expected. If not double check your settings.","title":"HTTP Method"},{"location":"internship/onboarding/instrumentation/grafana/#adding-a-dashboard","text":"Now that we've established a connection to Prometheus we need to start gathering some metrics and displaying them somewhere. I have created a dashboard that you can use to get started. First of all open up the Dashboards menu option and select Manage : Which should display a screen that looks like this: On the right hand side of the screen is an Import button. Click this button and then select the Upload JSoN file option that is presented. The file you need to upload is in build_tools/grafana and is called vcg_grafana_dashboard.json . Once that's done you should be presented with a screen that looks something like this: This view is showing you the last 15 minutes worth of activity on your system, so if you haven't been using it then nothing will show up here. Try opening up your local Varcade games at localhost:8002 and clicking around for a while. Refresh the game list page a few times, log in, log out, player a multi-player game etc... Once you do that you will see more activity: Have a read through some of the metrics. We're mostly interested in tracking things like: All Servers Request latency (how long each request takes to process) Volume of requests Error responses Game Server Number of active games Number of active connections (should be at least 1 per game) Workers Number of events processed Have a play around on the website and see what impact it has on the metrics. Once you've done that you will notice that a lot of the numbers are very low. It's just difficult to generate the amount of load a busy website might experience by yourself. Next we'll look at load testing.","title":"Adding a Dashboard"},{"location":"internship/onboarding/instrumentation/intro/","text":"There is one final thing we need to cover before you are ready to work on Varcade Games. Instrumentation. Instrumentation is a collective term for measuring instruments that are used for indicating, measuring and recording physical quantities. When running a live product you're going to want to be sure that your live product is in fact live. Servers can crash, or worse - have bugs that start corrupting all of your data. They will also behave very differently with one user than 1,000 concurrent users. You don't want to have to sit around all day and night manually monitoring your servers to make sure they are operating as expected. We need to put in place some automated monitoring systems so that we can forget about our servers until something goes wrong. Prometheus & Grafana We will be using two open source products in order to monitor and alert on our backend services. Straight from the Grafana docs: Grafana is a complete observability stack that allows you to monitor and analyze mertrics, logs and traces. It allows you to query, visualize, alert on and understand your data no matter where it is stored. Prometheus is an open source systems monitoring system for which Grafana provides out-of-the-box support. This topic walks you through the steps to create a series of dashboards in Grafana to display system metrics for a server monitored by Prometheus. In light of the above, what we will do is use Prometheus to monitor our servers. It will gather a bunch of interesting metrics about our running servers, like how long does a request take or how many requests are we getting. We will then use Grafana to display that data in a nice dashboard that we can use to monitor system performance and stability. As always, I recommend you check out the official docs for both Prometheus and Grafana to get a sense of what they're about. k6 Another thing we will need to do is generate traffic for our system. It's all well and good testing our backend manually by ourselves, but a single person using and distributed system is a very different thing to 1,000 people using that system. We will use k6 to generate load and then monitor our system using Grafana to help understand if our system has any bottlenecks, how well it performs under load and when it breaks. We've got a bit of setup to do first, so lets get started.","title":"Introduction"},{"location":"internship/onboarding/instrumentation/intro/#prometheus-grafana","text":"We will be using two open source products in order to monitor and alert on our backend services. Straight from the Grafana docs: Grafana is a complete observability stack that allows you to monitor and analyze mertrics, logs and traces. It allows you to query, visualize, alert on and understand your data no matter where it is stored. Prometheus is an open source systems monitoring system for which Grafana provides out-of-the-box support. This topic walks you through the steps to create a series of dashboards in Grafana to display system metrics for a server monitored by Prometheus. In light of the above, what we will do is use Prometheus to monitor our servers. It will gather a bunch of interesting metrics about our running servers, like how long does a request take or how many requests are we getting. We will then use Grafana to display that data in a nice dashboard that we can use to monitor system performance and stability. As always, I recommend you check out the official docs for both Prometheus and Grafana to get a sense of what they're about.","title":"Prometheus &amp; Grafana"},{"location":"internship/onboarding/instrumentation/intro/#k6","text":"Another thing we will need to do is generate traffic for our system. It's all well and good testing our backend manually by ourselves, but a single person using and distributed system is a very different thing to 1,000 people using that system. We will use k6 to generate load and then monitor our system using Grafana to help understand if our system has any bottlenecks, how well it performs under load and when it breaks. We've got a bit of setup to do first, so lets get started.","title":"k6"},{"location":"internship/onboarding/instrumentation/load_test/","text":"In order to generate some traffic on our distributed system we're going to use a tool called k6 , which is an: Open source load testing tool and SaaS for engineering teams It's a tool written in GoLang that allows us to write Javascript in order great load tests. Installing k6 To get set up with k6 you should follow the official documentation for your system. Important If you are using Windows you need to follow the Linux instructions using your Linux shell, since you will be running the load test from within your Linux environment. Running the test In order to run the load test navigate to the build_tools/load_generator directory on your command line. In that directory is a Javascript file that contains a script that will spawn 500 virtual users. Those users will each register a new account and run the various requests a browser would run to load the website. It will also create new Rock Paper Scissors Apocalypse multi-player games and play the game. To run the script enter the following command: 1 k6 run site_navigation.js If you get an error you should verify that your installation of k6 and its dependencies were all successful. If everything works you should see some output like this flash by on the screen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 / \\ | \u203e\u203e | /\u203e\u203e/ /\u203e\u203e/ / \\ / \\ | | / / / / / \\/ \\ | ( / \u203e\u203e \\ / \\ | | \\ \\ | ( \u203e ) | / __________ \\ | __ | \\_ _ \\ \\_ ____/ .io execution: local script: site_navigation.js output: - scenarios: ( 100 .00% ) 1 scenario, 500 max VUs, 15m30s max duration ( incl. graceful stop ) : * default: 500 looping VUs for 15m0s ( gracefulStop: 30s ) INFO [ 0000 ] Fetching VCG client, identifier: 1272 source = console INFO [ 0000 ] Fetching VCG client, identifier: 1957 source = console INFO [ 0000 ] Fetching VCG client, identifier: 8352 source = console INFO [ 0000 ] Fetching VCG client, identifier: 4549 source = console INFO [ 0000 ] Fetching VCG client, identifier: 4845 source = console INFO [ 0000 ] Fetching VCG client, identifier: 2130 source = console INFO [ 0000 ] Fetching VCG client, identifier: 4910 source = console INFO [ 0000 ] Fetching VCG client, identifier: 7115 source = console There are a couple of things worth noting here. k6 tells us that it is running 500 VUs , which means 500 Virtual Users . It also says 15m30s max duration , telling us that this test will run for 15 minutes. That means our users will be load the website, creating games and playing games for 15 minutes straight. This gives us an understand of how the whole system will handle load over a specific period of time. If you want the end the text early you can just hit ctrl+c . Once the test has finished a summary will be displayed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 running ( 00m02.8s ) , 000 /500 VUs, 0 complete and 500 interrupted iterations default \u2717 [ -------------------------------------- ] 500 VUs 00m02.8s/15m0s WARN [ 0003 ] No script iterations finished, consider making the test duration longer \u2588 landing and registration \u2717 statusCode \u21b3 99 % \u2014 \u2713 512 / \u2717 1 \u2588 homepage \u2713 statusCode checks.........................: 99 .80% \u2713 512 \u2717 1 data_received..................: 393 kB 138 kB/s data_sent......................: 160 kB 56 kB/s group_duration.................: avg = 1 .98s min = 1 .21s med = 2 .03s max = 2 .72s p ( 90 )= 2 .56s p ( 95 )= 2 .64s http_req_blocked...............: avg = 8 .57ms min = 57 .68\u00b5s med = 2 .72ms max = 35 .66ms p ( 90 )= 31 .5ms p ( 95 )= 33 .75ms http_req_connecting............: avg = 8 .35ms min = 39 .69\u00b5s med = 2 .62ms max = 35 .63ms p ( 90 )= 31 .45ms p ( 95 )= 33 .57ms http_req_duration..............: avg = 175 .8ms min = 33 .35ms med = 165 .71ms max = 1 .62s p ( 90 )= 217 .07ms p ( 95 )= 224 .57ms { expected_response:true } ...: avg = 174 .06ms min = 33 .35ms med = 165 .57ms max = 1 .62s p ( 90 )= 217 .05ms p ( 95 )= 224 .44ms http_req_failed................: 0 .19% \u2713 1 \u2717 512 http_req_receiving.............: avg = 33 .86\u00b5s min = 15 .58\u00b5s med = 29 .85\u00b5s max = 119 .25\u00b5s p ( 90 )= 52 .29\u00b5s p ( 95 )= 60 .46\u00b5s http_req_sending...............: avg = 1 .24ms min = 17 .03\u00b5s med = 213 .58\u00b5s max = 48 .79ms p ( 90 )= 2 .12ms p ( 95 )= 9 .78ms http_req_tls_handshaking.......: avg = 0s min = 0s med = 0s max = 0s p ( 90 )= 0s p ( 95 )= 0s http_req_waiting...............: avg = 174 .52ms min = 26 .01ms med = 164 .44ms max = 1 .62s p ( 90 )= 217 .02ms p ( 95 )= 224 .51ms http_reqs......................: 513 180 .657393/s vus............................: 500 min = 500 max = 500 vus_max........................: 500 min = 500 max = 500 Configuration We can configure this tests by making some changes to build_tools/load_generator/site_navigation.js : 1 2 3 4 5 6 7 8 9 10 import http from 'k6/http' ; import ws from 'k6/ws' ; import { sleep , group , check } from 'k6' ; export let options = { vus : 500 , duration : '15m' }; At the top of the file we can set the number of Virtual Users (vus) and the duration. If your machine is struggling to run the test with 500 users you can try lowering the value to 50 and going from there. The Metrics If you head back to your Grafana dashboard you won't see anything exciting just yet. The system needs a few seconds to update. Our Prometheus server will get updates from the services at regular updates, so we will see updated values every 15 seconds or so. Once the test has been running for a few minutes the dashboard should explode into life. Now when you make changes to Varcade Games you can test them under load!","title":"Running a load test"},{"location":"internship/onboarding/instrumentation/load_test/#installing-k6","text":"To get set up with k6 you should follow the official documentation for your system. Important If you are using Windows you need to follow the Linux instructions using your Linux shell, since you will be running the load test from within your Linux environment.","title":"Installing k6"},{"location":"internship/onboarding/instrumentation/load_test/#running-the-test","text":"In order to run the load test navigate to the build_tools/load_generator directory on your command line. In that directory is a Javascript file that contains a script that will spawn 500 virtual users. Those users will each register a new account and run the various requests a browser would run to load the website. It will also create new Rock Paper Scissors Apocalypse multi-player games and play the game. To run the script enter the following command: 1 k6 run site_navigation.js If you get an error you should verify that your installation of k6 and its dependencies were all successful. If everything works you should see some output like this flash by on the screen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 / \\ | \u203e\u203e | /\u203e\u203e/ /\u203e\u203e/ / \\ / \\ | | / / / / / \\/ \\ | ( / \u203e\u203e \\ / \\ | | \\ \\ | ( \u203e ) | / __________ \\ | __ | \\_ _ \\ \\_ ____/ .io execution: local script: site_navigation.js output: - scenarios: ( 100 .00% ) 1 scenario, 500 max VUs, 15m30s max duration ( incl. graceful stop ) : * default: 500 looping VUs for 15m0s ( gracefulStop: 30s ) INFO [ 0000 ] Fetching VCG client, identifier: 1272 source = console INFO [ 0000 ] Fetching VCG client, identifier: 1957 source = console INFO [ 0000 ] Fetching VCG client, identifier: 8352 source = console INFO [ 0000 ] Fetching VCG client, identifier: 4549 source = console INFO [ 0000 ] Fetching VCG client, identifier: 4845 source = console INFO [ 0000 ] Fetching VCG client, identifier: 2130 source = console INFO [ 0000 ] Fetching VCG client, identifier: 4910 source = console INFO [ 0000 ] Fetching VCG client, identifier: 7115 source = console There are a couple of things worth noting here. k6 tells us that it is running 500 VUs , which means 500 Virtual Users . It also says 15m30s max duration , telling us that this test will run for 15 minutes. That means our users will be load the website, creating games and playing games for 15 minutes straight. This gives us an understand of how the whole system will handle load over a specific period of time. If you want the end the text early you can just hit ctrl+c . Once the test has finished a summary will be displayed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 running ( 00m02.8s ) , 000 /500 VUs, 0 complete and 500 interrupted iterations default \u2717 [ -------------------------------------- ] 500 VUs 00m02.8s/15m0s WARN [ 0003 ] No script iterations finished, consider making the test duration longer \u2588 landing and registration \u2717 statusCode \u21b3 99 % \u2014 \u2713 512 / \u2717 1 \u2588 homepage \u2713 statusCode checks.........................: 99 .80% \u2713 512 \u2717 1 data_received..................: 393 kB 138 kB/s data_sent......................: 160 kB 56 kB/s group_duration.................: avg = 1 .98s min = 1 .21s med = 2 .03s max = 2 .72s p ( 90 )= 2 .56s p ( 95 )= 2 .64s http_req_blocked...............: avg = 8 .57ms min = 57 .68\u00b5s med = 2 .72ms max = 35 .66ms p ( 90 )= 31 .5ms p ( 95 )= 33 .75ms http_req_connecting............: avg = 8 .35ms min = 39 .69\u00b5s med = 2 .62ms max = 35 .63ms p ( 90 )= 31 .45ms p ( 95 )= 33 .57ms http_req_duration..............: avg = 175 .8ms min = 33 .35ms med = 165 .71ms max = 1 .62s p ( 90 )= 217 .07ms p ( 95 )= 224 .57ms { expected_response:true } ...: avg = 174 .06ms min = 33 .35ms med = 165 .57ms max = 1 .62s p ( 90 )= 217 .05ms p ( 95 )= 224 .44ms http_req_failed................: 0 .19% \u2713 1 \u2717 512 http_req_receiving.............: avg = 33 .86\u00b5s min = 15 .58\u00b5s med = 29 .85\u00b5s max = 119 .25\u00b5s p ( 90 )= 52 .29\u00b5s p ( 95 )= 60 .46\u00b5s http_req_sending...............: avg = 1 .24ms min = 17 .03\u00b5s med = 213 .58\u00b5s max = 48 .79ms p ( 90 )= 2 .12ms p ( 95 )= 9 .78ms http_req_tls_handshaking.......: avg = 0s min = 0s med = 0s max = 0s p ( 90 )= 0s p ( 95 )= 0s http_req_waiting...............: avg = 174 .52ms min = 26 .01ms med = 164 .44ms max = 1 .62s p ( 90 )= 217 .02ms p ( 95 )= 224 .51ms http_reqs......................: 513 180 .657393/s vus............................: 500 min = 500 max = 500 vus_max........................: 500 min = 500 max = 500","title":"Running the test"},{"location":"internship/onboarding/instrumentation/load_test/#configuration","text":"We can configure this tests by making some changes to build_tools/load_generator/site_navigation.js : 1 2 3 4 5 6 7 8 9 10 import http from 'k6/http' ; import ws from 'k6/ws' ; import { sleep , group , check } from 'k6' ; export let options = { vus : 500 , duration : '15m' }; At the top of the file we can set the number of Virtual Users (vus) and the duration. If your machine is struggling to run the test with 500 users you can try lowering the value to 50 and going from there.","title":"Configuration"},{"location":"internship/onboarding/instrumentation/load_test/#the-metrics","text":"If you head back to your Grafana dashboard you won't see anything exciting just yet. The system needs a few seconds to update. Our Prometheus server will get updates from the services at regular updates, so we will see updated values every 15 seconds or so. Once the test has been running for a few minutes the dashboard should explode into life. Now when you make changes to Varcade Games you can test them under load!","title":"The Metrics"},{"location":"internship/onboarding/rps_game/game_design/","text":"I want to talk briefly about some of the game design decisions behind Rock Paper Scissors Apocalypse. It's a very simple take on Rock Paper Scissors so it shouldn't need that much explanation. Gameplay For this game I wanted to capture the feeling of playing an old arcade style fighting game. There's a single player mode where you face a gauntlet of AI opponents and a multi player mode where you face other humans. The flow of the single player mode is fairly standard: 1 Character select -> VS Screen -> Fight Screen -> Next opponent or Game Over These fighting games often have a thin story line explaining why its diverse array of characters decided to get together and fight. Rock Paper Scissors is so ridiculously simple that I wanted to put a really over the top story behind it, hence the 'Apocalypse' part of the game. The characters are trying to save the world by playing this game. When you select single player mode you are greeted by this storyline, after which you get to select the character you want to save humanity with. Player Stats Once you're at the character select screen you have a decision to make - what character do you want to play as? I wanted to add a element to strategy and tactics to the game, so each character has some strengths and weaknesses. The way this works is as follows: All characters have the same health, in battle the player that loses all of their health loses the current round of the battle There is a base level of damage that all players do If a player's weapon selection defeats their opponent, then their attack bonus for that weapon is added to the damage done If a player's weapon selection loses to their opponent then their defense bonus reduces the damage received So, for example, in the screen shot above our character has +40% to their scissors damage. With a base damage of 20, their scissor damage becomes 28. This character also has -10% against paper. This means that when they select rock and their opponent selects paper they will mitigate some of the damage. That 20 base damage done by the opponent becomes 18. So in terms of strategy, if you are facing this character you want to be careful when selecting paper - because their scissors will do a lot of damage to you. The way I tried to balance this was to give every character a value of 50% to use on their attack and defense stats. The character above put most of that value into scissors so that they have one devastating attack. Other characters spread the 50% out more evenly so that they are generally stronger (eg. +10% to scissors and paper attack, -10% defense against everything). The equation for calculating damage looks like this: 1 baseDamage * (1 + attack - enemy defense) All of this data is available in the game_data.js file of the game engine. The calculation itself appears in the game_models.js file in the Weapon class. Botch If a player makes no selection then the 'botch' hand is automatically selected. This selection does no damage and loses against all weapons. If both players fail to make a selection (can happen in multi player) then both will receive damage when 'botch' is used. This is so that the game will end by attrition rather than continue forever. Difficulty Progression Once a character is selected in single player mode, the player will face a series of battles with the other characters in the roster. As the player progresses their opponent will get more and more difficult. Here's how it works. AI opponents will simply select a pattern of weapon selections. So the AI will have a predefined set of choices that it will make. For example, the easiest character will take a list of selections: 1 [rock, paper, scissors] And then shuffle that list, which might end up looking like this: 1 [paper, scissors, rock] That AI opponent will then simply select paper, then scissors, then rock over and over again. The player simply needs to figure out the pattern and they will easily defeat their opponent. To make this more difficult we simply add selections to the list. So the second AI character the player faces will start will a list: 1 [rock, paper, scissors] Then a random weapon and add it to the list, eg: 1 [rock, paper, scissors, paper] Then is will shuffle that list: 1 [paper, scissors, rock, paper] And that's it. Now the player has a longer pattern that is more difficult to figure out and remember. At this point, however, we also introduce some more variance. The AI opponents will change up their pattern once they've received enough damage. So, for example, an AI opponent may have the following list: 1 [paper, paper, scissors, rock] BUT when their health drops below 30% they reshuffle the list to try and throw the player off, so the pattern changes to: 1 [paper, scissors, paper, rock] Following this format we can add new opponents and simply extend their pattern by one each time and adjust the point at which they reshuffle in response to damage received. Character Unlocks At the time of writing the game has four main characters. Two and unlocked and two are locked. In single player mode you unlock the additional characters by beating all of the standard characters in single player with the two default characters. For example, Aruka faces off against the following characters in single player: Manbo (unlocked) Raden (locked) Hogo Sha (locked) Aruka's final character is Hogo Sha, and if he wins he will unlock Hogo. Similary Manbo, who starts unlocked, will unlock Raden once she defeats here. This leaves one final character that is locked - the boss. Beating the game The final bit of game design worth talking about is the final boss. Players don't get to face the final boss just by defeating all of their opponents... I wanted to make the game a little more difficult than that. They need to beat all of their opponents without losing a single round . If they lose a round they will get a game over screen and a character unlock message. If they win every round they play - then they get to face Mainyu... the final boss. Mainyu doesn't use a strategy like the other characters. It's selections are completely random, which makes it really difficult to play against (random selections are the most difficult in Rock Paper Scissors. Humans think they can be random, but often fall into patterns - so it is possible to be good or bad and this game, which most put down to chance). Once Mainyu is defeated, it will be unlocked. Good luck! That's about it for game design for now. Hopefully this has highlighted just how complex even a seemingly trivial game like Rock Paper Scissors can be. Some of the strategy games I've worked on in the past have had tens of thousands of rows in spreadsheets filled with data about character stats, economy management, buffs etc... If you plan on making a game my recommendation would be to pick a simple but solid (and fun!) core gameplay mechanic and focus on getting it right. Keep it simple, then when it works add complexity around it. Complexity is easy to add - fun isn't. Focus on the fun. Speaking of fun, what's more fun than playing with and against other people? Let's move on to the game server.","title":"Game Design"},{"location":"internship/onboarding/rps_game/game_design/#gameplay","text":"For this game I wanted to capture the feeling of playing an old arcade style fighting game. There's a single player mode where you face a gauntlet of AI opponents and a multi player mode where you face other humans. The flow of the single player mode is fairly standard: 1 Character select -> VS Screen -> Fight Screen -> Next opponent or Game Over These fighting games often have a thin story line explaining why its diverse array of characters decided to get together and fight. Rock Paper Scissors is so ridiculously simple that I wanted to put a really over the top story behind it, hence the 'Apocalypse' part of the game. The characters are trying to save the world by playing this game. When you select single player mode you are greeted by this storyline, after which you get to select the character you want to save humanity with.","title":"Gameplay"},{"location":"internship/onboarding/rps_game/game_design/#player-stats","text":"Once you're at the character select screen you have a decision to make - what character do you want to play as? I wanted to add a element to strategy and tactics to the game, so each character has some strengths and weaknesses. The way this works is as follows: All characters have the same health, in battle the player that loses all of their health loses the current round of the battle There is a base level of damage that all players do If a player's weapon selection defeats their opponent, then their attack bonus for that weapon is added to the damage done If a player's weapon selection loses to their opponent then their defense bonus reduces the damage received So, for example, in the screen shot above our character has +40% to their scissors damage. With a base damage of 20, their scissor damage becomes 28. This character also has -10% against paper. This means that when they select rock and their opponent selects paper they will mitigate some of the damage. That 20 base damage done by the opponent becomes 18. So in terms of strategy, if you are facing this character you want to be careful when selecting paper - because their scissors will do a lot of damage to you. The way I tried to balance this was to give every character a value of 50% to use on their attack and defense stats. The character above put most of that value into scissors so that they have one devastating attack. Other characters spread the 50% out more evenly so that they are generally stronger (eg. +10% to scissors and paper attack, -10% defense against everything). The equation for calculating damage looks like this: 1 baseDamage * (1 + attack - enemy defense) All of this data is available in the game_data.js file of the game engine. The calculation itself appears in the game_models.js file in the Weapon class.","title":"Player Stats"},{"location":"internship/onboarding/rps_game/game_design/#botch","text":"If a player makes no selection then the 'botch' hand is automatically selected. This selection does no damage and loses against all weapons. If both players fail to make a selection (can happen in multi player) then both will receive damage when 'botch' is used. This is so that the game will end by attrition rather than continue forever.","title":"Botch"},{"location":"internship/onboarding/rps_game/game_design/#difficulty-progression","text":"Once a character is selected in single player mode, the player will face a series of battles with the other characters in the roster. As the player progresses their opponent will get more and more difficult. Here's how it works. AI opponents will simply select a pattern of weapon selections. So the AI will have a predefined set of choices that it will make. For example, the easiest character will take a list of selections: 1 [rock, paper, scissors] And then shuffle that list, which might end up looking like this: 1 [paper, scissors, rock] That AI opponent will then simply select paper, then scissors, then rock over and over again. The player simply needs to figure out the pattern and they will easily defeat their opponent. To make this more difficult we simply add selections to the list. So the second AI character the player faces will start will a list: 1 [rock, paper, scissors] Then a random weapon and add it to the list, eg: 1 [rock, paper, scissors, paper] Then is will shuffle that list: 1 [paper, scissors, rock, paper] And that's it. Now the player has a longer pattern that is more difficult to figure out and remember. At this point, however, we also introduce some more variance. The AI opponents will change up their pattern once they've received enough damage. So, for example, an AI opponent may have the following list: 1 [paper, paper, scissors, rock] BUT when their health drops below 30% they reshuffle the list to try and throw the player off, so the pattern changes to: 1 [paper, scissors, paper, rock] Following this format we can add new opponents and simply extend their pattern by one each time and adjust the point at which they reshuffle in response to damage received.","title":"Difficulty Progression"},{"location":"internship/onboarding/rps_game/game_design/#character-unlocks","text":"At the time of writing the game has four main characters. Two and unlocked and two are locked. In single player mode you unlock the additional characters by beating all of the standard characters in single player with the two default characters. For example, Aruka faces off against the following characters in single player: Manbo (unlocked) Raden (locked) Hogo Sha (locked) Aruka's final character is Hogo Sha, and if he wins he will unlock Hogo. Similary Manbo, who starts unlocked, will unlock Raden once she defeats here. This leaves one final character that is locked - the boss.","title":"Character Unlocks"},{"location":"internship/onboarding/rps_game/game_design/#beating-the-game","text":"The final bit of game design worth talking about is the final boss. Players don't get to face the final boss just by defeating all of their opponents... I wanted to make the game a little more difficult than that. They need to beat all of their opponents without losing a single round . If they lose a round they will get a game over screen and a character unlock message. If they win every round they play - then they get to face Mainyu... the final boss. Mainyu doesn't use a strategy like the other characters. It's selections are completely random, which makes it really difficult to play against (random selections are the most difficult in Rock Paper Scissors. Humans think they can be random, but often fall into patterns - so it is possible to be good or bad and this game, which most put down to chance). Once Mainyu is defeated, it will be unlocked. Good luck! That's about it for game design for now. Hopefully this has highlighted just how complex even a seemingly trivial game like Rock Paper Scissors can be. Some of the strategy games I've worked on in the past have had tens of thousands of rows in spreadsheets filled with data about character stats, economy management, buffs etc... If you plan on making a game my recommendation would be to pick a simple but solid (and fun!) core gameplay mechanic and focus on getting it right. Keep it simple, then when it works add complexity around it. Complexity is easy to add - fun isn't. Focus on the fun. Speaking of fun, what's more fun than playing with and against other people? Let's move on to the game server.","title":"Beating the game"},{"location":"internship/onboarding/rps_game/intro/","text":"Rock Paper Scissors Apocalypse Hopefully by now you've played (and hopefully enjoyed playing) Rock Paper Scissors Apocalypse. It's not a particularly advanced game - but that was not the goal. I didn't want to create a tech demo, I wanted to create a somewhat polished but simple product. A product that includes often overlooked parts of building a product, like end credits or a settings menu. I also wanted to build something that could serve as a creative outlet. There are elements of visual design, game design, audio and narrative, as well as interesting tech: Nodejs - for our stateful game server Websockets - for 'realtime' game communication Phaser - a popular 2D game engine In this section of the docs we will focus on Phaser and the single-player game mode. Let's dive in.","title":"Introduction"},{"location":"internship/onboarding/rps_game/intro/#rock-paper-scissors-apocalypse","text":"Hopefully by now you've played (and hopefully enjoyed playing) Rock Paper Scissors Apocalypse. It's not a particularly advanced game - but that was not the goal. I didn't want to create a tech demo, I wanted to create a somewhat polished but simple product. A product that includes often overlooked parts of building a product, like end credits or a settings menu. I also wanted to build something that could serve as a creative outlet. There are elements of visual design, game design, audio and narrative, as well as interesting tech: Nodejs - for our stateful game server Websockets - for 'realtime' game communication Phaser - a popular 2D game engine In this section of the docs we will focus on Phaser and the single-player game mode. Let's dive in.","title":"Rock Paper Scissors Apocalypse"},{"location":"internship/onboarding/rps_game/key_concepts/","text":"Before we jump too deep into the code, let's first go through some concepts and terminology that will be useful when describing how the game works. Phaser ] The first thing you should do before looking at the game code is head over to phaser.io and checking out the game engine we'll be using. In fact, regardless of what project you start working on, or company you start working at, it's always a good idea to go read up on whatever the core technology being leveraged is. This doesn't need to be a study session, but at the very least you should: Try to understand what the producers of the technology are trying to achieve Check out a few basic examples Understand the feature set of the technology Find the documentation Phaser is our game engine of choice. It is a free and open source 2D game engine that is easy to use, performant and full featured. Scenes A Phaser project is split into scenes . When you play single player mode in Rock Paper Scissors Apocalypse the game will move through the following scenes: Boot Loading Main menu Story intro Character selection Character Intro VS Scene Fight Scene Post fight Loop back to VS scene if winner Game over We follow the traditional format for a fighting game: Select character -> face opponent -> view result -> fight next opponent or game over. So there is a progression. You fight one character at a time until you get to the final boss, unlocking characters along the way. Scenes are analogous to the scenes in a movie, but for a game they can be described as 'the different stages of interaction a player has with a game'. Our game has a number of scenes to set up the game, then a scene for the actual game play, then a scene to display the results. Each scene expects something slightly different from the user and encompasses a logical step within the game. When working on Rock Paper Scissors Apocalypse you will spend most of your time working on the scenes. They are all in the game_rps/client/src/scenes directory. At this point it's also worth calling out a couple of scenes that are somewhat specialized. The boot scene The boot scene simply loads enough of the game for us to display a loading scene. In our case it downloads a couple of fonts before transitioning to the loading scene. The boot scene is our entry point to the game - the first scene that is run. It will simply display a black screen while loading its assets, before moving directly on to the loading scene. We do this to minimize the amount of content we need to load before showing the player something. In our case we just need our font so that we can display some text in the loading scene. The loading scene The loading scene will download all of the game assets (images, audio etc...) required to run the game. We do this up front because if we only load our assets as they are needed by the game, the game would stutter and slow down during scene transitions. Assets If you open up game_rps/client/src/assets you will find all of the images, audio and fonts for the game. There is also a file in there called asset_list.json . If you open up that file what you will see is basically a manifest that contains all of the game assets. If you want to add a new asset to the game it can be added here. The file is broken down by scene and any new assets added simply need to be added here and referenced as needed by the code - the loading scene will take care of downloading the actual asset. The game engine Our game project is actually composed of three different projects: Client Game engine Server We'll ignore the server for now, but what is this game engine project? Well - since this game is both single and multi player I decided to split out the actual gameplay logic into it's own small project that can be imported into both the client and server projects. This means we have the exact same gameplay logic regardless of whether we're working on single player or multi player. It also means we can run the game on the server side - making it harder for players to cheat the leaderboards. The game engine contains: Data models for the game (Game, Player, Round, Weapon etc...) The data for the game (settings, story line, characters, credits etc...) The logic for managing a series of rounds and results The engine is event driven, which means you can subscribe to its event system to listen out for changes in game state - which is how it gets hooked into the client and server. We'll look at this in more detail later when we get into the actual code. The game engine interface The game engine interface is a class that allows us to completely decouple our game UI from the concept of single player vs multi player. Basically we have a graphics layer that doesn't care about the game mode being played, it just cares about making everything look and feel nice. The complexities of networking and interacting with the game engine live in the game engine interface. One of the first things we do when starting a new game is to create an instance of this interface. With that in mind, let's jump into the code and take a look at single-player mode.","title":"Key Concepts"},{"location":"internship/onboarding/rps_game/key_concepts/#phaser","text":"] The first thing you should do before looking at the game code is head over to phaser.io and checking out the game engine we'll be using. In fact, regardless of what project you start working on, or company you start working at, it's always a good idea to go read up on whatever the core technology being leveraged is. This doesn't need to be a study session, but at the very least you should: Try to understand what the producers of the technology are trying to achieve Check out a few basic examples Understand the feature set of the technology Find the documentation Phaser is our game engine of choice. It is a free and open source 2D game engine that is easy to use, performant and full featured.","title":"Phaser"},{"location":"internship/onboarding/rps_game/key_concepts/#scenes","text":"A Phaser project is split into scenes . When you play single player mode in Rock Paper Scissors Apocalypse the game will move through the following scenes: Boot Loading Main menu Story intro Character selection Character Intro VS Scene Fight Scene Post fight Loop back to VS scene if winner Game over We follow the traditional format for a fighting game: Select character -> face opponent -> view result -> fight next opponent or game over. So there is a progression. You fight one character at a time until you get to the final boss, unlocking characters along the way. Scenes are analogous to the scenes in a movie, but for a game they can be described as 'the different stages of interaction a player has with a game'. Our game has a number of scenes to set up the game, then a scene for the actual game play, then a scene to display the results. Each scene expects something slightly different from the user and encompasses a logical step within the game. When working on Rock Paper Scissors Apocalypse you will spend most of your time working on the scenes. They are all in the game_rps/client/src/scenes directory. At this point it's also worth calling out a couple of scenes that are somewhat specialized.","title":"Scenes"},{"location":"internship/onboarding/rps_game/key_concepts/#the-boot-scene","text":"The boot scene simply loads enough of the game for us to display a loading scene. In our case it downloads a couple of fonts before transitioning to the loading scene. The boot scene is our entry point to the game - the first scene that is run. It will simply display a black screen while loading its assets, before moving directly on to the loading scene. We do this to minimize the amount of content we need to load before showing the player something. In our case we just need our font so that we can display some text in the loading scene.","title":"The boot scene"},{"location":"internship/onboarding/rps_game/key_concepts/#the-loading-scene","text":"The loading scene will download all of the game assets (images, audio etc...) required to run the game. We do this up front because if we only load our assets as they are needed by the game, the game would stutter and slow down during scene transitions.","title":"The loading scene"},{"location":"internship/onboarding/rps_game/key_concepts/#assets","text":"If you open up game_rps/client/src/assets you will find all of the images, audio and fonts for the game. There is also a file in there called asset_list.json . If you open up that file what you will see is basically a manifest that contains all of the game assets. If you want to add a new asset to the game it can be added here. The file is broken down by scene and any new assets added simply need to be added here and referenced as needed by the code - the loading scene will take care of downloading the actual asset.","title":"Assets"},{"location":"internship/onboarding/rps_game/key_concepts/#the-game-engine","text":"Our game project is actually composed of three different projects: Client Game engine Server We'll ignore the server for now, but what is this game engine project? Well - since this game is both single and multi player I decided to split out the actual gameplay logic into it's own small project that can be imported into both the client and server projects. This means we have the exact same gameplay logic regardless of whether we're working on single player or multi player. It also means we can run the game on the server side - making it harder for players to cheat the leaderboards. The game engine contains: Data models for the game (Game, Player, Round, Weapon etc...) The data for the game (settings, story line, characters, credits etc...) The logic for managing a series of rounds and results The engine is event driven, which means you can subscribe to its event system to listen out for changes in game state - which is how it gets hooked into the client and server. We'll look at this in more detail later when we get into the actual code.","title":"The game engine"},{"location":"internship/onboarding/rps_game/key_concepts/#the-game-engine-interface","text":"The game engine interface is a class that allows us to completely decouple our game UI from the concept of single player vs multi player. Basically we have a graphics layer that doesn't care about the game mode being played, it just cares about making everything look and feel nice. The complexities of networking and interacting with the game engine live in the game engine interface. One of the first things we do when starting a new game is to create an instance of this interface. With that in mind, let's jump into the code and take a look at single-player mode.","title":"The game engine interface"},{"location":"internship/onboarding/rps_game/single_player_mode/","text":"Working with Phaser Phaser is a 2d graphics engine and does not come with any fancy UI or layout functionality. When working on Varcade Games we were able to use HTML and CSS to easily lay out all of our content in a nice organized fashion. With Phaser we're 2d graphics land, which means a Cartesian plane and a X/Y coordinates. The top left hand corner of the game is point X=0, Y=0. As we add images, test and buttons to our game we have to explicitly set their X/Y coordinates on that plane. If you're not careful you will end up with lots of hardcoded values in your code, which can become pretty painful pretty quickly. So, before we go any further we should check out our layout file. Layout Open up client/src/game_data/layout.js and have a look around. At the top we have a couple of global variables. It's useful to calculate and store screen height / width and half height / half width as they will help us position game objects relative to the screen. For example if you want to position something in the middle of the screen you set X to half width and Y to half height. You will see these values used extensively throughout the rest of the file. The first layout, and most straight forward layout, in the file is for the Loading scene: 1 2 3 4 5 6 7 8 9 10 11 12 13 LoadingScene : { ui : { text : { originX : 0.5 , originY : 0.5 , bitmapFontId : 'verdana64' , color : 0xFF0000 , fontSize : 48 , x : globalLayoutData . halfScreenWidth , y : globalLayoutData . halfScreenHeight } } }, So what can we infer from this? Well it's safe to say that there is probably a loading scene. That loading scene probably has some UI and the UI looks like it has some text. That text has a bunch of data associated with it. A lot of it should be obvious - there's an X and Y coordinate, a color, a font ID and a font size. The only bits that might be unfamiliar are originX and originY . You will see this used extensively through out our layout file as it is a really useful feature that Phaser has. When positioning an object in 2d space you can specify the coordinates relative to some point on the object... this is a lot easier to explain with a diagram: As you can see in the image above, I am describing the position of the images in space relative to a point on the image. If I set the origin X and Y of an image to (0, 0), then placing the image at coordinates (10, 10) will result in Phaser rendering that image with the top left corner at that point. If I set the origin X and origin Y of an image to (0.5, 0.5), then placing the image at coordinates (40, 30) will result in Phaser rendering that image with the center at those coordinates. Why 0.5? Because the minimum value for the origin is 0 and the maximum is 1.0. So specifying 0.5 for the origin of both X and Y represents half way of both axes. If this is confusing don't worry about - jump into the code and make some changes and see what happens. The background for the main menu scene is defined next in the layout: 1 2 3 4 5 6 7 8 9 10 MainMenuScene : { ui : { background : { originX : 0 , originY : 0 , x : 0 , y : 0 } } } Try changing the origin X and Y to 0.5 and see what happens. What do you need to change X and Y to in order to fix it? That brief introduction should be enough for you to be able to find your way around the various scene layouts - so let's move on to the code. The main menu The main menu is one of the simpler scenes in the game, so we can use it to get a sense of how scenes are set up. First off we need to create a new instance of a Phaser Scene: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const MainMenuScene = new Phaser . Class ({ Extends : Phaser . Scene , initialize : function () { Phaser . Scene . call ( this , { key : 'MainMenuScene' }) this . menuHighlightIconIndex = 0 }, init : function ( data ) { this . error = data . error // This will be filled if returning from an error in another scene }, create : function () { ... } ... } You will see this same basic setup in all of our scenes. Initialize acts as our constructor. init is called when the scene is being started and can also be used to pass data around, as we do here. Finally the create function is where we actually create our scene by adding images and text etc... Our rendering code looks like this: 1 2 3 4 5 6 7 8 this . layoutData = getSceneLayoutData ( 'MainMenuScene' ) const bgLayout = this . layoutData . ui . background this . add . image ( bgLayout . x , bgLayout . y , 'mainMenuBg' ). setOrigin ( bgLayout . originX , bgLayout . originY ) This is where we add the background image for our scene. First we fetch the layout information for the scene. Next we call a Phaser function: this.add.image - which is basically saying to Phaser 'add an image to this scene'. We give it the various coordinates and the ID of the image (this can be found in the asset list we discussed earlier) and we're done. Notice that the add.image(...) method returns an instance of itself so that we can chain a series of method calls together. In this case we add the image and then set the origin X/Y in one go. Once the background is sorted we add two buttons - one for single player and one for multi player. For now we only need to worry about single player, so this is the code we care about: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const singlePlayerButton = new TextButton ( this , menuButtonLayout . x , menuButtonLayout . y , 'Single Player' , menuButtonLayout . bitmapFontId , menuButtonLayout . fontSize , menuButtonLayout . color , () => { // On click console . log ( 'Starting new single player game...' ) const gameInterface = new SinglePlayerGame ({ sequence : 0 , vsScreenDelay : 500 , bossFight : false }, { undefeated : true } ) audioManager . playEffect ( 'impact' , { seek : 1 }) this . scene . start ( 'StoryIntroScene' , { gameInterface : gameInterface }) }, () => { // On hover this . fistIndicator . setY ( menuButtonLayout . y + menuButtonLayout . fistIndicatorYOffset ) this . fistIndicator . setTexture ([ 'rockIco' , 'paperIco' , 'scissorsIco' ][ ++ this . menuHighlightIconIndex % 3 ]) } ) singlePlayerButton . setOrigin ( menuButtonLayout . originX , menuButtonLayout . originY ) this . add . existing ( singlePlayerButton ) There's quite a lot going on here, but it's all pretty simple stuff. We simple create a new instance of a text button - which is a custom component that renders text that can be clicked. Hopefully you've already seen and interacted with this text button by playing the game. The text button needs some coordinates and configuration values, but what's more interesting is the final constructor argument. It's a callback - it's the code that is executed when the text button is clicked. We create an instance of a SinglePlayerGame and then call this.scene.start to progress on to the next scene in single player mode. The next scene is the StoryIntroScene which presents the game narrative - but that scene is a bit boring, so let's skip over it an move straight on to character selection. Character Selection The character selection scene will hopefully feel familiar already. Our layouts are back and really we're just loading a bunch of different assets - but there are some new concepts that are worth touching on. Custom components You've already seen one custom component in the form of a TextButton . The character select scene has another called CharacterInfoBox , which represents the following section of the UI: These custom components can be found in client/src/ui_elements.js . It's worth calling out that that some of these components are subclasses of existing Phaser entities, but some are simply an abstraction to reduce code complexity. Our TextButton , for example, extends Phaser.GameObjects.BitmapText - meaning it can be handled by Phaser like any other game object. Our CharacterInfoBox on the other hand is not a type of GameObject. It is simply a wrapper class around a group of components in the UI. It didn't make sense to me at the time to make it a game object - though this might change in the future. Regardless of whether our custom components are game objects are not, the intention is the same. We want to avoid code duplication and we want to keep our scene code simple. Tweening We've got some fancy animations going on in this scene. To do this we use a common technique called tweening , which is kind of short for in between . You may also hear this being referred to as interpolation . Basically we are telling phaser: I have this image of a character at position X. I want to move the character to position Y and I want it to take 1 second. You fill in all of the points in between to create a smooth looking animation. In Phaser the code looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 tweenCharacterIn : function ( character ) { character . setVisible ( true ) const tweenConfig = { // A `tween config` that tells Phaser what to animate targets : [ character ], // The game entities we want to tween x : this . layoutData . ui . character . x , // The attribute of the entity we want to tween duration : 500 , // How long we want the tween to take ease : 'Expo.easeOut' , // This is a 'easing' function, which adds a sort of deceleration effect repeat : 0 , onComplete : () => { // This is called when the animations completes this . characterSelectEnabled = true } } this . tweens . add ( tweenConfig ) }, This is the method we call when we want to animate a character on to the screen. I've added some comments to explain the various components. The most important part is: 1 x : this . layoutData . ui . character . x This is telling Phaser to tween the x attribute of our character image. When the character is off screen the x coordinate will be a negative value. We're telling Phaser to increase the x coordinate until it's value is equal to this.layoutData.ui.character.x . It looks something like this when laid out on a labelled axis: In our example the Aruka's initial coordinates are: 1 2 3 4 x: -40 y: 40 Origin x: 0.0 Origin y: 1.0 But we want Phaser to animate him over to: 1 2 3 4 x: 10 y: 40 Origin x: 0.0 Origin y: 1.0 And we want it to take 500 milliseconds. Try changing some of these values yourself. Increase or decrease the duration to slow down or speed up the animation. Also take a look at the Phaser docs to see what other ease functions are available and what they do. Again - the best way to understand this stuff is to play with it yourself. Data driven development If you've been looking through the code you may notice we load the character image and headshot by looping through the character list and creating images for each one: 1 2 3 4 5 6 7 8 9 10 const fullbody = this . add . image ( characterLayout . x - characterLayout . width , // Start off screen characterLayout . y , character . id + '_upperbody' ). setVisible ( false ). setOrigin ( characterLayout . originX , characterLayout . originY ) With the above code we create and add an image to the scene. Notice that the first argument, which is the X coordinate, is a negative value. As already mentioned above this is because we want to animate the image in from the left. Also notice that the line character.id + '_upperbody' . This is the ID of the texture. If you look through the game assets or read through the loading code you will find that the character images are all named <character_id>_<image_id>. For example: 1 2 3 man_headshot, // Manbo's headshot hog_upperbody, // Hogo Sha's upper body mai_flag // Mainyu's flag This allows us to dynamically add characters to the game simply by adding the required images and character config (their backstory etc...). We don't need to change any code - meaning our game is data driven when it comes to the characters. VS scene The VS scene is where we display who the player will be facing in the next round. This one is pretty simple - though there are a couple of things we should look at a little closer. View data If you look at the init method you'll see something called viewData : 1 2 3 4 5 6 7 8 init : function ( data ) { this . gameInterface = data . gameInterface this . viewData = this . gameInterface . getGameViewData () // This guy right here this . p1Ready = false this . p2Ready = false this . unknownOpponent = null this . battleSceneStarted = false } Back in the main menu scene we created an instance of a SinglePlayerGame . That object contains an object we call the view data . This object contains everything the UI needs to know in order to display the current state of the key. This is as close as our ever gets to the game engine (and the game server - bit we'll get to that later). It's an abstraction . This object is how we decouple our game logic from our UI. This is essential if we want to use the same engine on the client and on the server. The update method This is the first time we use Phaser 's update method. It is a scene method that is called once every frame. So if the game is running at 30 frames per second, this method will be called 30 times every second. In the VS scene we need to wait until both player have selected a character. For single player this happens instantly because in single player mode each character has a predetermined list of opponents. During multi-player we need to wait in this scene for an opponent. We don't need to worry about multi-player right now, but let's look at how we use the view data to update the state of this scene: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if ( ! this . p2Ready && this . viewData . p2Spec != null ) { if ( this . unknownOpponent ) { // Opponent joined multi-player game, need to animate this out this . tweens . add ({ targets : this . unknownOpponent , x : '+=' + this . layoutData . graphics . unknownOpponent . xTranslationDistance , duration : this . layoutData . graphics . unknownOpponent . xTranslationDuration , ease : 'Expo.easeOut' }) } const p2Layout = this . layoutData . graphics . p2 this . p2CharacterImage . setTexture ( this . viewData . p2Spec . id + '_upperbody' ) ... } This is a snippet taken from the update method. this.p2Ready is a boolean that belongs to the VS scene. We use this to make sure we don't process character selection more than once. this.viewData.p2Spec tells us which character, if any has been selected. P2 is player 2 and spec references the specification , or settings, of the character they selected. The VS scene has no idea whether P2 is the computer or another human player on the other side of the world - and that's exactly how we want it. Once a spec has been set we are free to go ahead and render the character that was selected, using information contained within the spec. The fight scene The fight scene is where all of the action happens, so unsurprisingly it is the most complicated scene in the game. The graphics are fairly straight forward, nothing much we haven't seen in other scenes. We have some text, character art and a background. Each character has a health bar, which is another custom component that lives in client/src/ui_elements/health_bar.js . All we do is render two rectangles, one on top of the other. We size the one on top based on the % health remaining for that character. We use our update method to keep our health bars up to date: 1 2 3 4 5 update : function ( time , delta ) { this . p1HealthBar . updateHealth ( this . viewData . p1CurrentHealth ) this . p2HealthBar . updateHealth ( this . viewData . p2CurrentHealth ) ... } Again we're just pulling information from the viewData object. This information could be coming from the server, or not, the scene doesn't care. The real complexity in this scene comes from it's interactions with the game engine, so let's look there. Game Events 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 this . gameInterface . addEventListener (( event ) => this . gameEventListener ( event )) ... gameEventListener : function ( event ) { if ( event instanceof RPSRoundEvent ) { switch ( event . type ) { case RPSRoundEvent . ROUND_COUNTDOWN : this . handleRoundCountdownEvent ( event ) break case RPSRoundEvent . WEAPON_COUNTDOWN : this . handleWeaponCountdownEvent ( event ) break case RPSRoundEvent . STATE_CHANGE : this . handleStateChangeEvent ( event ) break case RPSRoundEvent . WEAPONS_SELECTED : this . handleBattleEvent ( event ) break case RPSRoundEvent . ROUND_FINISHED : this . handleRoundEnd ( event ) break case RPSRoundEvent . ROUND_STARTED : break default : console . log ( 'Got unknown round event type: ' + event . type ) break } } else if ( event instanceof RPSGameEvent ) { switch ( event . type ) { case RPSGameEvent . GAME_COMPLETE : this . leaveScene ( 'PostFightScene' , { gameInterface : this . gameInterface }) break default : console . log ( 'Got unknown game event type: ' + event . type ) break } } } First we register a handler with something called the gameInterface . This game interface is the instance of SinglePlayerGame that we created in the menu scene. It's the same object we fetch the view data from - but the view data is a read-only data model, it doesn't allow us to interact with the game. We do that directly through the SinglePlayerGame object itself. In the event handler we have napped an event ID to methods that exist without our scene. These events are coming from the game engine, and could be coming from our local client or from a game server, depending on whether we're playing single or multi player. If you've played the game enough, the events should make immediate sense: 1 2 3 4 5 6 RPSRoundEvent . ROUND_STARTED // A new round has started RPSRoundEvent . ROUND_COUNTDOWN // At the start of each round we show a 'Get Ready' message - that is this event RPSRoundEvent . WEAPON_COUNTDOWN // The 3 second countdown for weapon selection comes in this event RPSRoundEvent . STATE_CHANGE // This signifies a state change, we'll discuss states more when we get to the game engine, but states includes things like [NEW_ROUND, COUNDOWN, WAITING_FOR_WEAPON_SELECTION] RPSRoundEvent . WEAPONS_SELECTED // Both players have selected their weapon so we need to show the result RPSRoundEvent . ROUND_FINISHED // A round has ended The game engine fires out these key events letting the game client know that it should update the game state. Game States Another thing that's worth looking at is how we handle game state changes. State changes are slightly different to events in that we sometimes want to know when we enter a state and when we exit a state, so here's how we handle that: 1 2 3 4 5 6 this . stateHandlerMap [ RPSRoundStates . NEW_ROUND ] = { onEnter : () => { }, onExit : () => { } } 1 2 3 4 handleStateChangeEvent : function ( event ) { this . stateHandlerMap [ event . data . oldState ]. onExit () this . stateHandlerMap [ event . data . newState ]. onEnter () } The other scenes There are some other scenes, but we don't need to look to intensely at them just yet. Game over When that game ends, whether you lost the first match or defeated the last boss, you are sent to the game over scene. Depending on the result the scene will display a different message. If you beat the game you will get to see the end credits. Booting and Loading I've already mentioned these scenes. It's where we load all of the images and audio files we need to run the game. Narrative There are two different narrative scenes: The game lore The character lore When single player mode begins we display the game lore - this is the story line of the game. It scrolls up the screen and can be skipped. When the player selects a character they will then see that characters back story. This is also simple scrolling text that can be skipped. All of these characters, the story lines, their stats etc... are game design details. These details are configured in the game engine, so let's look there next.","title":"Single player"},{"location":"internship/onboarding/rps_game/single_player_mode/#working-with-phaser","text":"Phaser is a 2d graphics engine and does not come with any fancy UI or layout functionality. When working on Varcade Games we were able to use HTML and CSS to easily lay out all of our content in a nice organized fashion. With Phaser we're 2d graphics land, which means a Cartesian plane and a X/Y coordinates. The top left hand corner of the game is point X=0, Y=0. As we add images, test and buttons to our game we have to explicitly set their X/Y coordinates on that plane. If you're not careful you will end up with lots of hardcoded values in your code, which can become pretty painful pretty quickly. So, before we go any further we should check out our layout file.","title":"Working with Phaser"},{"location":"internship/onboarding/rps_game/single_player_mode/#layout","text":"Open up client/src/game_data/layout.js and have a look around. At the top we have a couple of global variables. It's useful to calculate and store screen height / width and half height / half width as they will help us position game objects relative to the screen. For example if you want to position something in the middle of the screen you set X to half width and Y to half height. You will see these values used extensively throughout the rest of the file. The first layout, and most straight forward layout, in the file is for the Loading scene: 1 2 3 4 5 6 7 8 9 10 11 12 13 LoadingScene : { ui : { text : { originX : 0.5 , originY : 0.5 , bitmapFontId : 'verdana64' , color : 0xFF0000 , fontSize : 48 , x : globalLayoutData . halfScreenWidth , y : globalLayoutData . halfScreenHeight } } }, So what can we infer from this? Well it's safe to say that there is probably a loading scene. That loading scene probably has some UI and the UI looks like it has some text. That text has a bunch of data associated with it. A lot of it should be obvious - there's an X and Y coordinate, a color, a font ID and a font size. The only bits that might be unfamiliar are originX and originY . You will see this used extensively through out our layout file as it is a really useful feature that Phaser has. When positioning an object in 2d space you can specify the coordinates relative to some point on the object... this is a lot easier to explain with a diagram: As you can see in the image above, I am describing the position of the images in space relative to a point on the image. If I set the origin X and Y of an image to (0, 0), then placing the image at coordinates (10, 10) will result in Phaser rendering that image with the top left corner at that point. If I set the origin X and origin Y of an image to (0.5, 0.5), then placing the image at coordinates (40, 30) will result in Phaser rendering that image with the center at those coordinates. Why 0.5? Because the minimum value for the origin is 0 and the maximum is 1.0. So specifying 0.5 for the origin of both X and Y represents half way of both axes. If this is confusing don't worry about - jump into the code and make some changes and see what happens. The background for the main menu scene is defined next in the layout: 1 2 3 4 5 6 7 8 9 10 MainMenuScene : { ui : { background : { originX : 0 , originY : 0 , x : 0 , y : 0 } } } Try changing the origin X and Y to 0.5 and see what happens. What do you need to change X and Y to in order to fix it? That brief introduction should be enough for you to be able to find your way around the various scene layouts - so let's move on to the code.","title":"Layout"},{"location":"internship/onboarding/rps_game/single_player_mode/#the-main-menu","text":"The main menu is one of the simpler scenes in the game, so we can use it to get a sense of how scenes are set up. First off we need to create a new instance of a Phaser Scene: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const MainMenuScene = new Phaser . Class ({ Extends : Phaser . Scene , initialize : function () { Phaser . Scene . call ( this , { key : 'MainMenuScene' }) this . menuHighlightIconIndex = 0 }, init : function ( data ) { this . error = data . error // This will be filled if returning from an error in another scene }, create : function () { ... } ... } You will see this same basic setup in all of our scenes. Initialize acts as our constructor. init is called when the scene is being started and can also be used to pass data around, as we do here. Finally the create function is where we actually create our scene by adding images and text etc... Our rendering code looks like this: 1 2 3 4 5 6 7 8 this . layoutData = getSceneLayoutData ( 'MainMenuScene' ) const bgLayout = this . layoutData . ui . background this . add . image ( bgLayout . x , bgLayout . y , 'mainMenuBg' ). setOrigin ( bgLayout . originX , bgLayout . originY ) This is where we add the background image for our scene. First we fetch the layout information for the scene. Next we call a Phaser function: this.add.image - which is basically saying to Phaser 'add an image to this scene'. We give it the various coordinates and the ID of the image (this can be found in the asset list we discussed earlier) and we're done. Notice that the add.image(...) method returns an instance of itself so that we can chain a series of method calls together. In this case we add the image and then set the origin X/Y in one go. Once the background is sorted we add two buttons - one for single player and one for multi player. For now we only need to worry about single player, so this is the code we care about: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const singlePlayerButton = new TextButton ( this , menuButtonLayout . x , menuButtonLayout . y , 'Single Player' , menuButtonLayout . bitmapFontId , menuButtonLayout . fontSize , menuButtonLayout . color , () => { // On click console . log ( 'Starting new single player game...' ) const gameInterface = new SinglePlayerGame ({ sequence : 0 , vsScreenDelay : 500 , bossFight : false }, { undefeated : true } ) audioManager . playEffect ( 'impact' , { seek : 1 }) this . scene . start ( 'StoryIntroScene' , { gameInterface : gameInterface }) }, () => { // On hover this . fistIndicator . setY ( menuButtonLayout . y + menuButtonLayout . fistIndicatorYOffset ) this . fistIndicator . setTexture ([ 'rockIco' , 'paperIco' , 'scissorsIco' ][ ++ this . menuHighlightIconIndex % 3 ]) } ) singlePlayerButton . setOrigin ( menuButtonLayout . originX , menuButtonLayout . originY ) this . add . existing ( singlePlayerButton ) There's quite a lot going on here, but it's all pretty simple stuff. We simple create a new instance of a text button - which is a custom component that renders text that can be clicked. Hopefully you've already seen and interacted with this text button by playing the game. The text button needs some coordinates and configuration values, but what's more interesting is the final constructor argument. It's a callback - it's the code that is executed when the text button is clicked. We create an instance of a SinglePlayerGame and then call this.scene.start to progress on to the next scene in single player mode. The next scene is the StoryIntroScene which presents the game narrative - but that scene is a bit boring, so let's skip over it an move straight on to character selection.","title":"The main menu"},{"location":"internship/onboarding/rps_game/single_player_mode/#character-selection","text":"The character selection scene will hopefully feel familiar already. Our layouts are back and really we're just loading a bunch of different assets - but there are some new concepts that are worth touching on.","title":"Character Selection"},{"location":"internship/onboarding/rps_game/single_player_mode/#custom-components","text":"You've already seen one custom component in the form of a TextButton . The character select scene has another called CharacterInfoBox , which represents the following section of the UI: These custom components can be found in client/src/ui_elements.js . It's worth calling out that that some of these components are subclasses of existing Phaser entities, but some are simply an abstraction to reduce code complexity. Our TextButton , for example, extends Phaser.GameObjects.BitmapText - meaning it can be handled by Phaser like any other game object. Our CharacterInfoBox on the other hand is not a type of GameObject. It is simply a wrapper class around a group of components in the UI. It didn't make sense to me at the time to make it a game object - though this might change in the future. Regardless of whether our custom components are game objects are not, the intention is the same. We want to avoid code duplication and we want to keep our scene code simple.","title":"Custom components"},{"location":"internship/onboarding/rps_game/single_player_mode/#tweening","text":"We've got some fancy animations going on in this scene. To do this we use a common technique called tweening , which is kind of short for in between . You may also hear this being referred to as interpolation . Basically we are telling phaser: I have this image of a character at position X. I want to move the character to position Y and I want it to take 1 second. You fill in all of the points in between to create a smooth looking animation. In Phaser the code looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 tweenCharacterIn : function ( character ) { character . setVisible ( true ) const tweenConfig = { // A `tween config` that tells Phaser what to animate targets : [ character ], // The game entities we want to tween x : this . layoutData . ui . character . x , // The attribute of the entity we want to tween duration : 500 , // How long we want the tween to take ease : 'Expo.easeOut' , // This is a 'easing' function, which adds a sort of deceleration effect repeat : 0 , onComplete : () => { // This is called when the animations completes this . characterSelectEnabled = true } } this . tweens . add ( tweenConfig ) }, This is the method we call when we want to animate a character on to the screen. I've added some comments to explain the various components. The most important part is: 1 x : this . layoutData . ui . character . x This is telling Phaser to tween the x attribute of our character image. When the character is off screen the x coordinate will be a negative value. We're telling Phaser to increase the x coordinate until it's value is equal to this.layoutData.ui.character.x . It looks something like this when laid out on a labelled axis: In our example the Aruka's initial coordinates are: 1 2 3 4 x: -40 y: 40 Origin x: 0.0 Origin y: 1.0 But we want Phaser to animate him over to: 1 2 3 4 x: 10 y: 40 Origin x: 0.0 Origin y: 1.0 And we want it to take 500 milliseconds. Try changing some of these values yourself. Increase or decrease the duration to slow down or speed up the animation. Also take a look at the Phaser docs to see what other ease functions are available and what they do. Again - the best way to understand this stuff is to play with it yourself.","title":"Tweening"},{"location":"internship/onboarding/rps_game/single_player_mode/#data-driven-development","text":"If you've been looking through the code you may notice we load the character image and headshot by looping through the character list and creating images for each one: 1 2 3 4 5 6 7 8 9 10 const fullbody = this . add . image ( characterLayout . x - characterLayout . width , // Start off screen characterLayout . y , character . id + '_upperbody' ). setVisible ( false ). setOrigin ( characterLayout . originX , characterLayout . originY ) With the above code we create and add an image to the scene. Notice that the first argument, which is the X coordinate, is a negative value. As already mentioned above this is because we want to animate the image in from the left. Also notice that the line character.id + '_upperbody' . This is the ID of the texture. If you look through the game assets or read through the loading code you will find that the character images are all named <character_id>_<image_id>. For example: 1 2 3 man_headshot, // Manbo's headshot hog_upperbody, // Hogo Sha's upper body mai_flag // Mainyu's flag This allows us to dynamically add characters to the game simply by adding the required images and character config (their backstory etc...). We don't need to change any code - meaning our game is data driven when it comes to the characters.","title":"Data driven development"},{"location":"internship/onboarding/rps_game/single_player_mode/#vs-scene","text":"The VS scene is where we display who the player will be facing in the next round. This one is pretty simple - though there are a couple of things we should look at a little closer.","title":"VS scene"},{"location":"internship/onboarding/rps_game/single_player_mode/#view-data","text":"If you look at the init method you'll see something called viewData : 1 2 3 4 5 6 7 8 init : function ( data ) { this . gameInterface = data . gameInterface this . viewData = this . gameInterface . getGameViewData () // This guy right here this . p1Ready = false this . p2Ready = false this . unknownOpponent = null this . battleSceneStarted = false } Back in the main menu scene we created an instance of a SinglePlayerGame . That object contains an object we call the view data . This object contains everything the UI needs to know in order to display the current state of the key. This is as close as our ever gets to the game engine (and the game server - bit we'll get to that later). It's an abstraction . This object is how we decouple our game logic from our UI. This is essential if we want to use the same engine on the client and on the server.","title":"View data"},{"location":"internship/onboarding/rps_game/single_player_mode/#the-update-method","text":"This is the first time we use Phaser 's update method. It is a scene method that is called once every frame. So if the game is running at 30 frames per second, this method will be called 30 times every second. In the VS scene we need to wait until both player have selected a character. For single player this happens instantly because in single player mode each character has a predetermined list of opponents. During multi-player we need to wait in this scene for an opponent. We don't need to worry about multi-player right now, but let's look at how we use the view data to update the state of this scene: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if ( ! this . p2Ready && this . viewData . p2Spec != null ) { if ( this . unknownOpponent ) { // Opponent joined multi-player game, need to animate this out this . tweens . add ({ targets : this . unknownOpponent , x : '+=' + this . layoutData . graphics . unknownOpponent . xTranslationDistance , duration : this . layoutData . graphics . unknownOpponent . xTranslationDuration , ease : 'Expo.easeOut' }) } const p2Layout = this . layoutData . graphics . p2 this . p2CharacterImage . setTexture ( this . viewData . p2Spec . id + '_upperbody' ) ... } This is a snippet taken from the update method. this.p2Ready is a boolean that belongs to the VS scene. We use this to make sure we don't process character selection more than once. this.viewData.p2Spec tells us which character, if any has been selected. P2 is player 2 and spec references the specification , or settings, of the character they selected. The VS scene has no idea whether P2 is the computer or another human player on the other side of the world - and that's exactly how we want it. Once a spec has been set we are free to go ahead and render the character that was selected, using information contained within the spec.","title":"The update method"},{"location":"internship/onboarding/rps_game/single_player_mode/#the-fight-scene","text":"The fight scene is where all of the action happens, so unsurprisingly it is the most complicated scene in the game. The graphics are fairly straight forward, nothing much we haven't seen in other scenes. We have some text, character art and a background. Each character has a health bar, which is another custom component that lives in client/src/ui_elements/health_bar.js . All we do is render two rectangles, one on top of the other. We size the one on top based on the % health remaining for that character. We use our update method to keep our health bars up to date: 1 2 3 4 5 update : function ( time , delta ) { this . p1HealthBar . updateHealth ( this . viewData . p1CurrentHealth ) this . p2HealthBar . updateHealth ( this . viewData . p2CurrentHealth ) ... } Again we're just pulling information from the viewData object. This information could be coming from the server, or not, the scene doesn't care. The real complexity in this scene comes from it's interactions with the game engine, so let's look there.","title":"The fight scene"},{"location":"internship/onboarding/rps_game/single_player_mode/#game-events","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 this . gameInterface . addEventListener (( event ) => this . gameEventListener ( event )) ... gameEventListener : function ( event ) { if ( event instanceof RPSRoundEvent ) { switch ( event . type ) { case RPSRoundEvent . ROUND_COUNTDOWN : this . handleRoundCountdownEvent ( event ) break case RPSRoundEvent . WEAPON_COUNTDOWN : this . handleWeaponCountdownEvent ( event ) break case RPSRoundEvent . STATE_CHANGE : this . handleStateChangeEvent ( event ) break case RPSRoundEvent . WEAPONS_SELECTED : this . handleBattleEvent ( event ) break case RPSRoundEvent . ROUND_FINISHED : this . handleRoundEnd ( event ) break case RPSRoundEvent . ROUND_STARTED : break default : console . log ( 'Got unknown round event type: ' + event . type ) break } } else if ( event instanceof RPSGameEvent ) { switch ( event . type ) { case RPSGameEvent . GAME_COMPLETE : this . leaveScene ( 'PostFightScene' , { gameInterface : this . gameInterface }) break default : console . log ( 'Got unknown game event type: ' + event . type ) break } } } First we register a handler with something called the gameInterface . This game interface is the instance of SinglePlayerGame that we created in the menu scene. It's the same object we fetch the view data from - but the view data is a read-only data model, it doesn't allow us to interact with the game. We do that directly through the SinglePlayerGame object itself. In the event handler we have napped an event ID to methods that exist without our scene. These events are coming from the game engine, and could be coming from our local client or from a game server, depending on whether we're playing single or multi player. If you've played the game enough, the events should make immediate sense: 1 2 3 4 5 6 RPSRoundEvent . ROUND_STARTED // A new round has started RPSRoundEvent . ROUND_COUNTDOWN // At the start of each round we show a 'Get Ready' message - that is this event RPSRoundEvent . WEAPON_COUNTDOWN // The 3 second countdown for weapon selection comes in this event RPSRoundEvent . STATE_CHANGE // This signifies a state change, we'll discuss states more when we get to the game engine, but states includes things like [NEW_ROUND, COUNDOWN, WAITING_FOR_WEAPON_SELECTION] RPSRoundEvent . WEAPONS_SELECTED // Both players have selected their weapon so we need to show the result RPSRoundEvent . ROUND_FINISHED // A round has ended The game engine fires out these key events letting the game client know that it should update the game state.","title":"Game Events"},{"location":"internship/onboarding/rps_game/single_player_mode/#game-states","text":"Another thing that's worth looking at is how we handle game state changes. State changes are slightly different to events in that we sometimes want to know when we enter a state and when we exit a state, so here's how we handle that: 1 2 3 4 5 6 this . stateHandlerMap [ RPSRoundStates . NEW_ROUND ] = { onEnter : () => { }, onExit : () => { } } 1 2 3 4 handleStateChangeEvent : function ( event ) { this . stateHandlerMap [ event . data . oldState ]. onExit () this . stateHandlerMap [ event . data . newState ]. onEnter () }","title":"Game States"},{"location":"internship/onboarding/rps_game/single_player_mode/#the-other-scenes","text":"There are some other scenes, but we don't need to look to intensely at them just yet.","title":"The other scenes"},{"location":"internship/onboarding/rps_game/single_player_mode/#game-over","text":"When that game ends, whether you lost the first match or defeated the last boss, you are sent to the game over scene. Depending on the result the scene will display a different message. If you beat the game you will get to see the end credits.","title":"Game over"},{"location":"internship/onboarding/rps_game/single_player_mode/#booting-and-loading","text":"I've already mentioned these scenes. It's where we load all of the images and audio files we need to run the game.","title":"Booting and Loading"},{"location":"internship/onboarding/rps_game/single_player_mode/#narrative","text":"There are two different narrative scenes: The game lore The character lore When single player mode begins we display the game lore - this is the story line of the game. It scrolls up the screen and can be skipped. When the player selects a character they will then see that characters back story. This is also simple scrolling text that can be skipped. All of these characters, the story lines, their stats etc... are game design details. These details are configured in the game engine, so let's look there next.","title":"Narrative"},{"location":"internship/onboarding/rps_game/the_game_engine/","text":"The Game Engine is a combination of all of the game data and game logic for Rock Paper Scissors Apocalypse. It is a library that can be run in a browser or on a server - enabling multi-player gameplay. The game characters are defined here, as are the rules of the game and the execution of the game. In this section we'll have a quick look at some of the important elements of the engine. Game Data Open up game_engine/src/game_data.js . The contents of this file should be immediately familiar. It's all of the character information you've seen in the game UI. Here's the first entry in the character list: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 const characters = [ { id : 'aru' , displayName : 'Aruka' , country : 'Brazil' , stats : { health : 100 , style : 'paper' , rock : { baseDamage : 25 , damageModifier : 0 , damageMitigation : 0.2 }, paper : { baseDamage : 25 , damageModifier : 0.30 , damageMitigation : 0 }, scissors : { baseDamage : 25 , damageModifier : 0 , damageMitigation : 0 } }, singlePlayerSequence : [ 'man' , 'rad' , 'hog' ], locked : false , isBoss : false , singlePlayerUnlock : 'hog' , storyline : [ 'As humanity stood face to face with the darkest evil it had ever encountered, the indigenous warriors of the Amazon were some of the first to stand in its path.\\n' , 'Many believe that the spirit of mother nature flows through Aruka and guides him against the forces of darkness.\\n' , 'His intuition of all things natural, be they creative or destructive forces, makes Aruka a natural RPS contender. During battle he enters a trance-like state, through which his focus and composure is unwavering.' ], trashTalk : { win : [ 'The forest will always prevail...' ], lose : [ 'There is no good that lasts forever nor evil that never ends.' ] } } ... Some interesting fields here are: 1 2 3 singlePlayerSequence : [ 'man' , 'rad' , 'hog' ], These are the IDs of the characters that Aruka will face during single player mode. 1 locked : false , This tell the game client whether the character should initially be displayed as locked. If this is true you will need to make sure that the character can be unlocked (see below). 1 isBoss : false , This is, and should only be, true for one of the characters. The boss is treated differently to other players and is only faced once the player defeats all of their opponents without losing a single round. Mainyu is our boss. 1 singlePlayerUnlock : 'hog' , This entry tells us what character to unlock when this character successfully defeats every opponent in their singlePlayerSequence . Not every character unlocks another character, so this can be null. Try playing around with some of these settings and see what happens. Game Models This is where we define the various different game objects that we will use to represent players in the game, along with their characters and weapon selections. Most of these classes should be fairly self-explanatory. One thing to note is the RPSFighter : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class RPSFighter { /** * Represents the player's character selection. **/ constructor ( spec ) { this . id = spec . id this . spec = spec // Amount of damage this fighter has taken in the current round this . damage = 0 this . weapons = [ new Rock ( this . spec . stats . rock . baseDamage , { damageModifier : this . spec . stats . rock . damageModifier , damageMitigation : this . spec . stats . rock . damageMitigation }), new Paper ( this . spec . stats . paper . baseDamage , { damageModifier : this . spec . stats . paper . damageModifier , damageMitigation : this . spec . stats . paper . damageMitigation }), new Scissors ( this . spec . stats . scissors . baseDamage , { damageModifier : this . spec . stats . scissors . damageModifier , damageMitigation : this . spec . stats . scissors . damageMitigation }) ] this . currentSelectedWeaponIndex = null // True if the current round is accepting weapon selection from players this . weaponSelectAvailable = false } In it's constructor it loads stats from game_data.js . So we can balance the characters strengths and weaknesses from the data file. Or in other words - it's data driven . A couple of other interesting classes in this file are our bots: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class RPSStrategyBot extends RPSPlayer { /** * Represents an AI player (single player mode) * that uses some basic strategy, as defined in * strategy.js **/ constructor ( id , difficulty ) { super ( id ) this . strategy = getStrategy ( difficulty ) } eventListener ( event ) { if ( event instanceof RPSRoundEvent ) { if ( event . type === RPSRoundEvent . WEAPON_COUNTDOWN && event . data . value === 2 ) { this . fighter . equipWeapon ( this . strategy . getNextSelection ( this . fighter . getCurrentHealthPct ())) } if ( event . type === RPSRoundEvent . ROUND_FINISHED ) { this . strategy . reset () } } } } class RPSRandomBot extends RPSPlayer { /** * Represents an AI player (single player mode) * that simply makes random selection - * !Note! This is one of the most difficult to play against **/ eventListener ( event ) { if ( event instanceof RPSRoundEvent ) { if ( event . type === RPSRoundEvent . WEAPON_COUNTDOWN ) { this . fighter . equipWeapon ( Math . floor ( Math . random () * 3 )) } } } } The RPSRandomBot is used to create a single player enemy that will just make random selections. This is the hardest type of opponent to play against - so this is used by the final boss. The RPSStrategyBot is a little different. This object is used to create a single player enemy that plays according to strategies of varying difficulty. Our AI will always use some repeating pattern. The strategy difficulty dictates how difficult the pattern is to detect and whether the AI will change strategy after taking a certain amount of damage. These are used during single player to create a set of opponents that increase in difficulty as the player progresses. Game Play Open up game_engine/src/game_play.js . This is there the actual game happens. There is a class called RPSGame . This is class is essentially a state management system. Game States A game have a number of states it can be in: 1 2 3 4 5 6 class RPSGameStates { static get WAITING_FOR_PLAYERS () { return 0 } static get CHARACTER_SELECTION () { return 1 } static get IN_PROGRESS () { return 2 } static get GAME_OVER () { return 3 } } WAITING_FOR_PLAYERS The game has been created and is now waiting for players to be added. CHARACTER_SELECTION The game is now waiting for the players to make their character selection. IN_PROGRESS The game is in progress. GAME_OVER The game has ended. Rounds Once a game is in progress it is represented as a series of rounds. A player must win two rounds to win the game. Therefore the minimum number of rounds is 2 and the maximum is 3. Rounds are have a number of states that they progress through during gameplay: 1 2 3 4 5 static get NEW_ROUND () { return 0 } static get COUNTDOWN () { return 1 } static get WAITING_FOR_WEAPON_SELECTION () { return 2 } static get PROCESSING_RESULT () { return 3 } static get FINISHED () { return 4 } NEW_ROUND The round has been created. COUNTDOWN The 'start of round' countdown is in progress. WAITING_FOR_WEAPON_SELECTION Players can make their weapon selections. PROCESSING_RESULT The result of the player's selection are being processed. FINISHED The round has finished. A round will enter a cycle of going from WAITING_FOR_WEAPON_SELECTION to PROCESSING_RESULT until the game detects that a player has reached zero health, at which point it will progress to the FINISHED state. Tick So as you can see there is a logical progression of states that happens in order to make the game run. This progression is very similar in code to what the player experiences: Start game -> Select character -> Start battle -> start round -> select weapon -> Apply damage -> Repeat until health is zero -> End round -> Repeat until one player wins two rounds. But what is actually running this progression? That would be our game tick . The RPSGame object has a method: 1 2 3 tick () { this . stateHandlers [ this . state ]() } This method calls a state handler , which will behave differently depending on the current state of the game. This tick can be called at any desired interval. When the server is running the game it calls 'tick' every second. Single player mode calls it every half second. The speed of the game is based on the tick, because the tick is simply what causes our game states to change from one state to the next. If you want to play with this yourself, open up game_rps/client/src/game_engine_interface.js and find the line: 1 2 3 4 5 6 console . log ( 'Single player game - starting client side tick loop...' ) this . tickTimer = setInterval (() => { if ( ! this . paused ) { this . game . tick () } }, 500 ) That 500 is the 500 millisecond tick for single player. If you increase that value your single player game will run slower. Decrease it and it will run faster. That's about as deep as I want to go into the game for this onboarding course. Next we will look at the game design - understanding the gameplay will help you reason about the code.","title":"The Game Engine"},{"location":"internship/onboarding/rps_game/the_game_engine/#game-data","text":"Open up game_engine/src/game_data.js . The contents of this file should be immediately familiar. It's all of the character information you've seen in the game UI. Here's the first entry in the character list: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 const characters = [ { id : 'aru' , displayName : 'Aruka' , country : 'Brazil' , stats : { health : 100 , style : 'paper' , rock : { baseDamage : 25 , damageModifier : 0 , damageMitigation : 0.2 }, paper : { baseDamage : 25 , damageModifier : 0.30 , damageMitigation : 0 }, scissors : { baseDamage : 25 , damageModifier : 0 , damageMitigation : 0 } }, singlePlayerSequence : [ 'man' , 'rad' , 'hog' ], locked : false , isBoss : false , singlePlayerUnlock : 'hog' , storyline : [ 'As humanity stood face to face with the darkest evil it had ever encountered, the indigenous warriors of the Amazon were some of the first to stand in its path.\\n' , 'Many believe that the spirit of mother nature flows through Aruka and guides him against the forces of darkness.\\n' , 'His intuition of all things natural, be they creative or destructive forces, makes Aruka a natural RPS contender. During battle he enters a trance-like state, through which his focus and composure is unwavering.' ], trashTalk : { win : [ 'The forest will always prevail...' ], lose : [ 'There is no good that lasts forever nor evil that never ends.' ] } } ... Some interesting fields here are: 1 2 3 singlePlayerSequence : [ 'man' , 'rad' , 'hog' ], These are the IDs of the characters that Aruka will face during single player mode. 1 locked : false , This tell the game client whether the character should initially be displayed as locked. If this is true you will need to make sure that the character can be unlocked (see below). 1 isBoss : false , This is, and should only be, true for one of the characters. The boss is treated differently to other players and is only faced once the player defeats all of their opponents without losing a single round. Mainyu is our boss. 1 singlePlayerUnlock : 'hog' , This entry tells us what character to unlock when this character successfully defeats every opponent in their singlePlayerSequence . Not every character unlocks another character, so this can be null. Try playing around with some of these settings and see what happens.","title":"Game Data"},{"location":"internship/onboarding/rps_game/the_game_engine/#game-models","text":"This is where we define the various different game objects that we will use to represent players in the game, along with their characters and weapon selections. Most of these classes should be fairly self-explanatory. One thing to note is the RPSFighter : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class RPSFighter { /** * Represents the player's character selection. **/ constructor ( spec ) { this . id = spec . id this . spec = spec // Amount of damage this fighter has taken in the current round this . damage = 0 this . weapons = [ new Rock ( this . spec . stats . rock . baseDamage , { damageModifier : this . spec . stats . rock . damageModifier , damageMitigation : this . spec . stats . rock . damageMitigation }), new Paper ( this . spec . stats . paper . baseDamage , { damageModifier : this . spec . stats . paper . damageModifier , damageMitigation : this . spec . stats . paper . damageMitigation }), new Scissors ( this . spec . stats . scissors . baseDamage , { damageModifier : this . spec . stats . scissors . damageModifier , damageMitigation : this . spec . stats . scissors . damageMitigation }) ] this . currentSelectedWeaponIndex = null // True if the current round is accepting weapon selection from players this . weaponSelectAvailable = false } In it's constructor it loads stats from game_data.js . So we can balance the characters strengths and weaknesses from the data file. Or in other words - it's data driven . A couple of other interesting classes in this file are our bots: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class RPSStrategyBot extends RPSPlayer { /** * Represents an AI player (single player mode) * that uses some basic strategy, as defined in * strategy.js **/ constructor ( id , difficulty ) { super ( id ) this . strategy = getStrategy ( difficulty ) } eventListener ( event ) { if ( event instanceof RPSRoundEvent ) { if ( event . type === RPSRoundEvent . WEAPON_COUNTDOWN && event . data . value === 2 ) { this . fighter . equipWeapon ( this . strategy . getNextSelection ( this . fighter . getCurrentHealthPct ())) } if ( event . type === RPSRoundEvent . ROUND_FINISHED ) { this . strategy . reset () } } } } class RPSRandomBot extends RPSPlayer { /** * Represents an AI player (single player mode) * that simply makes random selection - * !Note! This is one of the most difficult to play against **/ eventListener ( event ) { if ( event instanceof RPSRoundEvent ) { if ( event . type === RPSRoundEvent . WEAPON_COUNTDOWN ) { this . fighter . equipWeapon ( Math . floor ( Math . random () * 3 )) } } } } The RPSRandomBot is used to create a single player enemy that will just make random selections. This is the hardest type of opponent to play against - so this is used by the final boss. The RPSStrategyBot is a little different. This object is used to create a single player enemy that plays according to strategies of varying difficulty. Our AI will always use some repeating pattern. The strategy difficulty dictates how difficult the pattern is to detect and whether the AI will change strategy after taking a certain amount of damage. These are used during single player to create a set of opponents that increase in difficulty as the player progresses.","title":"Game Models"},{"location":"internship/onboarding/rps_game/the_game_engine/#game-play","text":"Open up game_engine/src/game_play.js . This is there the actual game happens. There is a class called RPSGame . This is class is essentially a state management system.","title":"Game Play"},{"location":"internship/onboarding/rps_game/the_game_engine/#game-states","text":"A game have a number of states it can be in: 1 2 3 4 5 6 class RPSGameStates { static get WAITING_FOR_PLAYERS () { return 0 } static get CHARACTER_SELECTION () { return 1 } static get IN_PROGRESS () { return 2 } static get GAME_OVER () { return 3 } }","title":"Game States"},{"location":"internship/onboarding/rps_game/the_game_engine/#waiting_for_players","text":"The game has been created and is now waiting for players to be added.","title":"WAITING_FOR_PLAYERS"},{"location":"internship/onboarding/rps_game/the_game_engine/#character_selection","text":"The game is now waiting for the players to make their character selection.","title":"CHARACTER_SELECTION"},{"location":"internship/onboarding/rps_game/the_game_engine/#in_progress","text":"The game is in progress.","title":"IN_PROGRESS"},{"location":"internship/onboarding/rps_game/the_game_engine/#game_over","text":"The game has ended.","title":"GAME_OVER"},{"location":"internship/onboarding/rps_game/the_game_engine/#rounds","text":"Once a game is in progress it is represented as a series of rounds. A player must win two rounds to win the game. Therefore the minimum number of rounds is 2 and the maximum is 3. Rounds are have a number of states that they progress through during gameplay: 1 2 3 4 5 static get NEW_ROUND () { return 0 } static get COUNTDOWN () { return 1 } static get WAITING_FOR_WEAPON_SELECTION () { return 2 } static get PROCESSING_RESULT () { return 3 } static get FINISHED () { return 4 }","title":"Rounds"},{"location":"internship/onboarding/rps_game/the_game_engine/#new_round","text":"The round has been created.","title":"NEW_ROUND"},{"location":"internship/onboarding/rps_game/the_game_engine/#countdown","text":"The 'start of round' countdown is in progress.","title":"COUNTDOWN"},{"location":"internship/onboarding/rps_game/the_game_engine/#waiting_for_weapon_selection","text":"Players can make their weapon selections.","title":"WAITING_FOR_WEAPON_SELECTION"},{"location":"internship/onboarding/rps_game/the_game_engine/#processing_result","text":"The result of the player's selection are being processed.","title":"PROCESSING_RESULT"},{"location":"internship/onboarding/rps_game/the_game_engine/#finished","text":"The round has finished. A round will enter a cycle of going from WAITING_FOR_WEAPON_SELECTION to PROCESSING_RESULT until the game detects that a player has reached zero health, at which point it will progress to the FINISHED state.","title":"FINISHED"},{"location":"internship/onboarding/rps_game/the_game_engine/#tick","text":"So as you can see there is a logical progression of states that happens in order to make the game run. This progression is very similar in code to what the player experiences: Start game -> Select character -> Start battle -> start round -> select weapon -> Apply damage -> Repeat until health is zero -> End round -> Repeat until one player wins two rounds. But what is actually running this progression? That would be our game tick . The RPSGame object has a method: 1 2 3 tick () { this . stateHandlers [ this . state ]() } This method calls a state handler , which will behave differently depending on the current state of the game. This tick can be called at any desired interval. When the server is running the game it calls 'tick' every second. Single player mode calls it every half second. The speed of the game is based on the tick, because the tick is simply what causes our game states to change from one state to the next. If you want to play with this yourself, open up game_rps/client/src/game_engine_interface.js and find the line: 1 2 3 4 5 6 console . log ( 'Single player game - starting client side tick loop...' ) this . tickTimer = setInterval (() => { if ( ! this . paused ) { this . game . tick () } }, 500 ) That 500 is the 500 millisecond tick for single player. If you increase that value your single player game will run slower. Decrease it and it will run faster. That's about as deep as I want to go into the game for this onboarding course. Next we will look at the game design - understanding the gameplay will help you reason about the code.","title":"Tick"},{"location":"internship/onboarding/rps_game/working_with_the_game/","text":"Phaser Phaser is our game engine of choice. It's a popular 2D engine with an active and engaged community that is regularly updated. Before proceeding it's worth having a look through some of the official documentation and getting familiar with the layout of the site - you're going to need to be able to find your way around in there. Prerequisites At this point you should have your full Varcade Games stack up and running, but before proceeding let's double check. From your build_tools directory run: 1 make ps You should see something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Name Command State Ports ----------------------------------------------------------------------------------------------------------------- game-portal /bin/sh -c gunicorn game_p ... Up 0 .0.0.0:8000->8000/tcp game-portal-client docker-entrypoint.sh npm r ... Up 0 .0.0.0:8002->8002/tcp game-rps docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8080->8080/tcp, 0 .0.0.0:8085->8085/tcp game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp gameportaldb docker-entrypoint.sh mysqld Up 0 .0.0.0:3306->3306/tcp, 33060 /tcp grafana /run.sh Up 0 .0.0.0:3001->3000/tcp matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp prometheus /bin/prometheus --config.f ... Up 0 .0.0.0:9090->9090/tcp redis-db docker-entrypoint.sh redis ... Up 0 .0.0.0:6379->6379/tcp stats-tracker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5000->5000/tcp stats-tracker-worker /bin/sh -c python stats_wo ... Up 0 .0.0.0:5002->5002/tcp The line you're interested in is: 1 game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp This is our dev build of the game client. Notice at the end of the line: 1 0 .0.0.0:8090 This is telling us that the container is listening on port 8090... so let's try it. Open up your browser and navigate to localhost:8090 . You should be greeted by this page: What we've done is basically set up a dev server that hosts the game client so that we can play and work on the game without needing to run the whole Varcade Games stack. Our game can be built and played completely in isolation - which makes our lives a bit easier by allowing us to do more of that 'hot reloading' we saw earlier when working on the game portal. If you want to view logs for our game client you can do so with the command: 1 make logs a = game-rps-client My output looks like this right now: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 game-rps-client | \u2139 \uff62wdm\uff63: Compiled successfully. game-rps-client | \u2139 \uff62wdm\uff63: Compiling... game-rps-client | \u2139 \uff62wdm\uff63: Hash: d3673e4282f220a5448c game-rps-client | Version: webpack 4 .46.0 game-rps-client | Time: 482ms game-rps-client | Built at: 08 /22/2021 2 :19:54 PM game-rps-client | Asset Size Chunks Chunk Names game-rps-client | index.html 8 .57 KiB [ emitted ] game-rps-client | main.js 19 .3 MiB main [ emitted ] main game-rps-client | + 86 hidden assets game-rps-client | Entrypoint main = main.js game-rps-client | [ ./src/scenes/fight_screen.js ] 20 KiB { main } [ built ] game-rps-client | + 155 hidden modules game-rps-client | Child html-webpack-plugin for \"index.html\" : game-rps-client | 1 asset game-rps-client | Entrypoint undefined = index.html game-rps-client | 4 modules game-rps-client | \u2139 \uff62wdm\uff63: Compiled successfully. Which is telling me what a recent change to a file triggered a recompilation, which was a success. This should feel pretty familiar - I've tried to make interactions with the various different components as consistent as possible. Let's try it out properly by breaking something and then fixing it. Open up game_rps/client/src/index.js and comment out the second import like so: 1 //import { BootScene } from './scenes/boot_scene.js' Now open up your browser again. Everything should be broken, meaning you are left with a more or less blank screen: To understand what is going on here we need to open up the browser console again. You should see an error log that looks like this: 1 2 3 4 5 6 7 8 9 javascript Uncaught ReferenceError: BootScene is not defined at eval (index.js?b635:22) at Module../src/index.js (main.js:1663) at __webpack_require__ (main.js:20) at Object.0 (main.js:1843) at __webpack_require__ (main.js:20) at main.js:84 at main.js:87 Unsurprisingly the error is telling is that BootScene is not defined . This is because we just commented out the line of code that imports the BootScene (we'll talk about what the BootScene is soon). Remove the comment and take another look at your browser. The page should have reloaded automatically and start working again. And that's it - we can now player the game on a dev client, make changes and see the impact. Next we'll look at some of the key concepts around how we've used Phaser to create Rock Paper Scissors Apocalypse. Notes: Sometimes the page might not auto-reload after making a change. This could be after you add a new file (due to permission issues with your mounted directory), after you add a new dependency through NPM or if you make changes outside of the main src directory. In this case you can restart the image by running the following from your build_tools directory: make restart a=game-rps-client . If that doesn't work, you may need to rebuild with make build a=game-rps-client before reloading.","title":"Working with Rock Paper Scissors Apocalypse"},{"location":"internship/onboarding/rps_game/working_with_the_game/#phaser","text":"Phaser is our game engine of choice. It's a popular 2D engine with an active and engaged community that is regularly updated. Before proceeding it's worth having a look through some of the official documentation and getting familiar with the layout of the site - you're going to need to be able to find your way around in there.","title":"Phaser"},{"location":"internship/onboarding/rps_game/working_with_the_game/#prerequisites","text":"At this point you should have your full Varcade Games stack up and running, but before proceeding let's double check. From your build_tools directory run: 1 make ps You should see something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Name Command State Ports ----------------------------------------------------------------------------------------------------------------- game-portal /bin/sh -c gunicorn game_p ... Up 0 .0.0.0:8000->8000/tcp game-portal-client docker-entrypoint.sh npm r ... Up 0 .0.0.0:8002->8002/tcp game-rps docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8080->8080/tcp, 0 .0.0.0:8085->8085/tcp game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp gameportaldb docker-entrypoint.sh mysqld Up 0 .0.0.0:3306->3306/tcp, 33060 /tcp grafana /run.sh Up 0 .0.0.0:3001->3000/tcp matchmaker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5050->5050/tcp matchmaker-worker /bin/sh -c python game_wor ... Up 0 .0.0.0:5051->5051/tcp prometheus /bin/prometheus --config.f ... Up 0 .0.0.0:9090->9090/tcp redis-db docker-entrypoint.sh redis ... Up 0 .0.0.0:6379->6379/tcp stats-tracker /bin/sh -c gunicorn --relo ... Up 0 .0.0.0:5000->5000/tcp stats-tracker-worker /bin/sh -c python stats_wo ... Up 0 .0.0.0:5002->5002/tcp The line you're interested in is: 1 game-rps-client docker-entrypoint.sh /bin/ ... Up 0 .0.0.0:8090->8090/tcp This is our dev build of the game client. Notice at the end of the line: 1 0 .0.0.0:8090 This is telling us that the container is listening on port 8090... so let's try it. Open up your browser and navigate to localhost:8090 . You should be greeted by this page: What we've done is basically set up a dev server that hosts the game client so that we can play and work on the game without needing to run the whole Varcade Games stack. Our game can be built and played completely in isolation - which makes our lives a bit easier by allowing us to do more of that 'hot reloading' we saw earlier when working on the game portal. If you want to view logs for our game client you can do so with the command: 1 make logs a = game-rps-client My output looks like this right now: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 game-rps-client | \u2139 \uff62wdm\uff63: Compiled successfully. game-rps-client | \u2139 \uff62wdm\uff63: Compiling... game-rps-client | \u2139 \uff62wdm\uff63: Hash: d3673e4282f220a5448c game-rps-client | Version: webpack 4 .46.0 game-rps-client | Time: 482ms game-rps-client | Built at: 08 /22/2021 2 :19:54 PM game-rps-client | Asset Size Chunks Chunk Names game-rps-client | index.html 8 .57 KiB [ emitted ] game-rps-client | main.js 19 .3 MiB main [ emitted ] main game-rps-client | + 86 hidden assets game-rps-client | Entrypoint main = main.js game-rps-client | [ ./src/scenes/fight_screen.js ] 20 KiB { main } [ built ] game-rps-client | + 155 hidden modules game-rps-client | Child html-webpack-plugin for \"index.html\" : game-rps-client | 1 asset game-rps-client | Entrypoint undefined = index.html game-rps-client | 4 modules game-rps-client | \u2139 \uff62wdm\uff63: Compiled successfully. Which is telling me what a recent change to a file triggered a recompilation, which was a success. This should feel pretty familiar - I've tried to make interactions with the various different components as consistent as possible. Let's try it out properly by breaking something and then fixing it. Open up game_rps/client/src/index.js and comment out the second import like so: 1 //import { BootScene } from './scenes/boot_scene.js' Now open up your browser again. Everything should be broken, meaning you are left with a more or less blank screen: To understand what is going on here we need to open up the browser console again. You should see an error log that looks like this: 1 2 3 4 5 6 7 8 9 javascript Uncaught ReferenceError: BootScene is not defined at eval (index.js?b635:22) at Module../src/index.js (main.js:1663) at __webpack_require__ (main.js:20) at Object.0 (main.js:1843) at __webpack_require__ (main.js:20) at main.js:84 at main.js:87 Unsurprisingly the error is telling is that BootScene is not defined . This is because we just commented out the line of code that imports the BootScene (we'll talk about what the BootScene is soon). Remove the comment and take another look at your browser. The page should have reloaded automatically and start working again. And that's it - we can now player the game on a dev client, make changes and see the impact. Next we'll look at some of the key concepts around how we've used Phaser to create Rock Paper Scissors Apocalypse.","title":"Prerequisites"},{"location":"internship/onboarding/rps_game/working_with_the_game/#notes","text":"Sometimes the page might not auto-reload after making a change. This could be after you add a new file (due to permission issues with your mounted directory), after you add a new dependency through NPM or if you make changes outside of the main src directory. In this case you can restart the image by running the following from your build_tools directory: make restart a=game-rps-client . If that doesn't work, you may need to rebuild with make build a=game-rps-client before reloading.","title":"Notes:"},{"location":"internship/onboarding/rps_game_server/intro/","text":"We're about to venture deep into the server side of things... Server development can be intimidating for a number of reasons: No real visual indicators of progress (like with UI development) There are a lot of pitfalls and challenges to deal with There are a lot of concepts to learn beyond coding Networking Infrastructure Security Scalability Data management Data consistency We will touch all of those things to some degree, but don't get bogged down in all of that just yet. Let's instead focus on how we connect two players together for a nice game of Rock Paper Scissors. All of the code of this module lives in game_rps/server/game_server , so open it up in your text editor/IDE and lets get started.","title":"Introduction"},{"location":"internship/onboarding/rps_game_server/key_concepts/","text":"Before we look at the actual code, let's take a high level look at the design of the system and some of the important concepts at play. Game State First off, the Rock Paper Scissors Apocalypse (RPSA) game server is a stateful server . This means that it keeps all of its state in memory. This means that all of the games being played on the server are not saved to any persistent storage (like a database or hard disk). If the server dies all of the games are lost. This is a trade off I was happy to make in this case, because games are transient by nature. They are quick and self contained. If you're playing a game and server dies you only lose the progress for that game - it's not that big a deal. The benefit we get is that the server is quite simple and can be quite fast - since everything it needs is right there in memory. But what is the game state? Put simply the game state is: The set of all games being played at any moment in time, and the players that are playing those games. To understand exactly how this works lets go back to some of the sequence diagrams we saw earlier in the documentation. This time I've simplified them so that there are no Varcade Games components or Matchmaker components. Right now we're only interested in the game, which can be run completely standalone . Remember that, as it is much easier to work on just the game, without worrying about the game portal. Creating a game Take a moment to digest that image. The first thing that happens is that the game client creates a new game. It does this by sending a request to the game server. This is a normal HTTP request - just like any request you send through your browser. Note When a game is running from within Varcade Games it does not directly call the game server to create a game. The Matchmaker does that. In fact we actively hide this ability from game clients when deploying live. We want the matchmaker to act as a sort of security guard when it comes to creating and managing games. When the game server receives a request to create a game it will do exactly that. It will create a game (we'll see exactly how in the code later) and it will generate a token for that game. This token is how we control exactly who can connect to and play the game that was just created. Once the client has a token it can go ahead and connect to the game. This is where things change - this time the client will talk to the server over a Websocket . Earlier when we create the game we used the standard HTTP request-response model. This is where a client sends a request to a server, the server then does something and responds with an answer. That's it. It's a single interaction. When we open a socket connection (in this case a websocket ) that we're doing is creating a connection between the client and server. Once this connection is established, the client and server can freely send data to eachother as they please. Think about it like mail vs telephone. If you send someone a letter you have to wait for it to be delivered. They read it. Then they respond. If you call someone on the phone, you have a connection to them where you can both communicate at will. In our game client, once the socket connection has been created we can go ahead and allow the player that created the game to make their character selection. Once they do that, they need to sit and wait for another player to join. Note We'll talk about what happens when no one joins later when we get to the Matchmaker. Joining a game The join game flow is quite similar, except the first thing the player has to do is get a list of available games to join. Once they have that list they can ask the server join one of them (the server may say no, if for example the game has already reached max capacity). Once we have a token the rest of the flow is the same are the creation flow. The joining player selects their character. Once both players have their selection made the game can begin. At this point we have a server with an active game and two active websocket connections. Now we're ready to dig into the actual system design - what is actually happening behind all of those concepts we've just gone through?","title":"Key Concepts"},{"location":"internship/onboarding/rps_game_server/key_concepts/#game-state","text":"First off, the Rock Paper Scissors Apocalypse (RPSA) game server is a stateful server . This means that it keeps all of its state in memory. This means that all of the games being played on the server are not saved to any persistent storage (like a database or hard disk). If the server dies all of the games are lost. This is a trade off I was happy to make in this case, because games are transient by nature. They are quick and self contained. If you're playing a game and server dies you only lose the progress for that game - it's not that big a deal. The benefit we get is that the server is quite simple and can be quite fast - since everything it needs is right there in memory. But what is the game state? Put simply the game state is: The set of all games being played at any moment in time, and the players that are playing those games. To understand exactly how this works lets go back to some of the sequence diagrams we saw earlier in the documentation. This time I've simplified them so that there are no Varcade Games components or Matchmaker components. Right now we're only interested in the game, which can be run completely standalone . Remember that, as it is much easier to work on just the game, without worrying about the game portal.","title":"Game State"},{"location":"internship/onboarding/rps_game_server/key_concepts/#creating-a-game","text":"Take a moment to digest that image. The first thing that happens is that the game client creates a new game. It does this by sending a request to the game server. This is a normal HTTP request - just like any request you send through your browser. Note When a game is running from within Varcade Games it does not directly call the game server to create a game. The Matchmaker does that. In fact we actively hide this ability from game clients when deploying live. We want the matchmaker to act as a sort of security guard when it comes to creating and managing games. When the game server receives a request to create a game it will do exactly that. It will create a game (we'll see exactly how in the code later) and it will generate a token for that game. This token is how we control exactly who can connect to and play the game that was just created. Once the client has a token it can go ahead and connect to the game. This is where things change - this time the client will talk to the server over a Websocket . Earlier when we create the game we used the standard HTTP request-response model. This is where a client sends a request to a server, the server then does something and responds with an answer. That's it. It's a single interaction. When we open a socket connection (in this case a websocket ) that we're doing is creating a connection between the client and server. Once this connection is established, the client and server can freely send data to eachother as they please. Think about it like mail vs telephone. If you send someone a letter you have to wait for it to be delivered. They read it. Then they respond. If you call someone on the phone, you have a connection to them where you can both communicate at will. In our game client, once the socket connection has been created we can go ahead and allow the player that created the game to make their character selection. Once they do that, they need to sit and wait for another player to join. Note We'll talk about what happens when no one joins later when we get to the Matchmaker.","title":"Creating a game"},{"location":"internship/onboarding/rps_game_server/key_concepts/#joining-a-game","text":"The join game flow is quite similar, except the first thing the player has to do is get a list of available games to join. Once they have that list they can ask the server join one of them (the server may say no, if for example the game has already reached max capacity). Once we have a token the rest of the flow is the same are the creation flow. The joining player selects their character. Once both players have their selection made the game can begin. At this point we have a server with an active game and two active websocket connections. Now we're ready to dig into the actual system design - what is actually happening behind all of those concepts we've just gone through?","title":"Joining a game"},{"location":"internship/onboarding/rps_game_server/playing_with_others/","text":"At this point you should have your Varcade Games stack running. Point your browser at localhost:8090 to get access to the standalone game client, just like we did earlier when we talked about single player mode. When you select Multiplayer in the standalone client you get access to some additional debug UI that allows you to create your own multiplayer games, without needing Varcade Games and its matchmaker. You will find this to be very useful for testing multiplayer functionality as it will drastically increase you ability to make changes and test those changes quickly. Creating a game Select Multiplayer mode from the main menu and you will see a text box appear below the game. Enter a 'User id' (this can be any valid string) and hit the 'Select Name' button. Now you should have the option to create a game: Enter a game ID (again, any valid string will do - I went with 'test') then hit 'Create game'. Once you've done this the game client should change scene over to the character selection scene. Select a character and you should see this: We're halfway there... Joining a game Next open up a new tab in your browser and navigate to localhost:8090 . Select Multiplayer mode, just like before, and enter a different User id. Once you submit your user id you should see a list of available games to join under 'Active Games': Click the join link to join the game. This should cause the client to transition to the character select scene. Once you select your character, both clients should update and show the VS scene, then the game. Here I have set up two browser windows side by side so I can play against myself: Give it a try! Once you've played a game or two also try refreshing one or both of the browser windows. What happens if the host disconnects? What happens if the person that joined disconnects? It's worth spending a bit of time playing around and breaking things here.","title":"Playing with Others"},{"location":"internship/onboarding/rps_game_server/playing_with_others/#creating-a-game","text":"Select Multiplayer mode from the main menu and you will see a text box appear below the game. Enter a 'User id' (this can be any valid string) and hit the 'Select Name' button. Now you should have the option to create a game: Enter a game ID (again, any valid string will do - I went with 'test') then hit 'Create game'. Once you've done this the game client should change scene over to the character selection scene. Select a character and you should see this: We're halfway there...","title":"Creating a game"},{"location":"internship/onboarding/rps_game_server/playing_with_others/#joining-a-game","text":"Next open up a new tab in your browser and navigate to localhost:8090 . Select Multiplayer mode, just like before, and enter a different User id. Once you submit your user id you should see a list of available games to join under 'Active Games': Click the join link to join the game. This should cause the client to transition to the character select scene. Once you select your character, both clients should update and show the VS scene, then the game. Here I have set up two browser windows side by side so I can play against myself: Give it a try! Once you've played a game or two also try refreshing one or both of the browser windows. What happens if the host disconnects? What happens if the person that joined disconnects? It's worth spending a bit of time playing around and breaking things here.","title":"Joining a game"},{"location":"internship/onboarding/rps_game_server/system_design/","text":"The game server doesn't actually have all that much code. The game engine is a separately library that is shared between client and server, so the server doesn't need to worry about gameplay really. What it needs to do is create games and listen for player interactions and send messages and forth between the server and the game client. That's the server's main priority. Structure The diagram below shows some of the layers and interaction you will find in the server code. Note There is also an index.js file. It is the file that the NodeJS server launches. It just has some basic startup configuration in it. We don't need to consider it for now. The HTTP Server So the entry point to our game server is app.js . It's here that you can see the various other game server components getting initialized: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Metrics const metricsMiddleware = promBundle ({ includePath : true , httpDurationMetricName : 'game_rps_server_http_request_duration' }) // Prometheus middleware // HTTP Server const app = express () app . use ( metricsMiddleware ) app . use ( cors ()) app . use ( express . json ()) app . use ( httpLogger ) // Rock Paper Scissors Game Server const rpsGameServer = new RPS . RPSServer ( promBundle . promClient ) First up there are some metrics, so we can monitor the game server and make sure it's performing ok. Then the HTTP server we need for game management. We are using a popular HTTP server for NodeJS called Express . You can check out the official docs here . If you look down below the initialization section you will see where we set up 'routing' for Express JS. This is how we register endpoints for our game client and matchmaker to connect to when they want to create or join a game. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 app . post ( '/create_game' , function ( req , res ) { logger . info ( 'Received create game request: ${JSON.stringify(req.body)}' ) if ( ! validateGameRequest ( req , res )) { return } try { const gameData = rpsGameServer . createGame ( req . body . gameId , req . body . userId , req . body . username ) res . json ( gameData ) } catch ( err ) { if ( err instanceof RPSErrors . ValidationError ) { logger . warn ( 'Unable to create a new game, error message: ${err.message}' ) sendErrorResponse ( res , 400 , err . message ) } else { logger . error ( 'Unable to create a new game, error message: ${err.message}' ) sendErrorResponse ( res , 500 , 'An unexpected error occurred while trying to join the game.' ) } } }) Here we're adding a new endpoint to the app object, which is our reference to an Express server. This endpoint will accept 'POST' requests from clients that send requests to '/create_game'. The Game Server Once our metrics and HTTP server are set up we can create the game server: 1 const rpsGameServer = new RPS . RPSServer ( promBundle . promClient ) RPSServer can be found in game_server/rps.js . It is what connects players to games and manages the various events that are fired during a game. This makes it one of the more complex pieces of code in the project. But don't worry about that, how it works is pretty straight forward. RPSServer has the following member variables: 1 2 this . activeGames = {} // Maps a game ID to a GameHandler.MultiPlayerGame object this . tokenGameMap = {} // Maps game tokens to game IDs When we create a game we generate a token. Then we add token: game_id to the tokenGameMap object. Finally we add game_id: game to the activeGames object. Remember our sequence diagram earlier, where the Game Server returned a token to the game client? That is this token. When a player connects to a game server a token is supplied. The game server can then map that to a game ID and look up the corresponding game. Joining a game We do this because game IDs are shared with the Game Portal client, so nefarious players could potentially connect to games directly without going through the matchmaker. Most of what this class is doing is initializing the websocket connection, handling messages coming from the game clients and dealing with error scenarios, like if a connection drops. So we're still not playing the game yet - for that we need to once again consider the Game Engine.","title":"System Design"},{"location":"internship/onboarding/rps_game_server/system_design/#structure","text":"The diagram below shows some of the layers and interaction you will find in the server code. Note There is also an index.js file. It is the file that the NodeJS server launches. It just has some basic startup configuration in it. We don't need to consider it for now.","title":"Structure"},{"location":"internship/onboarding/rps_game_server/system_design/#the-http-server","text":"So the entry point to our game server is app.js . It's here that you can see the various other game server components getting initialized: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Metrics const metricsMiddleware = promBundle ({ includePath : true , httpDurationMetricName : 'game_rps_server_http_request_duration' }) // Prometheus middleware // HTTP Server const app = express () app . use ( metricsMiddleware ) app . use ( cors ()) app . use ( express . json ()) app . use ( httpLogger ) // Rock Paper Scissors Game Server const rpsGameServer = new RPS . RPSServer ( promBundle . promClient ) First up there are some metrics, so we can monitor the game server and make sure it's performing ok. Then the HTTP server we need for game management. We are using a popular HTTP server for NodeJS called Express . You can check out the official docs here . If you look down below the initialization section you will see where we set up 'routing' for Express JS. This is how we register endpoints for our game client and matchmaker to connect to when they want to create or join a game. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 app . post ( '/create_game' , function ( req , res ) { logger . info ( 'Received create game request: ${JSON.stringify(req.body)}' ) if ( ! validateGameRequest ( req , res )) { return } try { const gameData = rpsGameServer . createGame ( req . body . gameId , req . body . userId , req . body . username ) res . json ( gameData ) } catch ( err ) { if ( err instanceof RPSErrors . ValidationError ) { logger . warn ( 'Unable to create a new game, error message: ${err.message}' ) sendErrorResponse ( res , 400 , err . message ) } else { logger . error ( 'Unable to create a new game, error message: ${err.message}' ) sendErrorResponse ( res , 500 , 'An unexpected error occurred while trying to join the game.' ) } } }) Here we're adding a new endpoint to the app object, which is our reference to an Express server. This endpoint will accept 'POST' requests from clients that send requests to '/create_game'.","title":"The HTTP Server"},{"location":"internship/onboarding/rps_game_server/system_design/#the-game-server","text":"Once our metrics and HTTP server are set up we can create the game server: 1 const rpsGameServer = new RPS . RPSServer ( promBundle . promClient ) RPSServer can be found in game_server/rps.js . It is what connects players to games and manages the various events that are fired during a game. This makes it one of the more complex pieces of code in the project. But don't worry about that, how it works is pretty straight forward. RPSServer has the following member variables: 1 2 this . activeGames = {} // Maps a game ID to a GameHandler.MultiPlayerGame object this . tokenGameMap = {} // Maps game tokens to game IDs When we create a game we generate a token. Then we add token: game_id to the tokenGameMap object. Finally we add game_id: game to the activeGames object. Remember our sequence diagram earlier, where the Game Server returned a token to the game client? That is this token. When a player connects to a game server a token is supplied. The game server can then map that to a game ID and look up the corresponding game.","title":"The Game Server"},{"location":"internship/onboarding/rps_game_server/system_design/#joining-a-game","text":"We do this because game IDs are shared with the Game Portal client, so nefarious players could potentially connect to games directly without going through the matchmaker. Most of what this class is doing is initializing the websocket connection, handling messages coming from the game clients and dealing with error scenarios, like if a connection drops. So we're still not playing the game yet - for that we need to once again consider the Game Engine.","title":"Joining a game"},{"location":"internship/onboarding/rps_game_server/the_game_engine/","text":"I've mentioned a few times how the game engine is shared between the client and server. The MultiPlayerGame class in game_server/game_handler.js is what creates and runs the actual game logic. It is the server side equivalent of the client side game_engine_interface file we looked at on the client. The gameplay Player Input In single player mode user input is easy. Players click with their mouse and we handle it. In multi player we need to send that click to the server and then send it out to the other player. In the constructor of the MultiPlayerGame class you can see where we set up some functions to handle this. 1 2 3 4 5 this . messageHandlers = { select_fighter : ( conn , msg ) => this . handleSelectFighter ( conn , msg ), start_battle : ( conn , msg ) => this . handleStartBattle ( conn , msg ), select_weapon : ( conn , msg ) => this . handleSelectWeapon ( conn , msg ) } The three entries in this messageHandlers object represent the different possible player inputs. Players only really have two interactions with the game. They select a fighter and then choose between rock, paper and scissors on a loop. start_battle is a message that clients send to signal that they are ready to fight. We need to do this so that we can sync up the beginning of the battle scene. We won't go too deep on the rest of the code here as that warrants a course of it's own, and we will be back here once we get to the Matchmaker. You should absolutely explore it yourself though, try get a sense of what is going on in there.","title":"The Game Engine"},{"location":"internship/onboarding/rps_game_server/the_game_engine/#the-gameplay","text":"","title":"The gameplay"},{"location":"internship/onboarding/rps_game_server/the_game_engine/#player-input","text":"In single player mode user input is easy. Players click with their mouse and we handle it. In multi player we need to send that click to the server and then send it out to the other player. In the constructor of the MultiPlayerGame class you can see where we set up some functions to handle this. 1 2 3 4 5 this . messageHandlers = { select_fighter : ( conn , msg ) => this . handleSelectFighter ( conn , msg ), start_battle : ( conn , msg ) => this . handleStartBattle ( conn , msg ), select_weapon : ( conn , msg ) => this . handleSelectWeapon ( conn , msg ) } The three entries in this messageHandlers object represent the different possible player inputs. Players only really have two interactions with the game. They select a fighter and then choose between rock, paper and scissors on a loop. start_battle is a message that clients send to signal that they are ready to fight. We need to do this so that we can sync up the beginning of the battle scene. We won't go too deep on the rest of the code here as that warrants a course of it's own, and we will be back here once we get to the Matchmaker. You should absolutely explore it yourself though, try get a sense of what is going on in there.","title":"Player Input"},{"location":"internship/onboarding/varcade_games/adding_a_game/","text":"Adding a game to Varcade Games Navigate your browser to localhost:8000/admin . You should be greeted by a login page. Use the credentials that you provided in the early step where you ran ./manage.py createsuperuser . Once logged in you should see a menu that looks like this: Click the add link under the GAMES category. Fill in all of the fields with dummy data, for example: Game id: test_game Name: My Game Desc: A great game that you should play! Client url: empty Cover art: See below Game type: SinglePlayerOnly Game State: Coming Soon Adding Cover Art There is some sample cover art in the rps_game project. In VSCode you will find this file in game_rps/client/assets/exrps_cover.jpg . On Windows This might be a bit confusing on Windows. The file we want to upload to our browser lives on our Ubuntu instance, so how do we actually access it from Windows? In VSCode you can right click the image and select reveal in file explorer . This will open up a window showing the folder that contains the file. At the top of the window is a path to the file: Once you click the path it will turn into a text field that you can copy and paste: Copy that path and then select the browse button in the admin interface. You can now paste the image page in the upload window that pops up: Hit the save button and you're done. All that's left is to head back over to localhost:8002 and play the game.","title":"Adding a game"},{"location":"internship/onboarding/varcade_games/adding_a_game/#adding-a-game-to-varcade-games","text":"Navigate your browser to localhost:8000/admin . You should be greeted by a login page. Use the credentials that you provided in the early step where you ran ./manage.py createsuperuser . Once logged in you should see a menu that looks like this: Click the add link under the GAMES category. Fill in all of the fields with dummy data, for example: Game id: test_game Name: My Game Desc: A great game that you should play! Client url: empty Cover art: See below Game type: SinglePlayerOnly Game State: Coming Soon","title":"Adding a game to Varcade Games"},{"location":"internship/onboarding/varcade_games/adding_a_game/#adding-cover-art","text":"There is some sample cover art in the rps_game project. In VSCode you will find this file in game_rps/client/assets/exrps_cover.jpg .","title":"Adding Cover Art"},{"location":"internship/onboarding/varcade_games/adding_a_game/#on-windows","text":"This might be a bit confusing on Windows. The file we want to upload to our browser lives on our Ubuntu instance, so how do we actually access it from Windows? In VSCode you can right click the image and select reveal in file explorer . This will open up a window showing the folder that contains the file. At the top of the window is a path to the file: Once you click the path it will turn into a text field that you can copy and paste: Copy that path and then select the browse button in the admin interface. You can now paste the image page in the upload window that pops up: Hit the save button and you're done. All that's left is to head back over to localhost:8002 and play the game.","title":"On Windows"},{"location":"internship/onboarding/varcade_games/admin/","text":"The Admin Panel In order to follow along with this section you'll need to have the project up and running - so if you haven't done that, you should get it all setup before continuing. The admin panel is a part of the Website project. In you browser, navigate to localhost:8000/admin/ . If you're not already logged in here you will be greeted with a login screen. Log in with the credentials you provided when initially setting up the project and you should be greeted with something like this: You get this out of the box with Django, and it's one of the reasons I decided to go with Django for the server side of Varcade Games. Django Admin Some of these menu options are there by default, such as ACCOUNTS and SITES , but two of them are specific to Varcade Games. Games This section is where we add games, as you should have done already while setting up the project. Profiles In this section we can view user profiles, which are automatically created whenever a new account is created - more on this later. Basically as admin of the website you can view and manipulate player accounts as needed - and since the internet is what it is, it will be needed. The Code Let's have a look at the code behind all of this, because we've already used the admin panel enough to more or less know what it's about. Games If you open up website/server/game_portal/games/admin.py you should see the following code: 1 2 3 4 from django.contrib import admin from .models import Game admin . site . register ( Game ) And that's it. That's more or less all we need to do in order to add a custom section to the Django admin panel. But before you do that you need to create the model that you want to represent in the first place. All you can see from the imports above, this Game model is in the models.py file. The Game model is a database model that describes a single game in Varcade Games and it looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Game ( models . Model ): class GameTypes ( models . TextChoices ): SINGLE_PLAYER_ONLY = \"SPO\" , \"SinglePlayerOnly\" MULTI_PLAYER_ONLY = \"MPO\" , \"MultiPlayerOnly\" MULTI_AND_SINGLE_PLAYER = \"MSP\" , \"MultiAndSinglePlayer\" class GameState ( models . TextChoices ): ACTIVE = \"ACT\" , \"Active\" INACTIVE = \"INA\" , \"Inactive\" COMING_SOON = \"CMS\" , \"ComingSoon\" game_id : models . CharField = models . CharField ( max_length = 10 ) name : models . CharField = models . CharField ( max_length = 40 ) desc : models . CharField = models . CharField ( max_length = 180 ) client_url : models . CharField = models . CharField ( max_length = 160 ) cover_art : models . ImageField = models . ImageField ( upload_to = \"images\" , null = True ) banner_art : models . ImageField = models . ImageField ( upload_to = \"images\" , null = True ) stats_config : models . FileField = models . FileField ( upload_to = \"stats_config\" , null = True ) game_type : models . CharField = models . CharField ( max_length = 3 , choices = GameTypes . choices , default = GameTypes . SINGLE_PLAYER_ONLY ) game_state : models . CharField = models . CharField ( max_length = 3 , choices = GameState . choices , default = GameState . INACTIVE ) def __str__ ( self ) -> str : return self . name Have a look at all of those instance variables in the Game class: 1 2 3 4 5 game_id name desc client_url ... Are they familiar? They should be - take another look at the admin panel. Django automatically maps the fields of our database model to the admin panel, provided we have registered it - which we did in our admin.py file. For all of this to work our model needs to extend models.Model : 1 class Game ( models . Model ): This tells Django that our Game object will be a database model. Each of the instance variables is a Django specific type that Django knows how to handle. The type of the model's fields also dictates how they are rendered in the admin panel. The models.ImageField is rendered as an upload field in UI. The models.Charfield that have choices associated with them are rendered as dropdowns etc... Most of these fields are pretty straight forward. CharFields are just strings that Django can store in a database table. But the same is not true for the ImageField or the FileField. We need to store these files somewhere. Django will only store the path of that file in the database. To understands how this works we need to have a look at the settings file. The Setting File The settings.py is the core of our Django project. Remember back to the intro for this section, where I shared the following snippet from the Django homepage: Django is a high-level Python web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of web development, so you can focus on writing your app... It is through the setting.py that we will harness the power of Django. It's the interface through which we configure Django so that it can do the heavy lifting. Go ahead and open up website/server/game_portal/game_portal/setting.py . The section we're interested in right now is: 1 2 3 4 5 6 7 8 9 if DEBUG : CORS_ALLOW_ALL_ORIGINS = True STATIC_ROOT = os . path . join ( BASE_DIR , \"staticfiles\" ) MEDIA_ROOT = os . path . join ( BASE_DIR , \"media/\" ) else : CORS_ALLOWED_ORIGINS = [ \"https://varcade-games.com\" ] STATIC_ROOT = \"/var/lib/game_portal/data/staticfiles\" MEDIA_ROOT = \"/var/lib/game_portal/data/media/\" MEDIA_URL = \"https://api.varcade-games.com/media/\" More specifically we are interested in the MEDIA_ROOT and MEDIA_URL . The MEDIA_ROOT setting tells Django where it can store files locally. So any files we upload via the admin webpanel will go here. The MEDIA_URL setting tells Django where to request these files from. So why do we have this DEBUG condition and two different values for these settings? As the name implies, one is our debug config - which is active whenever we're running on our local dev server. However, when the website is deployed to a live server we need to tweak things a bit - but don't worry about this for now, we'll get to that later. For now - files will be saved to your game-portal container in the BASE_DIR - which correspond to website/server/game_portal directory. In fact - have a look in your file explorer right now. If you are running Varcade Games at the moment and have your local file system mounted on to the running Varcade Games container then you should see that media directory - and it should contain the files you uploaded when configuring Rock Paper Scissors Apocalypse . Summary So that's how we configure and store games. We create a class that is an instance of the Django model. We register that class with the Django admin system. We tell Django where we want static files to go (uploaded images etc...). Once all of that is done we can view our class in the admin panel and create/delete/modify data models as needed via that interface. Now that we have a game defined - how does it actually end up embedded in Varcade Games? That's what we will explore next.","title":"The Admin panel"},{"location":"internship/onboarding/varcade_games/admin/#the-admin-panel","text":"In order to follow along with this section you'll need to have the project up and running - so if you haven't done that, you should get it all setup before continuing. The admin panel is a part of the Website project. In you browser, navigate to localhost:8000/admin/ . If you're not already logged in here you will be greeted with a login screen. Log in with the credentials you provided when initially setting up the project and you should be greeted with something like this: You get this out of the box with Django, and it's one of the reasons I decided to go with Django for the server side of Varcade Games.","title":"The Admin Panel"},{"location":"internship/onboarding/varcade_games/admin/#django-admin","text":"Some of these menu options are there by default, such as ACCOUNTS and SITES , but two of them are specific to Varcade Games.","title":"Django Admin"},{"location":"internship/onboarding/varcade_games/admin/#games","text":"This section is where we add games, as you should have done already while setting up the project.","title":"Games"},{"location":"internship/onboarding/varcade_games/admin/#profiles","text":"In this section we can view user profiles, which are automatically created whenever a new account is created - more on this later. Basically as admin of the website you can view and manipulate player accounts as needed - and since the internet is what it is, it will be needed.","title":"Profiles"},{"location":"internship/onboarding/varcade_games/admin/#the-code","text":"Let's have a look at the code behind all of this, because we've already used the admin panel enough to more or less know what it's about.","title":"The Code"},{"location":"internship/onboarding/varcade_games/admin/#games_1","text":"If you open up website/server/game_portal/games/admin.py you should see the following code: 1 2 3 4 from django.contrib import admin from .models import Game admin . site . register ( Game ) And that's it. That's more or less all we need to do in order to add a custom section to the Django admin panel. But before you do that you need to create the model that you want to represent in the first place. All you can see from the imports above, this Game model is in the models.py file. The Game model is a database model that describes a single game in Varcade Games and it looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Game ( models . Model ): class GameTypes ( models . TextChoices ): SINGLE_PLAYER_ONLY = \"SPO\" , \"SinglePlayerOnly\" MULTI_PLAYER_ONLY = \"MPO\" , \"MultiPlayerOnly\" MULTI_AND_SINGLE_PLAYER = \"MSP\" , \"MultiAndSinglePlayer\" class GameState ( models . TextChoices ): ACTIVE = \"ACT\" , \"Active\" INACTIVE = \"INA\" , \"Inactive\" COMING_SOON = \"CMS\" , \"ComingSoon\" game_id : models . CharField = models . CharField ( max_length = 10 ) name : models . CharField = models . CharField ( max_length = 40 ) desc : models . CharField = models . CharField ( max_length = 180 ) client_url : models . CharField = models . CharField ( max_length = 160 ) cover_art : models . ImageField = models . ImageField ( upload_to = \"images\" , null = True ) banner_art : models . ImageField = models . ImageField ( upload_to = \"images\" , null = True ) stats_config : models . FileField = models . FileField ( upload_to = \"stats_config\" , null = True ) game_type : models . CharField = models . CharField ( max_length = 3 , choices = GameTypes . choices , default = GameTypes . SINGLE_PLAYER_ONLY ) game_state : models . CharField = models . CharField ( max_length = 3 , choices = GameState . choices , default = GameState . INACTIVE ) def __str__ ( self ) -> str : return self . name Have a look at all of those instance variables in the Game class: 1 2 3 4 5 game_id name desc client_url ... Are they familiar? They should be - take another look at the admin panel. Django automatically maps the fields of our database model to the admin panel, provided we have registered it - which we did in our admin.py file. For all of this to work our model needs to extend models.Model : 1 class Game ( models . Model ): This tells Django that our Game object will be a database model. Each of the instance variables is a Django specific type that Django knows how to handle. The type of the model's fields also dictates how they are rendered in the admin panel. The models.ImageField is rendered as an upload field in UI. The models.Charfield that have choices associated with them are rendered as dropdowns etc... Most of these fields are pretty straight forward. CharFields are just strings that Django can store in a database table. But the same is not true for the ImageField or the FileField. We need to store these files somewhere. Django will only store the path of that file in the database. To understands how this works we need to have a look at the settings file.","title":"Games"},{"location":"internship/onboarding/varcade_games/admin/#the-setting-file","text":"The settings.py is the core of our Django project. Remember back to the intro for this section, where I shared the following snippet from the Django homepage: Django is a high-level Python web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of web development, so you can focus on writing your app... It is through the setting.py that we will harness the power of Django. It's the interface through which we configure Django so that it can do the heavy lifting. Go ahead and open up website/server/game_portal/game_portal/setting.py . The section we're interested in right now is: 1 2 3 4 5 6 7 8 9 if DEBUG : CORS_ALLOW_ALL_ORIGINS = True STATIC_ROOT = os . path . join ( BASE_DIR , \"staticfiles\" ) MEDIA_ROOT = os . path . join ( BASE_DIR , \"media/\" ) else : CORS_ALLOWED_ORIGINS = [ \"https://varcade-games.com\" ] STATIC_ROOT = \"/var/lib/game_portal/data/staticfiles\" MEDIA_ROOT = \"/var/lib/game_portal/data/media/\" MEDIA_URL = \"https://api.varcade-games.com/media/\" More specifically we are interested in the MEDIA_ROOT and MEDIA_URL . The MEDIA_ROOT setting tells Django where it can store files locally. So any files we upload via the admin webpanel will go here. The MEDIA_URL setting tells Django where to request these files from. So why do we have this DEBUG condition and two different values for these settings? As the name implies, one is our debug config - which is active whenever we're running on our local dev server. However, when the website is deployed to a live server we need to tweak things a bit - but don't worry about this for now, we'll get to that later. For now - files will be saved to your game-portal container in the BASE_DIR - which correspond to website/server/game_portal directory. In fact - have a look in your file explorer right now. If you are running Varcade Games at the moment and have your local file system mounted on to the running Varcade Games container then you should see that media directory - and it should contain the files you uploaded when configuring Rock Paper Scissors Apocalypse .","title":"The Setting File"},{"location":"internship/onboarding/varcade_games/admin/#summary","text":"So that's how we configure and store games. We create a class that is an instance of the Django model. We register that class with the Django admin system. We tell Django where we want static files to go (uploaded images etc...). Once all of that is done we can view our class in the admin panel and create/delete/modify data models as needed via that interface. Now that we have a game defined - how does it actually end up embedded in Varcade Games? That's what we will explore next.","title":"Summary"},{"location":"internship/onboarding/varcade_games/embedding_games/","text":"Embedding Games Before we dig into the details of how games are loaded via the web UI, let's have a look at the process from a high level. Take a second to digest that image. We have multiple servers in play: Game Portal Used to configure games via admin panel API to serve active games to players File Server This is where players download the actual game from. Taking this step by step, the following is happening: Using a browser, we configure a game through the Admin Panel We run the Varcade Games client (our Vue.js project) in the browser We did this by navigating to localhost:8002 The Varcade Games client fetches the game data from the Game Portal The Varcade Games client uses that game data to download the game client from a file server The URL we added to the game we configured in the Admin Panel is this file server The Varcade Games client runs the game The game is a single javascript file, which we will look at in more detail later The Games API If you've already been exploring the networking section of the browser dev tools then you may have already seen this request: 1 Request URL: http://api.varcade.local:8000/games/v1/games/ This is step 3 from the list above. The response to this request looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"count\" : 1 , \"next\" : null , \"previous\" : null , \"results\" :[ { \"game_id\" : \"exrps\" , \"name\" : \"Rock Paper Scissors Apocalypse\" , \"desc\" : \"An fun but intense fighting game based on rock paper scissors. Single player and multi player modes available.\" , \"client_url\" : \"http://localhost:8090/main.js\" , \"cover_art\" : \"http://api.varcade.local:8000/media/images/exrps_cover_Wsyt72t.jpg\" , \"banner_art\" : \"http://api.varcade.local:8000/media/images/exrps_banner.jpg\" , \"stats_config\" : \"http://api.varcade.local:8000/media/stats_config/exrps_stats.json\" , \"game_state\" : \"ACT\" } ] } A couple of things should look familiar here. First off - all of that information is exactly what we put into the Admin Panel when we configured the game. It is all of the information needed by the Varcade Games client to display a game. Secondly, there are a couple of URLs in there. http://api.varcade.local:8000/media/images/exrps_cover_Wsyt72t.jpg http://api.varcade.local:8000/media/images/exrps_banner.jpg http://api.varcade.local:8000/media/stats_config/exrps_stats.json Remember the Django settings file from the previous section on the Admin Panel? This is our MEDIA_ROOT . Once we have all of the data we need from the Games API we can go ahead that display a game to the user. Loading games in the client Open up website/client/src/views/GamePlay.vue . This is the game page - where you will have played Rock Paper Scissors Apocalypse. Looking at the HTML, there are three main components on this page: 1 2 3 4 5 < wp-active-game :selected-game = \"selectedGame\" /> ... < wp-player-stats :selected-game = \"selectedGame\" /> ... < wp-game-leaderboard :game-id = \"gameId\" /> These are custom Vue components. We have one that presents our game, one that presents the player statistics for the game and another that presents the leaderboard for that game. Let's have a look at wp-active-game , it's at: website/client/src/components/wp-active-game.vue . If you scroll down to the code section of the file you will find this function (slightly modified for brevity): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 loadGameData : function () { if ( this . gameScriptLoaded ()) { console . log ( 'Will not load game - it appears to be loaded already' ) } else { let gameScript = document . createElement ( 'script' ); gameScript . setAttribute ( 'src' , this . selectedGame . client_url ); gameScript . setAttribute ( 'type' , 'text/javascript' ); gameScript . setAttribute ( 'id' , `_game_instance_ ${ this . gameId } ` ) document . body . appendChild ( gameScript ); this . loadingInterval = setInterval (() => { console . log ( \"Game loading...\" ); const gameContainerElement = document . getElementById ( 'gameContainer' ) this . gameLoaded = gameContainerElement != null && gameContainerElement . firstChild != null if ( this . gameLoaded ) { clearInterval ( this . loadingInterval ); console . log ( \"Game loaded.\" ); } }, 500 ); } } This is where we load the game. All we're doing is using javascript to add a new tag to the HTML page. This new tag is a script tag, and in that script tag we specify the URL of the game client. There is also some code that runs every 500 milliseconds to check if the initial loading of the game is complete, so that it can update the UI. And that's it for how the game is loaded - until of course we dig into how the game actually works. Before that - there is another hook we should take a look at. The Matchmaker.","title":"Embedding games"},{"location":"internship/onboarding/varcade_games/embedding_games/#embedding-games","text":"Before we dig into the details of how games are loaded via the web UI, let's have a look at the process from a high level. Take a second to digest that image. We have multiple servers in play: Game Portal Used to configure games via admin panel API to serve active games to players File Server This is where players download the actual game from. Taking this step by step, the following is happening: Using a browser, we configure a game through the Admin Panel We run the Varcade Games client (our Vue.js project) in the browser We did this by navigating to localhost:8002 The Varcade Games client fetches the game data from the Game Portal The Varcade Games client uses that game data to download the game client from a file server The URL we added to the game we configured in the Admin Panel is this file server The Varcade Games client runs the game The game is a single javascript file, which we will look at in more detail later","title":"Embedding Games"},{"location":"internship/onboarding/varcade_games/embedding_games/#the-games-api","text":"If you've already been exploring the networking section of the browser dev tools then you may have already seen this request: 1 Request URL: http://api.varcade.local:8000/games/v1/games/ This is step 3 from the list above. The response to this request looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"count\" : 1 , \"next\" : null , \"previous\" : null , \"results\" :[ { \"game_id\" : \"exrps\" , \"name\" : \"Rock Paper Scissors Apocalypse\" , \"desc\" : \"An fun but intense fighting game based on rock paper scissors. Single player and multi player modes available.\" , \"client_url\" : \"http://localhost:8090/main.js\" , \"cover_art\" : \"http://api.varcade.local:8000/media/images/exrps_cover_Wsyt72t.jpg\" , \"banner_art\" : \"http://api.varcade.local:8000/media/images/exrps_banner.jpg\" , \"stats_config\" : \"http://api.varcade.local:8000/media/stats_config/exrps_stats.json\" , \"game_state\" : \"ACT\" } ] } A couple of things should look familiar here. First off - all of that information is exactly what we put into the Admin Panel when we configured the game. It is all of the information needed by the Varcade Games client to display a game. Secondly, there are a couple of URLs in there. http://api.varcade.local:8000/media/images/exrps_cover_Wsyt72t.jpg http://api.varcade.local:8000/media/images/exrps_banner.jpg http://api.varcade.local:8000/media/stats_config/exrps_stats.json Remember the Django settings file from the previous section on the Admin Panel? This is our MEDIA_ROOT . Once we have all of the data we need from the Games API we can go ahead that display a game to the user.","title":"The Games API"},{"location":"internship/onboarding/varcade_games/embedding_games/#loading-games-in-the-client","text":"Open up website/client/src/views/GamePlay.vue . This is the game page - where you will have played Rock Paper Scissors Apocalypse. Looking at the HTML, there are three main components on this page: 1 2 3 4 5 < wp-active-game :selected-game = \"selectedGame\" /> ... < wp-player-stats :selected-game = \"selectedGame\" /> ... < wp-game-leaderboard :game-id = \"gameId\" /> These are custom Vue components. We have one that presents our game, one that presents the player statistics for the game and another that presents the leaderboard for that game. Let's have a look at wp-active-game , it's at: website/client/src/components/wp-active-game.vue . If you scroll down to the code section of the file you will find this function (slightly modified for brevity): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 loadGameData : function () { if ( this . gameScriptLoaded ()) { console . log ( 'Will not load game - it appears to be loaded already' ) } else { let gameScript = document . createElement ( 'script' ); gameScript . setAttribute ( 'src' , this . selectedGame . client_url ); gameScript . setAttribute ( 'type' , 'text/javascript' ); gameScript . setAttribute ( 'id' , `_game_instance_ ${ this . gameId } ` ) document . body . appendChild ( gameScript ); this . loadingInterval = setInterval (() => { console . log ( \"Game loading...\" ); const gameContainerElement = document . getElementById ( 'gameContainer' ) this . gameLoaded = gameContainerElement != null && gameContainerElement . firstChild != null if ( this . gameLoaded ) { clearInterval ( this . loadingInterval ); console . log ( \"Game loaded.\" ); } }, 500 ); } } This is where we load the game. All we're doing is using javascript to add a new tag to the HTML page. This new tag is a script tag, and in that script tag we specify the URL of the game client. There is also some code that runs every 500 milliseconds to check if the initial loading of the game is complete, so that it can update the UI. And that's it for how the game is loaded - until of course we dig into how the game actually works. Before that - there is another hook we should take a look at. The Matchmaker.","title":"Loading games in the client"},{"location":"internship/onboarding/varcade_games/get_the_code/","text":"Running The Project First things first, we need to get our hands on the code. SSH Keys We will create some SSH keys so that we can pull code securely from Github. From the home directory of your Ubuntu terminal (you can get there by typing cd ~/ in the Ubuntu terminal and hitting return), run the following command to create some SSH keys (replacing the email address here with your own): 1 ssh-keygen -t ed25519 -C john.doe@foo.com You will then be prompted to to select a directory and a passphrase. You can just hit return twice to accept the defaults. The output from this process should look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u2718 kev \ue0b0 ~ \ue0b0 ssh-keygen -t ed25519 -C john.doe@foo.com Generating public/private ed25519 key pair. Enter file in which to save the key (/home/kev/.ssh/id_ed25519): Created directory '/home/kev/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/kev/.ssh/id_ed25519 Your public key has been saved in /home/kev/.ssh/id_ed25519.pub The key fingerprint is: <REDACTED> john.doe@foo.com The key's randomart image is: +--[ED25519 256]--+ | o.o+O@#| << snipped >> | | +----[SHA256]-----+ Next we need to attach the pubic SSH key that we just generated to our Github account. Run the following command in your Ubuntu terminal: 1 cat ~/.ssh/id_ed25519.pub The output of the command will look something like: 1 ssh-ed25519 AAAAC3NzaC1lZLI1TTE5AAAAIK0wmN/Cr3JXqmLW7u+g9pTh+wyqDHpSQEISczXkBx9q john.doe@foo.com Copy that line, we will use it in the next step. Open your github account and go to Your Profile (Icon at the top right of the screen) > Settings > SSH and GPG keys. Click the New SSH Key button. Give your SSH key a name that helps you understand what machine this key belongs to and then paste in the output from the previous command (your ssh key output). Downloading the code Now we can get the code. Head back over to your Ubuntu terminal and create a new directory for your code: 1 2 3 cd ~/ mkdir code cd code The clone all of the required repos using the following commands: 1 2 3 4 5 git clone git@github.com:theblacknight/build_tools.git git clone git@github.com:theblacknight/website.git git clone git@github.com:theblacknight/matchmaker.git git clone git@github.com:theblacknight/stats_tracker.git git clone git@github.com:theblacknight/game_rps.git If you entered a passphrase for your SSH key you will need to enter it now. The output will look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 kev \ue0b0 ~/code \ue0b0 git clone git@github.com:theblacknight/build_tools.git Cloning into 'build_tools'... The authenticity of host 'github.com (140.82.121.4)' can't be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added 'github.com,140.82.121.4' (RSA) to the list of known hosts. Enter passphrase for key '/home/kev/.ssh/id_ed25519': remote: Enumerating objects: 356, done. remote: Counting objects: 100% (356/356), done. remote: Compressing objects: 100% (178/178), done. remote: Total 356 (delta 247), reused 268 (delta 161), pack-reused 0 Receiving objects: 100% (356/356), 62.04 KiB | 577.00 KiB/s, done. Resolving deltas: 100% (247/247), done. Working with the code !! Windows Specific Once all of the projects are cloned you can do something pretty cool. Run the following command: 1 code . This is a special program in the Windows Ubuntu distro that will open up VSCode on your local machine, but connect it to the Ubuntu instance so that you can modify the code that we just cloned directly from Windows! Feel free to explore the code for a while before proceeding. There are detailed README files in each project folder and in all first level sub-folders that should help you understand what each of the different pieces is doing.","title":"Running The Project"},{"location":"internship/onboarding/varcade_games/get_the_code/#running-the-project","text":"First things first, we need to get our hands on the code.","title":"Running The Project"},{"location":"internship/onboarding/varcade_games/get_the_code/#ssh-keys","text":"We will create some SSH keys so that we can pull code securely from Github. From the home directory of your Ubuntu terminal (you can get there by typing cd ~/ in the Ubuntu terminal and hitting return), run the following command to create some SSH keys (replacing the email address here with your own): 1 ssh-keygen -t ed25519 -C john.doe@foo.com You will then be prompted to to select a directory and a passphrase. You can just hit return twice to accept the defaults. The output from this process should look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u2718 kev \ue0b0 ~ \ue0b0 ssh-keygen -t ed25519 -C john.doe@foo.com Generating public/private ed25519 key pair. Enter file in which to save the key (/home/kev/.ssh/id_ed25519): Created directory '/home/kev/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/kev/.ssh/id_ed25519 Your public key has been saved in /home/kev/.ssh/id_ed25519.pub The key fingerprint is: <REDACTED> john.doe@foo.com The key's randomart image is: +--[ED25519 256]--+ | o.o+O@#| << snipped >> | | +----[SHA256]-----+ Next we need to attach the pubic SSH key that we just generated to our Github account. Run the following command in your Ubuntu terminal: 1 cat ~/.ssh/id_ed25519.pub The output of the command will look something like: 1 ssh-ed25519 AAAAC3NzaC1lZLI1TTE5AAAAIK0wmN/Cr3JXqmLW7u+g9pTh+wyqDHpSQEISczXkBx9q john.doe@foo.com Copy that line, we will use it in the next step. Open your github account and go to Your Profile (Icon at the top right of the screen) > Settings > SSH and GPG keys. Click the New SSH Key button. Give your SSH key a name that helps you understand what machine this key belongs to and then paste in the output from the previous command (your ssh key output).","title":"SSH Keys"},{"location":"internship/onboarding/varcade_games/get_the_code/#downloading-the-code","text":"Now we can get the code. Head back over to your Ubuntu terminal and create a new directory for your code: 1 2 3 cd ~/ mkdir code cd code The clone all of the required repos using the following commands: 1 2 3 4 5 git clone git@github.com:theblacknight/build_tools.git git clone git@github.com:theblacknight/website.git git clone git@github.com:theblacknight/matchmaker.git git clone git@github.com:theblacknight/stats_tracker.git git clone git@github.com:theblacknight/game_rps.git If you entered a passphrase for your SSH key you will need to enter it now. The output will look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 kev \ue0b0 ~/code \ue0b0 git clone git@github.com:theblacknight/build_tools.git Cloning into 'build_tools'... The authenticity of host 'github.com (140.82.121.4)' can't be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added 'github.com,140.82.121.4' (RSA) to the list of known hosts. Enter passphrase for key '/home/kev/.ssh/id_ed25519': remote: Enumerating objects: 356, done. remote: Counting objects: 100% (356/356), done. remote: Compressing objects: 100% (178/178), done. remote: Total 356 (delta 247), reused 268 (delta 161), pack-reused 0 Receiving objects: 100% (356/356), 62.04 KiB | 577.00 KiB/s, done. Resolving deltas: 100% (247/247), done.","title":"Downloading the code"},{"location":"internship/onboarding/varcade_games/get_the_code/#working-with-the-code","text":"","title":"Working with the code"},{"location":"internship/onboarding/varcade_games/get_the_code/#windows-specific","text":"Once all of the projects are cloned you can do something pretty cool. Run the following command: 1 code . This is a special program in the Windows Ubuntu distro that will open up VSCode on your local machine, but connect it to the Ubuntu instance so that you can modify the code that we just cloned directly from Windows! Feel free to explore the code for a while before proceeding. There are detailed README files in each project folder and in all first level sub-folders that should help you understand what each of the different pieces is doing.","title":"!! Windows Specific"},{"location":"internship/onboarding/varcade_games/intro_client/","text":"Introduction At this point you should be pretty familiar with Varcade games from a user perspective. Now it's time to start looking beneath the surface to understand how is all actually works. In this section we will go through the architecture of the system, try and understand what is happening from the perspective of the browser, make some code changes and run some tests. Up until now we've been getting things set up but from here on out... we're engineering. Notes From this point on you will have to start exploring and finding your own way around. As I've said before, this is the most effective path for learning, so keep the following in mind: Be curious - ask questions, think about what you're seeing/experiencing and why it does/doesn't make sense Don't be afraid to get lost in the code Don't be afraid to make changes break things Don't worry if you don't understand something (there will be plenty you won't understand, that's why we're here - to learn) You can do this - but like everything worthwhile, it's going to take time and effort","title":"Introduction"},{"location":"internship/onboarding/varcade_games/intro_client/#introduction","text":"At this point you should be pretty familiar with Varcade games from a user perspective. Now it's time to start looking beneath the surface to understand how is all actually works. In this section we will go through the architecture of the system, try and understand what is happening from the perspective of the browser, make some code changes and run some tests. Up until now we've been getting things set up but from here on out... we're engineering.","title":"Introduction"},{"location":"internship/onboarding/varcade_games/intro_client/#notes","text":"From this point on you will have to start exploring and finding your own way around. As I've said before, this is the most effective path for learning, so keep the following in mind: Be curious - ask questions, think about what you're seeing/experiencing and why it does/doesn't make sense Don't be afraid to get lost in the code Don't be afraid to make changes break things Don't worry if you don't understand something (there will be plenty you won't understand, that's why we're here - to learn) You can do this - but like everything worthwhile, it's going to take time and effort","title":"Notes"},{"location":"internship/onboarding/varcade_games/intro_server/","text":"Introduction Varcade Games is pluggable . This means we can dynamically add games via the web application's admin panel. This section will cover the behind the scenes for this functionality. The server side of Varcade Games is built using Django . From the Django homepage: Django is a high-level Python web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of web development, so you can focus on writing your app without needing to reinvent the wheel. It\u2019s free and open source. Or more succinctly: The web framework for perfectionists with deadlines. This project leverages the built in Django admin system as well as some Javascript to dynamically add and remove games to and from the system - no code changes or deployments required! First lets take a look at the admin panel...","title":"Introduction"},{"location":"internship/onboarding/varcade_games/intro_server/#introduction","text":"Varcade Games is pluggable . This means we can dynamically add games via the web application's admin panel. This section will cover the behind the scenes for this functionality. The server side of Varcade Games is built using Django . From the Django homepage: Django is a high-level Python web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of web development, so you can focus on writing your app without needing to reinvent the wheel. It\u2019s free and open source. Or more succinctly: The web framework for perfectionists with deadlines. This project leverages the built in Django admin system as well as some Javascript to dynamically add and remove games to and from the system - no code changes or deployments required! First lets take a look at the admin panel...","title":"Introduction"},{"location":"internship/onboarding/varcade_games/making_changes/","text":"Making Changes Ok, finally it's time to actually get our hands dirty and change some code. To start we're going to work on the website project, also know as the Game Portal . Prerequisites The following must be true before continuing here: Your local Varcade games dev server is up and running You can access the web portal through http://localhost:8002 You can create and account and log in to your local dev server Changing the client The first thing we will do is get a view of our logs so that we can see what happens when we make some changes. In your terminal, navigate to the build_tools project and run the following command: 1 make logs a = game-portal-client This should result in your terminal filling up with a bunch of information that should look something like: 1 2 3 4 5 6 7 8 9 10 game-portal-client | <s> [ webpack.Progress ] 95 % emitting game-portal-client | <s> [ webpack.Progress ] 95 % emitting HtmlWebpackPlugin game-portal-client | <s> [ webpack.Progress ] 95 % emitting CopyPlugin game-portal-client | <s> [ webpack.Progress ] 98 % after emitting game-portal-client | <s> [ webpack.Progress ] 98 % after emitting CopyPlugin game-portal-client | DONE Compiled successfully in 213ms7:42:57 AM game-portal-client | <s> [ webpack.Progress ] 100 % game-portal-client | App running at: game-portal-client | - Local: http://localhost:8002/ game-portal-client | - Network: http://varcade.local/ Don't worry if yours doesn't look identical - the output here will depend on a number of factors. Next hit enter a few times in that same terminal window. This will add a few blank lines to the bottom of the output, which creates a sort of separator between the latest log output and future log output. This is a useful trick for when you want to view a chunk of logs starting at a point in time. Note : This little trick doesn't actually change the logs or anything, just adds some blank lines to your terminal. If you run the log command again in another window the blank lines will not be there. Removing the header The first change we're going to make is to remove the header from the login/registration page. We have a lovely big picture on that page and we'd like to see what it looks like without a chunk at the top being blocked by the header. In your browser open up http://localhost:8002 . If you are already logged in, click the logout button at the top right corner of the screen. Next, open up the code in what ever editor/IDE you are using and open the following file: 1 website/client/src/views/Index.vue This is the file that contains our core Vue components that allow users to register and log in. At the top of the file you will see the following: 1 2 3 4 5 6 7 8 < template > < div class = \"index-screen-image\" > < wp-top-bar v-bind:display-logout-option = \"false\" /> < div class = \"login-box-container\" > < wp-login-register /> </ div > </ div > </ template > Modify line 3 so that it looks like this: 1 <!--<wp-top-bar v-bind:display-logout-option=\"false\"/>--> What this does is 'comment out' that line of HTML. It means that the browser will ignore this line - which in turn will stop our header from being rendered. Once you've made this change, save the file and then head back over to your browser. The change should be immediately apparent - you don't even need to refresh the page! What sorcery is this? How is that even possible? This sorcery is called 'hot reloading' (see official docs ) and to see it in action let's head back over to our terminal! In the terminal window you should see something like this: 1 2 3 4 5 6 7 8 9 10 11 12 game-portal-client | <s> [ webpack.Progress ] 94 % after asset optimization game-portal-client | <s> [ webpack.Progress ] 94 % after seal game-portal-client | <s> [ webpack.Progress ] 95 % emitting game-portal-client | <s> [ webpack.Progress ] 95 % emitting HtmlWebpackPlugin game-portal-client | <s> [ webpack.Progress ] 95 % emitting CopyPlugin game-portal-client | <s> [ webpack.Progress ] 98 % after emitting game-portal-client | <s> [ webpack.Progress ] 98 % after emitting CopyPlugin game-portal-client | DONE Compiled successfully in 168ms7:44:20 AM game-portal-client | <s> [ webpack.Progress ] 100 % game-portal-client | App running at: game-portal-client | - Local: http://localhost:8002/ game-portal-client | - Network: http://varcade.local/ Your output should look exactly the same as mine. If you scroll up you will notice that what you're looking at here is essentially a progress bar. Scroll enough and you will reach the point where we added our blank lines, and you should see the following: 1 2 3 game-portal-client | WAIT Compiling...7:44:19 AM game-portal-client | <s> [ webpack.Progress ] 0 % compiling game-portal-client | <s> [ webpack.Progress ] 10 % building 0 /0 modules 0 active So what actually happened here? When we run our Vue.js app in development mode it watches all of the files in the project to see if any of them change. As soon as one changes, Vue will rebuild itself and update any active pages in place! That's exactly what we just did - and the logs show Vue.js reacting to the change we made, by recompiling the project. Pretty cool right? This allows us to make changes to our web application and immediately see the change. When things go wrong The above example show what happens when we successfully make a change... but what happens when we break something (and we will... we'll break loads of things!)? Well, let's find out. Head back over to your editor and remove the --> at the end of the file we modified so that it looks like this: 1 <!--<wp-top-bar v-bind:display-logout-option=\"false\"/> Then hit save and head back over to your browser. Bit of a different story right? You should still be able to see the Varcade Games homepage, but there is an error message displayed over it: 1 2 3 4 5 6 7 8 9 Failed to compile . . / src / views / Index . vue Module Error ( from . / node_modules / eslint - loader / index . js ) : /game_portal_client/src/views/Index.vue 54 : 1 error Parsing error : eof - in - comment vue / no - parsing - error \u2716 1 problem ( 1 error , 0 warnings ) Whenever you break the game portal client you will see an error like this. If you take a log at your logs you will also see this same error. This is important because we sometimes get a more descriptive error in our logs, like we do in this case: 1 2 3 4 5 6 7 8 9 10 11 game-portal-client | ( Emitted value instead of an instance of Error ) game-portal-client | Errors compiling template: game-portal-client | tag <div> has no matching end tag. game-portal-client | 1 | game-portal-client | 2 | game-portal-client | | game-portal-client | <s> [ webpack.Progress ] 100 % game-portal-client | 3 | <div class = \"index-screen-image\" > game-portal-client | | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ game-portal-client | 4 | game-portal-client | @ ./src/views/Index.vue?vue & type = template & id = 23543608 & 1 :0-410 1 :0-410 This message tells us that <div class=\"index-screen-image\"> has no matching end tag, which makes sense because on that line after that line in our template we opened a comment but never closed it: 1 2 3 4 5 6 7 8 9 < template > < div class = \"index-screen-image\" > <!--<wp-top-bar v-bind:display-logout-option=\"false\"/> <div class=\"login-box-container\"> <wp-login-register/> </div> </div> </template> Remove the <!-- from the start of line 4 and save the file. This will leave our page back in it's original state. What's next You are now equipped to start working on the Varcade Games game portal client. Take some time to look around the various files in the project. Make some changes, see what happens. The client/src/components directory is especially important as this is where the various components that make up the website live. Next we will look at what to do after we make changes to the code.","title":"Making Changes"},{"location":"internship/onboarding/varcade_games/making_changes/#making-changes","text":"Ok, finally it's time to actually get our hands dirty and change some code. To start we're going to work on the website project, also know as the Game Portal .","title":"Making Changes"},{"location":"internship/onboarding/varcade_games/making_changes/#prerequisites","text":"The following must be true before continuing here: Your local Varcade games dev server is up and running You can access the web portal through http://localhost:8002 You can create and account and log in to your local dev server","title":"Prerequisites"},{"location":"internship/onboarding/varcade_games/making_changes/#changing-the-client","text":"The first thing we will do is get a view of our logs so that we can see what happens when we make some changes. In your terminal, navigate to the build_tools project and run the following command: 1 make logs a = game-portal-client This should result in your terminal filling up with a bunch of information that should look something like: 1 2 3 4 5 6 7 8 9 10 game-portal-client | <s> [ webpack.Progress ] 95 % emitting game-portal-client | <s> [ webpack.Progress ] 95 % emitting HtmlWebpackPlugin game-portal-client | <s> [ webpack.Progress ] 95 % emitting CopyPlugin game-portal-client | <s> [ webpack.Progress ] 98 % after emitting game-portal-client | <s> [ webpack.Progress ] 98 % after emitting CopyPlugin game-portal-client | DONE Compiled successfully in 213ms7:42:57 AM game-portal-client | <s> [ webpack.Progress ] 100 % game-portal-client | App running at: game-portal-client | - Local: http://localhost:8002/ game-portal-client | - Network: http://varcade.local/ Don't worry if yours doesn't look identical - the output here will depend on a number of factors. Next hit enter a few times in that same terminal window. This will add a few blank lines to the bottom of the output, which creates a sort of separator between the latest log output and future log output. This is a useful trick for when you want to view a chunk of logs starting at a point in time. Note : This little trick doesn't actually change the logs or anything, just adds some blank lines to your terminal. If you run the log command again in another window the blank lines will not be there.","title":"Changing the client"},{"location":"internship/onboarding/varcade_games/making_changes/#removing-the-header","text":"The first change we're going to make is to remove the header from the login/registration page. We have a lovely big picture on that page and we'd like to see what it looks like without a chunk at the top being blocked by the header. In your browser open up http://localhost:8002 . If you are already logged in, click the logout button at the top right corner of the screen. Next, open up the code in what ever editor/IDE you are using and open the following file: 1 website/client/src/views/Index.vue This is the file that contains our core Vue components that allow users to register and log in. At the top of the file you will see the following: 1 2 3 4 5 6 7 8 < template > < div class = \"index-screen-image\" > < wp-top-bar v-bind:display-logout-option = \"false\" /> < div class = \"login-box-container\" > < wp-login-register /> </ div > </ div > </ template > Modify line 3 so that it looks like this: 1 <!--<wp-top-bar v-bind:display-logout-option=\"false\"/>--> What this does is 'comment out' that line of HTML. It means that the browser will ignore this line - which in turn will stop our header from being rendered. Once you've made this change, save the file and then head back over to your browser. The change should be immediately apparent - you don't even need to refresh the page! What sorcery is this? How is that even possible? This sorcery is called 'hot reloading' (see official docs ) and to see it in action let's head back over to our terminal! In the terminal window you should see something like this: 1 2 3 4 5 6 7 8 9 10 11 12 game-portal-client | <s> [ webpack.Progress ] 94 % after asset optimization game-portal-client | <s> [ webpack.Progress ] 94 % after seal game-portal-client | <s> [ webpack.Progress ] 95 % emitting game-portal-client | <s> [ webpack.Progress ] 95 % emitting HtmlWebpackPlugin game-portal-client | <s> [ webpack.Progress ] 95 % emitting CopyPlugin game-portal-client | <s> [ webpack.Progress ] 98 % after emitting game-portal-client | <s> [ webpack.Progress ] 98 % after emitting CopyPlugin game-portal-client | DONE Compiled successfully in 168ms7:44:20 AM game-portal-client | <s> [ webpack.Progress ] 100 % game-portal-client | App running at: game-portal-client | - Local: http://localhost:8002/ game-portal-client | - Network: http://varcade.local/ Your output should look exactly the same as mine. If you scroll up you will notice that what you're looking at here is essentially a progress bar. Scroll enough and you will reach the point where we added our blank lines, and you should see the following: 1 2 3 game-portal-client | WAIT Compiling...7:44:19 AM game-portal-client | <s> [ webpack.Progress ] 0 % compiling game-portal-client | <s> [ webpack.Progress ] 10 % building 0 /0 modules 0 active So what actually happened here? When we run our Vue.js app in development mode it watches all of the files in the project to see if any of them change. As soon as one changes, Vue will rebuild itself and update any active pages in place! That's exactly what we just did - and the logs show Vue.js reacting to the change we made, by recompiling the project. Pretty cool right? This allows us to make changes to our web application and immediately see the change.","title":"Removing the header"},{"location":"internship/onboarding/varcade_games/making_changes/#when-things-go-wrong","text":"The above example show what happens when we successfully make a change... but what happens when we break something (and we will... we'll break loads of things!)? Well, let's find out. Head back over to your editor and remove the --> at the end of the file we modified so that it looks like this: 1 <!--<wp-top-bar v-bind:display-logout-option=\"false\"/> Then hit save and head back over to your browser. Bit of a different story right? You should still be able to see the Varcade Games homepage, but there is an error message displayed over it: 1 2 3 4 5 6 7 8 9 Failed to compile . . / src / views / Index . vue Module Error ( from . / node_modules / eslint - loader / index . js ) : /game_portal_client/src/views/Index.vue 54 : 1 error Parsing error : eof - in - comment vue / no - parsing - error \u2716 1 problem ( 1 error , 0 warnings ) Whenever you break the game portal client you will see an error like this. If you take a log at your logs you will also see this same error. This is important because we sometimes get a more descriptive error in our logs, like we do in this case: 1 2 3 4 5 6 7 8 9 10 11 game-portal-client | ( Emitted value instead of an instance of Error ) game-portal-client | Errors compiling template: game-portal-client | tag <div> has no matching end tag. game-portal-client | 1 | game-portal-client | 2 | game-portal-client | | game-portal-client | <s> [ webpack.Progress ] 100 % game-portal-client | 3 | <div class = \"index-screen-image\" > game-portal-client | | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ game-portal-client | 4 | game-portal-client | @ ./src/views/Index.vue?vue & type = template & id = 23543608 & 1 :0-410 1 :0-410 This message tells us that <div class=\"index-screen-image\"> has no matching end tag, which makes sense because on that line after that line in our template we opened a comment but never closed it: 1 2 3 4 5 6 7 8 9 < template > < div class = \"index-screen-image\" > <!--<wp-top-bar v-bind:display-logout-option=\"false\"/> <div class=\"login-box-container\"> <wp-login-register/> </div> </div> </template> Remove the <!-- from the start of line 4 and save the file. This will leave our page back in it's original state.","title":"When things go wrong"},{"location":"internship/onboarding/varcade_games/making_changes/#whats-next","text":"You are now equipped to start working on the Varcade Games game portal client. Take some time to look around the various files in the project. Make some changes, see what happens. The client/src/components directory is especially important as this is where the various components that make up the website live. Next we will look at what to do after we make changes to the code.","title":"What's next"},{"location":"internship/onboarding/varcade_games/matchmaker/","text":"The Matchmaker The Varcade Games client comes with some built-in functionality that allows players to create and join games online. Game developers can hook into this built in functionality to interact with our matchmaker server. So what we have is: A matchmaker SDK A matchmaker server The Varcade Games client provides the SDK and manages interactions with the Matchmaker so that game developers don't need to. The UI for creating and joining games will be consistent across all games in the portfolio. The Matchmaker SDK Open up website/client/src/components/wp-active-game.vue again. You may have already noticed there is a custom component in there for the matchmaker: 1 < wp-matchmaker :game-id = \"gameId\" /> If you open up that file, website/client/src/components/matchmaker.vue , you will see that it contains a modal : 1 2 3 4 5 6 < modal name = \"matchmaker-modal\" width = \"800\" height = \"600\" :scrollable = \"false\" :reset = \"true\" > ... A modal is a piece of UI that appears over our main UI. Hopefully you have seen this in action already. When you click Multi-player on the Rock Paper Scissors Apocalypse main menu a window pops up. That is a modal, and this is where it is defined. One function worth checking out at this point is the initMatchmaker method: 1 2 3 4 5 6 7 8 9 10 11 12 13 initMatchmaker : function () { if ( ! this . matchmaker && ! window . getMatchmaker ) { const matchmaker = new Matchmaker ( this . gameId , this . $store , () => { this . $modal . show ( 'matchmaker-modal' ); this . refreshGameList (); }); this . matchmaker = matchmaker ; window . getMatchmaker = function () { return matchmaker ; } } } This is how we expose the Matchmaker functionality to the game client. We create an instance of a Matchmaker object. We then attach a function called getMatchmaker to the global Javascript window object. The Matchmaker Object The above code initializes the Matchmaker object here: 1 2 3 4 new Matchmaker ( this . gameId , this . $store , () => { this . $modal . show ( 'matchmaker-modal' ); this . refreshGameList (); }); To understand a bit better what is going on here, let's look at the source. Open up website/client/src/matchmaker.js . This class is an interface to the Matchmaker server. It exposes all of the functionality of that server to the Varcade Games client, for example: Get a list of open games Create a new game Join an existing game The matchmaker also provides a hook for the actual game client to hook into the matchmaker. Remember earlier on when we attached our Matchmaker object to the window object? Game client can access that same window object. Any Javascript executing on the page can. So that the game client does is call window.getMatchmaker() , and if a player selects multi-player they can call matchmaker.showMatchmaker(callback) . The whole thing looks something like this: It's worth spending a minute going through this diagram. First off, you should notice that I've split the diagram in two with a red dotted line. It's important to not what exactly is within the scope of the Varcade Games Client and what is not. Within the client we have a matchmaker Vue file, which is responsible for the matchmaker UI, and we have a matchmaker object, which is a normal object that provides access to the matchmaker server and the matchmaker UI. But next to those two we have a window object and the actual game client (the graphics and gameplay etc...). The window is a global Javascript script object that represents a tab in your browser. So every time you open up a new webpage in your browser, that webpage has access to this global object. That means that any Javascript running on that page also has access to it. We use this fact to share our matchmaker object between two different applications running on the same page. One application is the Varcade games client. The other is the game, which has nothing to do with the Varcade Games client - it just happens to have been downloaded by it. Since both have access to this shared object, they can now interact - and that is how clicking the multi-player button in the game UI can open a modal in the Varcade Games UI. We'll look at exactly how the game client does this in a later section. That's it for the matchmaker for now - we will come back and look at all of this in a lot more detail later on when we look at multi-player gameplay and the matchmaker server. But first, let's jump in to some single player Rock Paper Scissors Apocalypse.","title":"The Matchmaker"},{"location":"internship/onboarding/varcade_games/matchmaker/#the-matchmaker","text":"The Varcade Games client comes with some built-in functionality that allows players to create and join games online. Game developers can hook into this built in functionality to interact with our matchmaker server. So what we have is: A matchmaker SDK A matchmaker server The Varcade Games client provides the SDK and manages interactions with the Matchmaker so that game developers don't need to. The UI for creating and joining games will be consistent across all games in the portfolio.","title":"The Matchmaker"},{"location":"internship/onboarding/varcade_games/matchmaker/#the-matchmaker-sdk","text":"Open up website/client/src/components/wp-active-game.vue again. You may have already noticed there is a custom component in there for the matchmaker: 1 < wp-matchmaker :game-id = \"gameId\" /> If you open up that file, website/client/src/components/matchmaker.vue , you will see that it contains a modal : 1 2 3 4 5 6 < modal name = \"matchmaker-modal\" width = \"800\" height = \"600\" :scrollable = \"false\" :reset = \"true\" > ... A modal is a piece of UI that appears over our main UI. Hopefully you have seen this in action already. When you click Multi-player on the Rock Paper Scissors Apocalypse main menu a window pops up. That is a modal, and this is where it is defined. One function worth checking out at this point is the initMatchmaker method: 1 2 3 4 5 6 7 8 9 10 11 12 13 initMatchmaker : function () { if ( ! this . matchmaker && ! window . getMatchmaker ) { const matchmaker = new Matchmaker ( this . gameId , this . $store , () => { this . $modal . show ( 'matchmaker-modal' ); this . refreshGameList (); }); this . matchmaker = matchmaker ; window . getMatchmaker = function () { return matchmaker ; } } } This is how we expose the Matchmaker functionality to the game client. We create an instance of a Matchmaker object. We then attach a function called getMatchmaker to the global Javascript window object.","title":"The Matchmaker SDK"},{"location":"internship/onboarding/varcade_games/matchmaker/#the-matchmaker-object","text":"The above code initializes the Matchmaker object here: 1 2 3 4 new Matchmaker ( this . gameId , this . $store , () => { this . $modal . show ( 'matchmaker-modal' ); this . refreshGameList (); }); To understand a bit better what is going on here, let's look at the source. Open up website/client/src/matchmaker.js . This class is an interface to the Matchmaker server. It exposes all of the functionality of that server to the Varcade Games client, for example: Get a list of open games Create a new game Join an existing game The matchmaker also provides a hook for the actual game client to hook into the matchmaker. Remember earlier on when we attached our Matchmaker object to the window object? Game client can access that same window object. Any Javascript executing on the page can. So that the game client does is call window.getMatchmaker() , and if a player selects multi-player they can call matchmaker.showMatchmaker(callback) . The whole thing looks something like this: It's worth spending a minute going through this diagram. First off, you should notice that I've split the diagram in two with a red dotted line. It's important to not what exactly is within the scope of the Varcade Games Client and what is not. Within the client we have a matchmaker Vue file, which is responsible for the matchmaker UI, and we have a matchmaker object, which is a normal object that provides access to the matchmaker server and the matchmaker UI. But next to those two we have a window object and the actual game client (the graphics and gameplay etc...). The window is a global Javascript script object that represents a tab in your browser. So every time you open up a new webpage in your browser, that webpage has access to this global object. That means that any Javascript running on that page also has access to it. We use this fact to share our matchmaker object between two different applications running on the same page. One application is the Varcade games client. The other is the game, which has nothing to do with the Varcade Games client - it just happens to have been downloaded by it. Since both have access to this shared object, they can now interact - and that is how clicking the multi-player button in the game UI can open a modal in the Varcade Games UI. We'll look at exactly how the game client does this in a later section. That's it for the matchmaker for now - we will come back and look at all of this in a lot more detail later on when we look at multi-player gameplay and the matchmaker server. But first, let's jump in to some single player Rock Paper Scissors Apocalypse.","title":"The Matchmaker Object"},{"location":"internship/onboarding/varcade_games/reverse_engineering/","text":"Reverse Engineering Now that we've been through the full project setup and you have seen some of the system architecture in detail it is time to spend some time digging around yourself. Let's start with your browser console. The Browser Console If you've ever done any sort of web development you're likely familiar with the browser console as well as the value that it brings. If not, you're about to find out. Digging around in Varcade Games If you development stack isn't running then go ahead and start it up. Then open your browser to your local Varcade Games instance at localhost:8002 . Log in to some existing account, or create a new one if you need to. Inspecting a webpage Once you've arrived at the games page do the following: Right-click on the Varcade Games title at the top left hand corner of the browser window In the menu that pops up select the Inspect item You should see something like this: You have just opened the built-in web browser dev tools. As the name suggests, this is a set of tools for developers. Depending on the browser you are using (I am using Brave) this may look different, but most of the popular browser these days have more or less the same options available. In our dev tools you'll be presented with some HTML. More specifically, you are seeing the HTML that was created for displaying Varcade Games. If you move your mouse over some of the HTML in the tools window you will notice that different elements on the page get highlighted. You can even right click on the HTML elements to interact with them. Try right-clicking the '<body>' tag and selecting Delete element . Everything is gone! This is expected - all we've done here is dynamically modify the HTML in our browser. But don't worry, refresh the page and everything will come back, just the way it was. You can open up these dev tools on any web page that you visit and have a look around at how they structure their website. Some will be complex, others less so - but it's always interesting to jump in and have a look at how your favourite websites are built. Spend some time digging around in the HTML. Try removing some elements and see what effect it has on the page. Everything you see and do here will be valuable for when you actually start working on the project. Styling Along with the HTML you'll also notice a section in the dev tools for CSS. In my case it's on the right hand side of the window under the heading Styles . Any CSS that is defined for the page you are viewing will show up here - and yes you can go ahead and modify this too. This tool is particularly useful when you are actively designing and building a page as you can change values here to get quick feedback on how it looks before you go ahead and modify your CSS files. So let's play with it. Left-click on the body tag. In the styles section of your dev tools you should now see some style information for the body of our webpage. Notice that if you uncheck the background entry, the page background turns white. If you uncheck the color entry then all of the text on the page turns black. Two things worth noticing in this UI: Sometimes unchecking a style doesn't do anything! Some of the styles are crossed off! To address the first point, it's worth understanding what CSS actually means. It stands for Cascading StyleSheets . The word cascading is the one that matters here. It means 'to pass on'. What is happening here is that the body element in our CSS defines some styling, but other elements on the page may choose to define their own styling . So the information in the body style will cascade down through all child elements, but that does not mean that the child elements need to use that style, they may have their own style - as children often do. That leads on to the second point. When you see an entry in this list crossed off then it means some CSS has been defined elsewhere that overrides it. In our case, we have overridden the default body style that colors text black so that we can color it white. If you uncheck the box beside the color: white style you will notice that the color: black style is no longer crossed off. That is because we are no longer overriding in. Using these tools you can play around with different styles and visuals for your pages (or other peoples pages if you like!). Adding new styles In the style window you should see an entry called element.style or just element . If you click that entry you can add what ever styling you want to the selected element Trying copying and pasting some of these style changes into that section and notice the difference it makes to the webpage: background: red; margin: 100px; font-size: 2em; The Console The page inspector is great for understanding the layout and styling of any given webpage - but modern webpages are a lot more than just structured content and pretty colors. They're active. Especially in the case of the pages that contain our games. Active pages means there is some Javascript running somewhere - and where there are scripts running we need logs to understand what the hell is going on. Along the top of the dev tools section of your browser window there should be a 'Console' tab. Whenever you write some Javascript for a browser and write to the console it shows up here. So for example 1 console.log ( \"Hello World\" ) Running this Javascript in a browser will print Hello World to the console. In our console you can see there is a lot more going on, but before we dig in - let's get a fresh view of the information. First open up the game page so you can see Rock Paper Scissors Apocalypse . Then refresh the page to captured all of the output that comes with loading this page. If you scroll up towards the top you should see some messages like this: 1 2 3 4 5 6 7 8 9 10 11 ... Phaser v3.55.2 ( WebGL | Web Audio ) https://phaser.io Checking local storage for save data... Game loading... Game loaded. Boot complete - loading assets Loading assets... Loading 'global' assets... Loading icons: ui/icons.png,50,50 Loading bgMusic: audio/battle.wav ... This is what is being logged by the game client to help us understand what is going on. The short snippet above shows the game starting up and then beginning to load assets (the images/audio etc...). It's worth noting that not all of these logs are coming from code we wrote . Some of the log messages are coming from Phaser - the 2D game engine we are using. Some of them are coming from Vue.js - the web framework we are using. You don't need to understand any of these logs just yet, but you need to know they are there. Leave the console open and try navigating around the website, playing the game, playing multi-player etc... and see what is being printed out there. Understanding how to find and interpret logs will be vital later on when you start extending Varcade Games. Networking The final section of the browser dev tools we're going to look at here is the Network section: Again this may look slightly different in your browser, but the concepts are all the same. Select the Network tab in your browser and refresh the page. What you're looking at here is all of the requests that your browser sent to the server in order to load the page. In our case it there are requests be sent to multiple servers as we load the: Page's HTML Page's Javascript Page's CSS Game's Javascript Images for the game Audio for the game Leaderboard and player stats for the game In the table of requests we can also see the Status of the request, the Type of resource being requests (image/script/text etc...) and a few other bits of useful information about the size of the response and the amount of time it took. If you click on any one of the requests you will get a lot more information about it: The request in the image above is the request to fetch the actual game code for Rock Paper Scissors Apocalypse. Have a look at the request URL. It is http://localhost:8090/main.js . Is this URL familiar for any reason? Cast your mind back to when we set up the game in the Varcade Games admin panel. For every game we entered a URL... the above URL is that URL. Coincidence? No. When we register a game with Varcade Games we tell the system where the game code is located, and this is the point where we actually call that URL to get the game code. Again, these tools are all interactive. You can modify and re-send requests if you like, or preview the response data. Exploration Ok - I think you are now armed with enough information to start exploring and trying to reverse engineer some of what is going on behind the scenes are Varcade Games. Like I said before - jump in, click things, break things. Any damage you do and be undone by refreshing the page. And most importantly: think . As you explore the website using the devtools, have a think about: What does this request do? Why does this one take longer than that one? What happens if I remove this HTML element? What would the game page look like with a red background? What happens if I change the URL in the admin panel? Will the game break? What are all of these messages in the console? And don't be afraid to look things up. Head over to Duck Duck Go (or Google... I suppose) and search for some of the words you see but don't understand. This exploration and research is far more valuable than anything you read here or watch on some tutorial video. Notes: There are some practical applications for the console in your day to day life, for example if you're viewing a webpage and it has an annoying flashing ad, or and image you don't like, you can open up the console and remove it! The next time some webpage stops working as expected, try opening up the console and having a look at the logs. If you need to contact support the information you find here might be useful.","title":"Reverse Engineering"},{"location":"internship/onboarding/varcade_games/reverse_engineering/#reverse-engineering","text":"Now that we've been through the full project setup and you have seen some of the system architecture in detail it is time to spend some time digging around yourself. Let's start with your browser console.","title":"Reverse Engineering"},{"location":"internship/onboarding/varcade_games/reverse_engineering/#the-browser-console","text":"If you've ever done any sort of web development you're likely familiar with the browser console as well as the value that it brings. If not, you're about to find out.","title":"The Browser Console"},{"location":"internship/onboarding/varcade_games/reverse_engineering/#digging-around-in-varcade-games","text":"If you development stack isn't running then go ahead and start it up. Then open your browser to your local Varcade Games instance at localhost:8002 . Log in to some existing account, or create a new one if you need to.","title":"Digging around in Varcade Games"},{"location":"internship/onboarding/varcade_games/reverse_engineering/#inspecting-a-webpage","text":"Once you've arrived at the games page do the following: Right-click on the Varcade Games title at the top left hand corner of the browser window In the menu that pops up select the Inspect item You should see something like this: You have just opened the built-in web browser dev tools. As the name suggests, this is a set of tools for developers. Depending on the browser you are using (I am using Brave) this may look different, but most of the popular browser these days have more or less the same options available. In our dev tools you'll be presented with some HTML. More specifically, you are seeing the HTML that was created for displaying Varcade Games. If you move your mouse over some of the HTML in the tools window you will notice that different elements on the page get highlighted. You can even right click on the HTML elements to interact with them. Try right-clicking the '<body>' tag and selecting Delete element . Everything is gone! This is expected - all we've done here is dynamically modify the HTML in our browser. But don't worry, refresh the page and everything will come back, just the way it was. You can open up these dev tools on any web page that you visit and have a look around at how they structure their website. Some will be complex, others less so - but it's always interesting to jump in and have a look at how your favourite websites are built. Spend some time digging around in the HTML. Try removing some elements and see what effect it has on the page. Everything you see and do here will be valuable for when you actually start working on the project.","title":"Inspecting a webpage"},{"location":"internship/onboarding/varcade_games/reverse_engineering/#styling","text":"Along with the HTML you'll also notice a section in the dev tools for CSS. In my case it's on the right hand side of the window under the heading Styles . Any CSS that is defined for the page you are viewing will show up here - and yes you can go ahead and modify this too. This tool is particularly useful when you are actively designing and building a page as you can change values here to get quick feedback on how it looks before you go ahead and modify your CSS files. So let's play with it. Left-click on the body tag. In the styles section of your dev tools you should now see some style information for the body of our webpage. Notice that if you uncheck the background entry, the page background turns white. If you uncheck the color entry then all of the text on the page turns black. Two things worth noticing in this UI: Sometimes unchecking a style doesn't do anything! Some of the styles are crossed off! To address the first point, it's worth understanding what CSS actually means. It stands for Cascading StyleSheets . The word cascading is the one that matters here. It means 'to pass on'. What is happening here is that the body element in our CSS defines some styling, but other elements on the page may choose to define their own styling . So the information in the body style will cascade down through all child elements, but that does not mean that the child elements need to use that style, they may have their own style - as children often do. That leads on to the second point. When you see an entry in this list crossed off then it means some CSS has been defined elsewhere that overrides it. In our case, we have overridden the default body style that colors text black so that we can color it white. If you uncheck the box beside the color: white style you will notice that the color: black style is no longer crossed off. That is because we are no longer overriding in. Using these tools you can play around with different styles and visuals for your pages (or other peoples pages if you like!).","title":"Styling"},{"location":"internship/onboarding/varcade_games/reverse_engineering/#adding-new-styles","text":"In the style window you should see an entry called element.style or just element . If you click that entry you can add what ever styling you want to the selected element Trying copying and pasting some of these style changes into that section and notice the difference it makes to the webpage: background: red; margin: 100px; font-size: 2em;","title":"Adding new styles"},{"location":"internship/onboarding/varcade_games/reverse_engineering/#the-console","text":"The page inspector is great for understanding the layout and styling of any given webpage - but modern webpages are a lot more than just structured content and pretty colors. They're active. Especially in the case of the pages that contain our games. Active pages means there is some Javascript running somewhere - and where there are scripts running we need logs to understand what the hell is going on. Along the top of the dev tools section of your browser window there should be a 'Console' tab. Whenever you write some Javascript for a browser and write to the console it shows up here. So for example 1 console.log ( \"Hello World\" ) Running this Javascript in a browser will print Hello World to the console. In our console you can see there is a lot more going on, but before we dig in - let's get a fresh view of the information. First open up the game page so you can see Rock Paper Scissors Apocalypse . Then refresh the page to captured all of the output that comes with loading this page. If you scroll up towards the top you should see some messages like this: 1 2 3 4 5 6 7 8 9 10 11 ... Phaser v3.55.2 ( WebGL | Web Audio ) https://phaser.io Checking local storage for save data... Game loading... Game loaded. Boot complete - loading assets Loading assets... Loading 'global' assets... Loading icons: ui/icons.png,50,50 Loading bgMusic: audio/battle.wav ... This is what is being logged by the game client to help us understand what is going on. The short snippet above shows the game starting up and then beginning to load assets (the images/audio etc...). It's worth noting that not all of these logs are coming from code we wrote . Some of the log messages are coming from Phaser - the 2D game engine we are using. Some of them are coming from Vue.js - the web framework we are using. You don't need to understand any of these logs just yet, but you need to know they are there. Leave the console open and try navigating around the website, playing the game, playing multi-player etc... and see what is being printed out there. Understanding how to find and interpret logs will be vital later on when you start extending Varcade Games.","title":"The Console"},{"location":"internship/onboarding/varcade_games/reverse_engineering/#networking","text":"The final section of the browser dev tools we're going to look at here is the Network section: Again this may look slightly different in your browser, but the concepts are all the same. Select the Network tab in your browser and refresh the page. What you're looking at here is all of the requests that your browser sent to the server in order to load the page. In our case it there are requests be sent to multiple servers as we load the: Page's HTML Page's Javascript Page's CSS Game's Javascript Images for the game Audio for the game Leaderboard and player stats for the game In the table of requests we can also see the Status of the request, the Type of resource being requests (image/script/text etc...) and a few other bits of useful information about the size of the response and the amount of time it took. If you click on any one of the requests you will get a lot more information about it: The request in the image above is the request to fetch the actual game code for Rock Paper Scissors Apocalypse. Have a look at the request URL. It is http://localhost:8090/main.js . Is this URL familiar for any reason? Cast your mind back to when we set up the game in the Varcade Games admin panel. For every game we entered a URL... the above URL is that URL. Coincidence? No. When we register a game with Varcade Games we tell the system where the game code is located, and this is the point where we actually call that URL to get the game code. Again, these tools are all interactive. You can modify and re-send requests if you like, or preview the response data.","title":"Networking"},{"location":"internship/onboarding/varcade_games/reverse_engineering/#exploration","text":"Ok - I think you are now armed with enough information to start exploring and trying to reverse engineer some of what is going on behind the scenes are Varcade Games. Like I said before - jump in, click things, break things. Any damage you do and be undone by refreshing the page. And most importantly: think . As you explore the website using the devtools, have a think about: What does this request do? Why does this one take longer than that one? What happens if I remove this HTML element? What would the game page look like with a red background? What happens if I change the URL in the admin panel? Will the game break? What are all of these messages in the console? And don't be afraid to look things up. Head over to Duck Duck Go (or Google... I suppose) and search for some of the words you see but don't understand. This exploration and research is far more valuable than anything you read here or watch on some tutorial video. Notes: There are some practical applications for the console in your day to day life, for example if you're viewing a webpage and it has an annoying flashing ad, or and image you don't like, you can open up the console and remove it! The next time some webpage stops working as expected, try opening up the console and having a look at the logs. If you need to contact support the information you find here might be useful.","title":"Exploration"},{"location":"internship/onboarding/varcade_games/running_vcg/","text":"Building the applications From your terminal, open the build_tools directory: 1 cd ~/code/build_tools We'll use Vim to create a settings file for our local environment. If you haven't used Vim before, this may be a strange experience. First type vim .env.local in your terminal and hit return . This will result in a blank screen. Next press i to enter insert mode and then type the following line: 1 ENV_CODE_OVER_TIME_ROOT=/home/<your user name here>/code Then press the esc key and type :wq and hit return If you did everything exactly as I've written above, there should now be a new file in the build_tools directory called .env.local . This file tells the build scripts where the code is, so it's pretty important. You should now be able to open this file in VSCode. If you have any issues with Vim you can create the file via VSCode - but it's good to start wrapping your head around Vim now, as it will be useful in the future. Next we need to install a couple tools for building and running the project: 1 2 sudo apt install make sudo apt install docker-compose Building Varcade Games Windows Only Make sure docker is running (in Windows). Open Docker and open the setting screen to: Docker > Settings > Resources > WSL Integration > Enable integration with additional distros Make sure that Ubuntu-20.04 is checked in the Enable integration with additional distros section: Back in your terminal, run: 1 make build This will kick off a build of the various different applications. This will take a few minutes as all of the dependencies will need to download. Nearly there! Running the applications All we need to do now is run make start from the Ubuntu terminal. That will start up all of the applications and you can check their state by running make ps . If any of the services fail to start, run make start again. Before we can actually interact with Varcade Games we need to initialize the database. Run the following command to connect to the game-portal application: 1 docker exec -it game-portal bash Next run: 1 ./manage.py migrate You will see some output like this: Next run: 1 ./manage.py createsuperuser You will need to follow a few steps to create your admin user account for managing Varcade Games. We have one final thing to do - that is set up our local networking environment. Open notepad as administrator. The select File > Open and navigate to C:\\Windows\\System32\\drivers\\etc\\ and open the file called hosts . The directory may appear empty, so be sure to select all files from the drop down at the bottom right that says text files . Add the following line to the bottom of the file: 1 127 .0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local Save and close notepad. Now, if you point your browser at localhost:8002 you should arrive at the landing page for Varcade Games . You can log in with the username and password you entered in the previous step when you ran ./manage.py createsuperuser . Unfortunately there won't be much to see. We need to add game.","title":"Running vcg"},{"location":"internship/onboarding/varcade_games/running_vcg/#building-the-applications","text":"From your terminal, open the build_tools directory: 1 cd ~/code/build_tools We'll use Vim to create a settings file for our local environment. If you haven't used Vim before, this may be a strange experience. First type vim .env.local in your terminal and hit return . This will result in a blank screen. Next press i to enter insert mode and then type the following line: 1 ENV_CODE_OVER_TIME_ROOT=/home/<your user name here>/code Then press the esc key and type :wq and hit return If you did everything exactly as I've written above, there should now be a new file in the build_tools directory called .env.local . This file tells the build scripts where the code is, so it's pretty important. You should now be able to open this file in VSCode. If you have any issues with Vim you can create the file via VSCode - but it's good to start wrapping your head around Vim now, as it will be useful in the future. Next we need to install a couple tools for building and running the project: 1 2 sudo apt install make sudo apt install docker-compose","title":"Building the applications"},{"location":"internship/onboarding/varcade_games/running_vcg/#building-varcade-games","text":"","title":"Building Varcade Games"},{"location":"internship/onboarding/varcade_games/running_vcg/#windows-only","text":"Make sure docker is running (in Windows). Open Docker and open the setting screen to: Docker > Settings > Resources > WSL Integration > Enable integration with additional distros Make sure that Ubuntu-20.04 is checked in the Enable integration with additional distros section: Back in your terminal, run: 1 make build This will kick off a build of the various different applications. This will take a few minutes as all of the dependencies will need to download. Nearly there!","title":"Windows Only"},{"location":"internship/onboarding/varcade_games/running_vcg/#running-the-applications","text":"All we need to do now is run make start from the Ubuntu terminal. That will start up all of the applications and you can check their state by running make ps . If any of the services fail to start, run make start again. Before we can actually interact with Varcade Games we need to initialize the database. Run the following command to connect to the game-portal application: 1 docker exec -it game-portal bash Next run: 1 ./manage.py migrate You will see some output like this: Next run: 1 ./manage.py createsuperuser You will need to follow a few steps to create your admin user account for managing Varcade Games. We have one final thing to do - that is set up our local networking environment. Open notepad as administrator. The select File > Open and navigate to C:\\Windows\\System32\\drivers\\etc\\ and open the file called hosts . The directory may appear empty, so be sure to select all files from the drop down at the bottom right that says text files . Add the following line to the bottom of the file: 1 127 .0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local Save and close notepad. Now, if you point your browser at localhost:8002 you should arrive at the landing page for Varcade Games . You can log in with the username and password you entered in the previous step when you ran ./manage.py createsuperuser . Unfortunately there won't be much to see. We need to add game.","title":"Running the applications"},{"location":"internship/onboarding/varcade_games/system_architecture/","text":"System Architecture At this point you should have your local development environment all set up and you should be able to log in to your own private instance of Varcade games and play Rock Paper Scissors Apocalypse . So let's have a look at the big picture - what's actually going on behind the scenes. In the above diagram I have colored all of the components that make up Varcade Games in grey. The green boxes (Redis and MySQL) are third party dependencies. Varcade Games needs them to operate, but they exist as independent products built by someone else. And finally, in blue is our actual game. Rock Paper Scissors Apocalypse. This game has nothing to do with Varcade Games, technically at least. It is plugged into the system, but the system doesn't need it to operate. The game doesn't need Varcade Games to function either. It is using it as a host. I'll briefly introduce the various components here before we dig more deeply into how they work and how to work with them. Components Varcade Games Client & Server The first box on the left hand side center of the diagram is our Varcade Games Client. This is what the user interacts with. Where they log in, browse games and select games to play. This client is built using Vue.js , so there is a lot of Javascript, HTML and CSS in there. The client connects to a dedicated Varcade Games server. This server is responsible for managing player accounts and managing games. It is built using Django , so we'll be working in Python on the server side. It also uses MySQL as a database to store the player account and game information. Player Stats Server In our diagram we can see that the Varcade Games Server connects to something called the 'Stats Tracker' server. This server's job is to serve leaderboards and interesting statistics to the game portal. Each game page will have a metrics and leaderboard section, the Varcade Games client gets that information from the Varcade Games server, but that server must request the information from the Stats Tracker server first. This server is built using Flask , which means we're working with Python. Matchmaker Server The Varcade Games client also connects to the Matchmaker server. The client has a built in Matchmaker maker UI so that players can find each other and play together. The Matchmaker server is responsible for creating and managing multi-player games. It is generic by nature and doesn't really know anything about the games that are using it, so each game that wants to use it must be registered with it. This server is also built using Flask , which means we're working with Python again. Redis You'll notice that both the Stats Tracker and Matchmaker servers connect to Redis , which is a no-sql database. Multi-player games, player stats and leaderboards are all stored in Redis. It provides a number of data structures that are useful for our particular use case. The Workers Both the Stats Tracker and Matchmaker also have 'worker' applications. These are programs that are also written in Python whose job it is to monitor goings on behind the scenes. They track and store player stats coming from games. They clean up old games in the Matchmaker database, and much more. Many server systems require such applications for performing any work that doesn't fit into the typical request-response model of a sever. RPS Client and Server And finally, we've got our game. This is the game that we have integrated into Varcade Games, which means it is hosted by, and leverages the Matchmaker and Stats Tracker services built in to, Varcade Games. Notice that our diagram shows a connection between the two clients. The game client is embedded in the Varcade Games client. Notice also that the client communicates with its dedicated server in order to play against other players online, but the server also has connections to Varcade Games. First of all, the Matchmaker needs to be able to connect to the game server in order to actually create and manage games. Secondly, the game server needs to send 'events' to a 'stream' in order to keep the Varcade Games system up to date. This 'stream' is more functionality in Redis that we are leveraging. The game client is built using Phaser 3, a 2D game engine built in Javascript. This is the part the player interacts with. The game server is built using Node.js, which is a web server built in Javascript. Interaction Now that we've been introduced to the various different players in our systems, let's take a look at how the system actually behaves ; how these components actually interact with each other. To represent this visually we will use something called a 'sequence diagram'. Sequence Diagrams In case you've never seen a sequence diagram before, they are essentially just a useful way of visually representing interactions between a number of components in a system over time. For example, here is a very basic sequence diagram that shows the interactions between a customer and a cashier when buying a loaf of bread: What a pleasant and polite interaction it was too. All we've done here is visually represent a customer walking up to a cashier with a loaf of bread. They greet each other, then the cashier scans the bread and tells the customer how much they have to pay. The customer then counts out some cash and gives it to the cashier. The cashier then gives the customer their change before they say goodbye and go their separate ways. The arrows that go between entities represent communication between components . There are also arrows that start and end on a single entity. In our case, when the cashier scans the bread they don't need anything from the customer. They just need to do that action themselves. Same goes for the customer when they are counting out the money needed to pay for the bread. In the sections below we will expand on these concepts to understand how the different entities in the Varcade Games system interact with each other. Basic Varcade Games interaction Let's use a sequence diagram to take a look at some of the interactions you will have already had with Varcade Games. In the below sequence diagram we have 4 entities: User Browser This is the user's web browser, through which it is interacting with our website Varcade Games Server This is the server that manages all of the Varcade Games configuration and data Stats Tracker Server This is the server that manages leaderboards and player stats for our games File Server This is a basic server that serves files This diagram is showing us the most basic interaction that a user will have with Varcade Games. They will: Load the website Log in View a list of games Select a game Play the game Our website is what is known as a 'client side application'. All of the interactions and layouts of our pages are managed through Javascript running in the browser. So when you navigate to Varcade Games you first need to download that Javascript. It is stored on a server whose only job is to serve those files. Once the browser runs the Javascript it will present the user with a log in page. As mentioned earlier, the client will connect to the Varcade Games server to log in. The server will give the client back a token, which it can use to fetch the player's profile and a list of currently available games. Once it has a list of game the client can go about displaying them on the landing page that players see once they've logged in. A player can select an active game to play, at which point our client will fetch the leaderboard for that game as well as any statistics that are available for that player. In our case your will only see stats if you have played a Rock Paper Scissors multi-player game. Once all of that is loaded our client can display the game page, at which point the user is free to play the game. That's it for our high level view of the overall system. Later one we will see more sequence diagrams that will help us go through some of the more complex interactions within Varcade Games. For now, let's start scratching beneath the surface...","title":"System Architecture"},{"location":"internship/onboarding/varcade_games/system_architecture/#system-architecture","text":"At this point you should have your local development environment all set up and you should be able to log in to your own private instance of Varcade games and play Rock Paper Scissors Apocalypse . So let's have a look at the big picture - what's actually going on behind the scenes. In the above diagram I have colored all of the components that make up Varcade Games in grey. The green boxes (Redis and MySQL) are third party dependencies. Varcade Games needs them to operate, but they exist as independent products built by someone else. And finally, in blue is our actual game. Rock Paper Scissors Apocalypse. This game has nothing to do with Varcade Games, technically at least. It is plugged into the system, but the system doesn't need it to operate. The game doesn't need Varcade Games to function either. It is using it as a host. I'll briefly introduce the various components here before we dig more deeply into how they work and how to work with them.","title":"System Architecture"},{"location":"internship/onboarding/varcade_games/system_architecture/#components","text":"","title":"Components"},{"location":"internship/onboarding/varcade_games/system_architecture/#varcade-games-client-server","text":"The first box on the left hand side center of the diagram is our Varcade Games Client. This is what the user interacts with. Where they log in, browse games and select games to play. This client is built using Vue.js , so there is a lot of Javascript, HTML and CSS in there. The client connects to a dedicated Varcade Games server. This server is responsible for managing player accounts and managing games. It is built using Django , so we'll be working in Python on the server side. It also uses MySQL as a database to store the player account and game information.","title":"Varcade Games Client &amp; Server"},{"location":"internship/onboarding/varcade_games/system_architecture/#player-stats-server","text":"In our diagram we can see that the Varcade Games Server connects to something called the 'Stats Tracker' server. This server's job is to serve leaderboards and interesting statistics to the game portal. Each game page will have a metrics and leaderboard section, the Varcade Games client gets that information from the Varcade Games server, but that server must request the information from the Stats Tracker server first. This server is built using Flask , which means we're working with Python.","title":"Player Stats Server"},{"location":"internship/onboarding/varcade_games/system_architecture/#matchmaker-server","text":"The Varcade Games client also connects to the Matchmaker server. The client has a built in Matchmaker maker UI so that players can find each other and play together. The Matchmaker server is responsible for creating and managing multi-player games. It is generic by nature and doesn't really know anything about the games that are using it, so each game that wants to use it must be registered with it. This server is also built using Flask , which means we're working with Python again.","title":"Matchmaker Server"},{"location":"internship/onboarding/varcade_games/system_architecture/#redis","text":"You'll notice that both the Stats Tracker and Matchmaker servers connect to Redis , which is a no-sql database. Multi-player games, player stats and leaderboards are all stored in Redis. It provides a number of data structures that are useful for our particular use case.","title":"Redis"},{"location":"internship/onboarding/varcade_games/system_architecture/#the-workers","text":"Both the Stats Tracker and Matchmaker also have 'worker' applications. These are programs that are also written in Python whose job it is to monitor goings on behind the scenes. They track and store player stats coming from games. They clean up old games in the Matchmaker database, and much more. Many server systems require such applications for performing any work that doesn't fit into the typical request-response model of a sever.","title":"The Workers"},{"location":"internship/onboarding/varcade_games/system_architecture/#rps-client-and-server","text":"And finally, we've got our game. This is the game that we have integrated into Varcade Games, which means it is hosted by, and leverages the Matchmaker and Stats Tracker services built in to, Varcade Games. Notice that our diagram shows a connection between the two clients. The game client is embedded in the Varcade Games client. Notice also that the client communicates with its dedicated server in order to play against other players online, but the server also has connections to Varcade Games. First of all, the Matchmaker needs to be able to connect to the game server in order to actually create and manage games. Secondly, the game server needs to send 'events' to a 'stream' in order to keep the Varcade Games system up to date. This 'stream' is more functionality in Redis that we are leveraging. The game client is built using Phaser 3, a 2D game engine built in Javascript. This is the part the player interacts with. The game server is built using Node.js, which is a web server built in Javascript.","title":"RPS Client and Server"},{"location":"internship/onboarding/varcade_games/system_architecture/#interaction","text":"Now that we've been introduced to the various different players in our systems, let's take a look at how the system actually behaves ; how these components actually interact with each other. To represent this visually we will use something called a 'sequence diagram'.","title":"Interaction"},{"location":"internship/onboarding/varcade_games/system_architecture/#sequence-diagrams","text":"In case you've never seen a sequence diagram before, they are essentially just a useful way of visually representing interactions between a number of components in a system over time. For example, here is a very basic sequence diagram that shows the interactions between a customer and a cashier when buying a loaf of bread: What a pleasant and polite interaction it was too. All we've done here is visually represent a customer walking up to a cashier with a loaf of bread. They greet each other, then the cashier scans the bread and tells the customer how much they have to pay. The customer then counts out some cash and gives it to the cashier. The cashier then gives the customer their change before they say goodbye and go their separate ways. The arrows that go between entities represent communication between components . There are also arrows that start and end on a single entity. In our case, when the cashier scans the bread they don't need anything from the customer. They just need to do that action themselves. Same goes for the customer when they are counting out the money needed to pay for the bread. In the sections below we will expand on these concepts to understand how the different entities in the Varcade Games system interact with each other.","title":"Sequence Diagrams"},{"location":"internship/onboarding/varcade_games/system_architecture/#basic-varcade-games-interaction","text":"Let's use a sequence diagram to take a look at some of the interactions you will have already had with Varcade Games. In the below sequence diagram we have 4 entities: User Browser This is the user's web browser, through which it is interacting with our website Varcade Games Server This is the server that manages all of the Varcade Games configuration and data Stats Tracker Server This is the server that manages leaderboards and player stats for our games File Server This is a basic server that serves files This diagram is showing us the most basic interaction that a user will have with Varcade Games. They will: Load the website Log in View a list of games Select a game Play the game Our website is what is known as a 'client side application'. All of the interactions and layouts of our pages are managed through Javascript running in the browser. So when you navigate to Varcade Games you first need to download that Javascript. It is stored on a server whose only job is to serve those files. Once the browser runs the Javascript it will present the user with a log in page. As mentioned earlier, the client will connect to the Varcade Games server to log in. The server will give the client back a token, which it can use to fetch the player's profile and a list of currently available games. Once it has a list of game the client can go about displaying them on the landing page that players see once they've logged in. A player can select an active game to play, at which point our client will fetch the leaderboard for that game as well as any statistics that are available for that player. In our case your will only see stats if you have played a Rock Paper Scissors multi-player game. Once all of that is loaded our client can display the game page, at which point the user is free to play the game. That's it for our high level view of the overall system. Later one we will see more sequence diagrams that will help us go through some of the more complex interactions within Varcade Games. For now, let's start scratching beneath the surface...","title":"Basic Varcade Games interaction"},{"location":"internship/onboarding/varcade_games/tests_and_linters/","text":"Tests & Linters Linter Now that we're making changes to our code we need to make sure that our changes are conforming to our code standards. A linter is a tool that can flag programming mistakes, bugs and code style violations. The Varcade Games client has a linter set up that will check any changes we make and in some cases even fix code style violations for us, if they are trivial enough. From your terminal, navigate to the website project client directory. For example, if your code is located in ~/code/varcade_games then you'd run: 1 cd ~/code/varcade_games/website/client Next we need to install some additional dependencies. Specifically npm , which is the Node Package Manager . This is a tool that allows you to install libraries that you can use to build your own applications (for example, Vue.js). For installation instructions check out their official docs . After the installation complete you can run the following command to actually install all of the project dependencies: 1 npm install Once that is done you can run: 1 npm run lint This will run a program that checks all of our client javascript code to make sure it conforms to our standards. It should print an output like this: 1 2 > web_portal_client@0.1.0 lint website/client > eslint ./src There's basically no output. As you can see it all looks good. But it won't always be like this, so let's break something so we can experience what that looks like. In your editor/IDE open up website/client/src/main.js . On the very first line that has code on it, add a semi-colon(;) to the end, like this: 1 import Vue from 'vue' ; Now go back to your terminal and run 1 npm run lint This time you should see a nasty looking error: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 website/client/src/main.js 7 :22 error Extra semicolon semi \u2716 1 problem ( 1 error, 0 warnings ) 1 error and 0 warnings potentially fixable with the ` --fix ` option. npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! web_portal_client@0.1.0 lint: ` eslint ./src ` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the web_portal_client@0.1.0 lint script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in : npm ERR! /tmp/.npm/_logs/2021-08-17T19_14_49_722Z-debug.log The important part is at the top: 1 2 website/client/src/main.js 7:22 error Extra semicolon semi It's telling us that there is an Extra semicolon in the file website/client/src/main.js on line 7, column 22. And indeed, if you count the rows and columns in your editor you will find your ';' at line: 7, col :22. There are many things that will trigger the linter to fail. What we're trying to do is make sure all of the code has a consistent style, which will make it easier to work with - especially is a lot of people are working on the same codebase. Thankfully when the linter picks up trivial things like this it can fix them itself. If you run: 1 npm run lint-fix You will notice we're back to no output: 1 2 > web_portal_client@0.1.0 lint-fix website/client > eslint ./src --fix The linter has removed the semicolon for us, but it cannot do more complex operations. For example, if you add the following code block to the top of main.js : 1 if ( true ) {} And run the linter with the fix option enabled you will get the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 > web_portal_client@0.1.0 lint-fix website/client > eslint ./src --fix website/client/src/main.js 34 :5 error Unexpected constant condition no-constant-condition 34 :11 error Empty block statement no-empty \u2716 2 problems ( 2 errors, 0 warnings ) npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! web_portal_client@0.1.0 lint-fix: ` eslint ./src --fix ` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the web_portal_client@0.1.0 lint-fix script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in : npm ERR! /tmp/.npm/_logs/2021-08-17T19_27_20_052Z-debug.log So the linter has actually made some changes. If you open main.js you will find that the invalid code block we added has been moved down 30 lines or so. This is because our linter doesn't want code before the imports in a file. However, the two remaining lint errors above cannot be fixed automatically - because it would modify logic, and we don't want a linter messing around with logic. In this case it's warning us that if(true) is a constant condition and pointless. It also doesn't allow empty code block like {} . It's important to note that this code will not break the application. It's just not very good code - and the linter can pick up on code that smells a bit bad. The more help we have keeping our codebase clean from bad smelling code, the better. Remove the invalid code block and run the linter again to get everything back to normal. As you work on Varcade Games you will meet a lot of different types of linter - or static analysis tools . Tests Whenever you write code you should probably write some automated tests. In our case, we don't have any client side tests at the moment, but we do have server side tests. So let's run them! In your terminal navigate over to the server directory for the website. For example, if your code is located in ~/code/varcade_games then you'd run: 1 cd ~/code/varcade_games/website/server For our server tests we actually use a docker image, just like for running the actual services. We build an image with all of the code and tests, then we run the container and run the tests. This gives us a consistent environment to run our tests in - everyone running these tests will be running with the same dependencies and configurations. If we just ran the tests on our dev machine we could get different results due to different configuration. I've abstracted away most of the complexity of running the tests so all you need to do is run: 1 make build_test_image This may take a while... Next we run the image as follows: 1 make run_test_image_mounted Once it's done you can run the following make commands to run the actual tests: 1 make run_tests You should see a whole lot of output after running that command, and it hopefully ends with something like the following: 1 ======== 10 passed, 0 warnings in 1 .67s ======== (Ok there might be a few warnings... but the tests should pass!) These tests test the functionality of the game portal - they tell us if something functional broke. So let's break something... Open up website/server/tests/game_portal/games/test_accounts.py . Find the test called test_create_user_with_short_password . This test case verifies that the server returns an error status if a user submits a password that is too short. In this case we expect and error to occur, so we have this assertion: 1 assert response . status_code == status . HTTP_400_BAD_REQUEST This ensures that the server response is a 400 (bad request) if a user submits a password as basic as foo . Change this line to the following: 1 assert response . status_code == 200 This would mean the request to the server was a success, which is the wrong behavior. Now run the tests again with make run_tests . The out put should have changed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #<snip> tests/game_portal/accounts/test_accounts.py::TestAccounts::test_create_user_with_short_password FAILED [ 20 % ] #<snip> ______________________________________ TestAccounts.test_create_user_with_short_password ______________________________________ self = <test_accounts.TestAccounts object at 0x7f5b357df3d0> api_client = <rest_framework.test.APIClient object at 0x7f5b35cc7950> def test_create_user_with_short_password ( self, api_client ) : \"\"\" Ensure user is not created for password lengths less than 8. \"\"\" data = { \"username\" : \"foobar\" , \"email\" : \"foobarbaz@example.com\" , \"password\" : \"foo\" , } response = api_client.post ( self.create_url, data, format = \"json\" ) > assert response.status_code == 200 E assert 400 == 200 E +400 E -200 tests/game_portal/accounts/test_accounts.py:51: AssertionError #<snip> =================================================== short test summary info =================================================== FAILED tests/game_portal/accounts/test_accounts.py::TestAccounts::test_create_user_with_short_password - assert 400 == 200 ========================================== 1 failed, 9 passed, 30 warnings in 1 .77s =========================================== In this output we can see that we now have a failing test. It is failing for the exact reason we made it fail: 1 2 3 4 > assert response.status_code == 200 E assert 400 == 200 E +400 E -200 We change our test to expect a 200, but the server is still returning a 400 - because the request is invalid. Go ahead and change the code back to get the tests running again. It's also worth noting that even though the tests are running in a container - our changes to the code were applied automatically. On the server part of the game portal there are some more checks we can do too. Coverage Now try running: 1 make run_coverage This tells us how much of our code is covered by tests: 1 2 3 4 5 6 7 8 9 <snip> game_portal/game_portal/test_settings.py 4 0 100 % game_portal/game_portal/urls.py 22 0 100 % tests/conftest.py 11 1 91 % 12 tests/game_portal/accounts/test_accounts.py 33 0 100 % tests/game_portal/games/test_games.py 40 0 100 % tests/game_portal/profiles/test_profiles.py 33 0 100 % ------------------------------------------------------------------------------------------------------ TOTAL 489 24 95 % Code coverage is a useful indicator about how much test coverage you have but it's important to understand that 100% coverage doesn't mean you have bug free or high quality code. Don't use coverage as a target, use it as a guide. Type Checking For our Python projects we also have some type checking. Python is a dynamically typed language, meaning we have no compiler to tell us about errors and we often have to wait until we are running the code to know whether it even runs. Enter Mypy. Mypy is a static type checker that will analyze our code and tell us if there is any in there that might be problematic. You can run the type checker against the game portal by running: 1 make run_type_checking Which should result in some output like: 1 2 3 4 5 docker exec -it $( docker ps -aqf \"name=gameportal_tests\" ) bash -c '\\ echo \"Running Mypy against web app\" && \\ mypy game_portal' Running Mypy against web app Success: no issues found in 41 source files And that's it for the server side. When working on any project that is expect to live for longer than a couple of months it's important to understand what tools are at your disposal to help ensure you are creating maintainable and extendable code. Now that you can make changes and run tests, let's take a closer at the server side code. It's time to Django.","title":"Tests and Linters"},{"location":"internship/onboarding/varcade_games/tests_and_linters/#tests-linters","text":"","title":"Tests &amp; Linters"},{"location":"internship/onboarding/varcade_games/tests_and_linters/#linter","text":"Now that we're making changes to our code we need to make sure that our changes are conforming to our code standards. A linter is a tool that can flag programming mistakes, bugs and code style violations. The Varcade Games client has a linter set up that will check any changes we make and in some cases even fix code style violations for us, if they are trivial enough. From your terminal, navigate to the website project client directory. For example, if your code is located in ~/code/varcade_games then you'd run: 1 cd ~/code/varcade_games/website/client Next we need to install some additional dependencies. Specifically npm , which is the Node Package Manager . This is a tool that allows you to install libraries that you can use to build your own applications (for example, Vue.js). For installation instructions check out their official docs . After the installation complete you can run the following command to actually install all of the project dependencies: 1 npm install Once that is done you can run: 1 npm run lint This will run a program that checks all of our client javascript code to make sure it conforms to our standards. It should print an output like this: 1 2 > web_portal_client@0.1.0 lint website/client > eslint ./src There's basically no output. As you can see it all looks good. But it won't always be like this, so let's break something so we can experience what that looks like. In your editor/IDE open up website/client/src/main.js . On the very first line that has code on it, add a semi-colon(;) to the end, like this: 1 import Vue from 'vue' ; Now go back to your terminal and run 1 npm run lint This time you should see a nasty looking error: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 website/client/src/main.js 7 :22 error Extra semicolon semi \u2716 1 problem ( 1 error, 0 warnings ) 1 error and 0 warnings potentially fixable with the ` --fix ` option. npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! web_portal_client@0.1.0 lint: ` eslint ./src ` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the web_portal_client@0.1.0 lint script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in : npm ERR! /tmp/.npm/_logs/2021-08-17T19_14_49_722Z-debug.log The important part is at the top: 1 2 website/client/src/main.js 7:22 error Extra semicolon semi It's telling us that there is an Extra semicolon in the file website/client/src/main.js on line 7, column 22. And indeed, if you count the rows and columns in your editor you will find your ';' at line: 7, col :22. There are many things that will trigger the linter to fail. What we're trying to do is make sure all of the code has a consistent style, which will make it easier to work with - especially is a lot of people are working on the same codebase. Thankfully when the linter picks up trivial things like this it can fix them itself. If you run: 1 npm run lint-fix You will notice we're back to no output: 1 2 > web_portal_client@0.1.0 lint-fix website/client > eslint ./src --fix The linter has removed the semicolon for us, but it cannot do more complex operations. For example, if you add the following code block to the top of main.js : 1 if ( true ) {} And run the linter with the fix option enabled you will get the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 > web_portal_client@0.1.0 lint-fix website/client > eslint ./src --fix website/client/src/main.js 34 :5 error Unexpected constant condition no-constant-condition 34 :11 error Empty block statement no-empty \u2716 2 problems ( 2 errors, 0 warnings ) npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! web_portal_client@0.1.0 lint-fix: ` eslint ./src --fix ` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the web_portal_client@0.1.0 lint-fix script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in : npm ERR! /tmp/.npm/_logs/2021-08-17T19_27_20_052Z-debug.log So the linter has actually made some changes. If you open main.js you will find that the invalid code block we added has been moved down 30 lines or so. This is because our linter doesn't want code before the imports in a file. However, the two remaining lint errors above cannot be fixed automatically - because it would modify logic, and we don't want a linter messing around with logic. In this case it's warning us that if(true) is a constant condition and pointless. It also doesn't allow empty code block like {} . It's important to note that this code will not break the application. It's just not very good code - and the linter can pick up on code that smells a bit bad. The more help we have keeping our codebase clean from bad smelling code, the better. Remove the invalid code block and run the linter again to get everything back to normal. As you work on Varcade Games you will meet a lot of different types of linter - or static analysis tools .","title":"Linter"},{"location":"internship/onboarding/varcade_games/tests_and_linters/#tests","text":"Whenever you write code you should probably write some automated tests. In our case, we don't have any client side tests at the moment, but we do have server side tests. So let's run them! In your terminal navigate over to the server directory for the website. For example, if your code is located in ~/code/varcade_games then you'd run: 1 cd ~/code/varcade_games/website/server For our server tests we actually use a docker image, just like for running the actual services. We build an image with all of the code and tests, then we run the container and run the tests. This gives us a consistent environment to run our tests in - everyone running these tests will be running with the same dependencies and configurations. If we just ran the tests on our dev machine we could get different results due to different configuration. I've abstracted away most of the complexity of running the tests so all you need to do is run: 1 make build_test_image This may take a while... Next we run the image as follows: 1 make run_test_image_mounted Once it's done you can run the following make commands to run the actual tests: 1 make run_tests You should see a whole lot of output after running that command, and it hopefully ends with something like the following: 1 ======== 10 passed, 0 warnings in 1 .67s ======== (Ok there might be a few warnings... but the tests should pass!) These tests test the functionality of the game portal - they tell us if something functional broke. So let's break something... Open up website/server/tests/game_portal/games/test_accounts.py . Find the test called test_create_user_with_short_password . This test case verifies that the server returns an error status if a user submits a password that is too short. In this case we expect and error to occur, so we have this assertion: 1 assert response . status_code == status . HTTP_400_BAD_REQUEST This ensures that the server response is a 400 (bad request) if a user submits a password as basic as foo . Change this line to the following: 1 assert response . status_code == 200 This would mean the request to the server was a success, which is the wrong behavior. Now run the tests again with make run_tests . The out put should have changed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #<snip> tests/game_portal/accounts/test_accounts.py::TestAccounts::test_create_user_with_short_password FAILED [ 20 % ] #<snip> ______________________________________ TestAccounts.test_create_user_with_short_password ______________________________________ self = <test_accounts.TestAccounts object at 0x7f5b357df3d0> api_client = <rest_framework.test.APIClient object at 0x7f5b35cc7950> def test_create_user_with_short_password ( self, api_client ) : \"\"\" Ensure user is not created for password lengths less than 8. \"\"\" data = { \"username\" : \"foobar\" , \"email\" : \"foobarbaz@example.com\" , \"password\" : \"foo\" , } response = api_client.post ( self.create_url, data, format = \"json\" ) > assert response.status_code == 200 E assert 400 == 200 E +400 E -200 tests/game_portal/accounts/test_accounts.py:51: AssertionError #<snip> =================================================== short test summary info =================================================== FAILED tests/game_portal/accounts/test_accounts.py::TestAccounts::test_create_user_with_short_password - assert 400 == 200 ========================================== 1 failed, 9 passed, 30 warnings in 1 .77s =========================================== In this output we can see that we now have a failing test. It is failing for the exact reason we made it fail: 1 2 3 4 > assert response.status_code == 200 E assert 400 == 200 E +400 E -200 We change our test to expect a 200, but the server is still returning a 400 - because the request is invalid. Go ahead and change the code back to get the tests running again. It's also worth noting that even though the tests are running in a container - our changes to the code were applied automatically. On the server part of the game portal there are some more checks we can do too.","title":"Tests"},{"location":"internship/onboarding/varcade_games/tests_and_linters/#coverage","text":"Now try running: 1 make run_coverage This tells us how much of our code is covered by tests: 1 2 3 4 5 6 7 8 9 <snip> game_portal/game_portal/test_settings.py 4 0 100 % game_portal/game_portal/urls.py 22 0 100 % tests/conftest.py 11 1 91 % 12 tests/game_portal/accounts/test_accounts.py 33 0 100 % tests/game_portal/games/test_games.py 40 0 100 % tests/game_portal/profiles/test_profiles.py 33 0 100 % ------------------------------------------------------------------------------------------------------ TOTAL 489 24 95 % Code coverage is a useful indicator about how much test coverage you have but it's important to understand that 100% coverage doesn't mean you have bug free or high quality code. Don't use coverage as a target, use it as a guide.","title":"Coverage"},{"location":"internship/onboarding/varcade_games/tests_and_linters/#type-checking","text":"For our Python projects we also have some type checking. Python is a dynamically typed language, meaning we have no compiler to tell us about errors and we often have to wait until we are running the code to know whether it even runs. Enter Mypy. Mypy is a static type checker that will analyze our code and tell us if there is any in there that might be problematic. You can run the type checker against the game portal by running: 1 make run_type_checking Which should result in some output like: 1 2 3 4 5 docker exec -it $( docker ps -aqf \"name=gameportal_tests\" ) bash -c '\\ echo \"Running Mypy against web app\" && \\ mypy game_portal' Running Mypy against web app Success: no issues found in 41 source files And that's it for the server side. When working on any project that is expect to live for longer than a couple of months it's important to understand what tools are at your disposal to help ensure you are creating maintainable and extendable code. Now that you can make changes and run tests, let's take a closer at the server side code. It's time to Django.","title":"Type Checking"},{"location":"internship/setup/","text":"Setting up your Dev Environment This section will teach you how to set up your computer to run a distributed system Code Over time aims to provide realistic hands-on experience with a real software product, and so this section covers what is typically the first thing a software engineer does during their first few days at a new company. That is, set up their shiny new work machine and get the project they will be working on running. This is something you need to learn by doing , so let's start doing.","title":"Introduction"},{"location":"internship/setup/#setting-up-your-dev-environment","text":"This section will teach you how to set up your computer to run a distributed system Code Over time aims to provide realistic hands-on experience with a real software product, and so this section covers what is typically the first thing a software engineer does during their first few days at a new company. That is, set up their shiny new work machine and get the project they will be working on running. This is something you need to learn by doing , so let's start doing.","title":"Setting up your Dev Environment"},{"location":"internship/setup/next_steps/","text":"What do I do now? The answer to that question is entirely up to you I'm afraid. If you'd like to add a real game that you can play to your Game Portal then open up the README for the game_rps project. It will guide you through the specific settings you need to do that. The onboarding section of this site will guide you through the overall system design and also provide more insights into specific areas of the project and the code. It covers topics like: The system architecture The structure of the various different projects How to test the various different systems How to make changes and see the impact in real time Unless you've already got experience working on a moderately sized project like this, I think the onboarding course is a great next step. If you are more experienced and confident then I'd recommend just jumping into the code and trying to figure out how everything works. Regardless of your choice, I really hope that working with Varcade Games is a great learning experience and helps you grow as an engineer. Good luck! - Kev","title":"Next Steps"},{"location":"internship/setup/next_steps/#what-do-i-do-now","text":"The answer to that question is entirely up to you I'm afraid. If you'd like to add a real game that you can play to your Game Portal then open up the README for the game_rps project. It will guide you through the specific settings you need to do that. The onboarding section of this site will guide you through the overall system design and also provide more insights into specific areas of the project and the code. It covers topics like: The system architecture The structure of the various different projects How to test the various different systems How to make changes and see the impact in real time Unless you've already got experience working on a moderately sized project like this, I think the onboarding course is a great next step. If you are more experienced and confident then I'd recommend just jumping into the code and trying to figure out how everything works. Regardless of your choice, I really hope that working with Varcade Games is a great learning experience and helps you grow as an engineer. Good luck! - Kev","title":"What do I do now?"},{"location":"internship/setup/environment_setup/intro/","text":"Introduction A Varcade Games development stack can be set up on Windows, Linux or MacOS. You may or may not have heard of Linux or MacOS. They are operating systems (OS). When you start up you computer you boot the operating system, which is what allows you to actually do things with the computer. Most people are familiar with Windows as it comes pre-installed on most PCs, but there are other options out there too - Linux being the main on. MacOS is the operating system that runs on Mac computers. In terms of effort, Linux is definitely the easiest environment to set up, followed by by MacOS. Windows is a bit more involved - but it's an upfront cost that you only need to pay once. This is why many software engineers actually prefer to use a Mac or a machine that runs Linux - they are more 'developer friendly' in many cases, especially for server side development. In general I would recommend working with Linux as it's an extremely valuable skill to have as a software engineer, but the choice is yours. If you are running Windows we will actually set up a kind of Linux on your machine during this course, so you will be using a Linux system, but from the comfort of your Windows environment. Hopefully this experience will be enough to make you take the plunge and switch over to using Linux full time. Follow the guide for whichever OS you are using to get setup: Linux Windows OSX Info If you've already got Docker set up and you know what you're doing you can skip straight to the Testing your setup page . Info Technically I should say GNU/Linux and not Linux when referring to this operating system - but this isn't the time or place to get into that.","title":"Overview"},{"location":"internship/setup/environment_setup/intro/#introduction","text":"A Varcade Games development stack can be set up on Windows, Linux or MacOS. You may or may not have heard of Linux or MacOS. They are operating systems (OS). When you start up you computer you boot the operating system, which is what allows you to actually do things with the computer. Most people are familiar with Windows as it comes pre-installed on most PCs, but there are other options out there too - Linux being the main on. MacOS is the operating system that runs on Mac computers. In terms of effort, Linux is definitely the easiest environment to set up, followed by by MacOS. Windows is a bit more involved - but it's an upfront cost that you only need to pay once. This is why many software engineers actually prefer to use a Mac or a machine that runs Linux - they are more 'developer friendly' in many cases, especially for server side development. In general I would recommend working with Linux as it's an extremely valuable skill to have as a software engineer, but the choice is yours. If you are running Windows we will actually set up a kind of Linux on your machine during this course, so you will be using a Linux system, but from the comfort of your Windows environment. Hopefully this experience will be enough to make you take the plunge and switch over to using Linux full time. Follow the guide for whichever OS you are using to get setup: Linux Windows OSX Info If you've already got Docker set up and you know what you're doing you can skip straight to the Testing your setup page . Info Technically I should say GNU/Linux and not Linux when referring to this operating system - but this isn't the time or place to get into that.","title":"Introduction"},{"location":"internship/setup/environment_setup/linux/","text":"Linux Docker You will need to install Docker Engine in order to run Varcade Games locally. Official instructions for your distro can be found here . Docker-Compose You will also need to install Docker Compose. You can follow the official instructions here . That's about it for your setup on Linux, now let's test it - head over to the guide for doing that .","title":"Linux"},{"location":"internship/setup/environment_setup/linux/#linux","text":"","title":"Linux"},{"location":"internship/setup/environment_setup/linux/#docker","text":"You will need to install Docker Engine in order to run Varcade Games locally. Official instructions for your distro can be found here .","title":"Docker"},{"location":"internship/setup/environment_setup/linux/#docker-compose","text":"You will also need to install Docker Compose. You can follow the official instructions here . That's about it for your setup on Linux, now let's test it - head over to the guide for doing that .","title":"Docker-Compose"},{"location":"internship/setup/environment_setup/osx/","text":"OSX Docker In order to run Varcade Games on your Mac you will need to install Docker for Mac. Follow the official guide to get it set up. Developer Tools You will also need some standard developer tools. To get these you can install XCode directly from the Apple app store, or you can download from the developer downloads (login required). If you've ever done any development on your Mac you've likely installed this stuff already. Git You will also need 'Git' (source control) for getting access to the code. Again, if you've done any development you likely have Git on your system already - but if not, don't worry - you can follow the official install instructions here . You can check if git is installed already by typing git --version in your terminal (to open your terminal press CMD + Space, then type terminal , then hit enter). You should see some output that looks like this: 1 git version 2.31.1 That's about it. Let's test our setup - head over to the guide for doing that .","title":"OSX"},{"location":"internship/setup/environment_setup/osx/#osx","text":"","title":"OSX"},{"location":"internship/setup/environment_setup/osx/#docker","text":"In order to run Varcade Games on your Mac you will need to install Docker for Mac. Follow the official guide to get it set up.","title":"Docker"},{"location":"internship/setup/environment_setup/osx/#developer-tools","text":"You will also need some standard developer tools. To get these you can install XCode directly from the Apple app store, or you can download from the developer downloads (login required). If you've ever done any development on your Mac you've likely installed this stuff already.","title":"Developer Tools"},{"location":"internship/setup/environment_setup/osx/#git","text":"You will also need 'Git' (source control) for getting access to the code. Again, if you've done any development you likely have Git on your system already - but if not, don't worry - you can follow the official install instructions here . You can check if git is installed already by typing git --version in your terminal (to open your terminal press CMD + Space, then type terminal , then hit enter). You should see some output that looks like this: 1 git version 2.31.1 That's about it. Let's test our setup - head over to the guide for doing that .","title":"Git"},{"location":"internship/setup/environment_setup/testing_your_setup/","text":"Testing your setup At this point you should have Docker up and running, which means you can now run the Docker image that was included in the zip you downloaded to begin with. Linux and MacOS Run the following command in your terminal: 1 docker --version If docker is up and running you should see some output similar to this: 1 Docker version 20 .10.11, build 485636f Windows On windows you will need to open Powershell, if it's not already open then run: 1 docker --version If docker is up and running you should see some output similar to this: 1 Docker version 20 .10.11, build 485636f If you did see this then congratulations! You've successfully setup your computer to be able to work on Varcade Games! If you did not see this, then it's time to start investigating - but don't worry, there is opportunity here. Learning how to deal with environment specific issues when setting up / working with a project is essential for every software engineer. If you can't get to the bottom of the issue yourself you can go ahead and create and issue on the Github Repo .","title":"Testing your setup"},{"location":"internship/setup/environment_setup/testing_your_setup/#testing-your-setup","text":"At this point you should have Docker up and running, which means you can now run the Docker image that was included in the zip you downloaded to begin with.","title":"Testing your setup"},{"location":"internship/setup/environment_setup/testing_your_setup/#linux-and-macos","text":"Run the following command in your terminal: 1 docker --version If docker is up and running you should see some output similar to this: 1 Docker version 20 .10.11, build 485636f","title":"Linux and MacOS"},{"location":"internship/setup/environment_setup/testing_your_setup/#windows","text":"On windows you will need to open Powershell, if it's not already open then run: 1 docker --version If docker is up and running you should see some output similar to this: 1 Docker version 20 .10.11, build 485636f If you did see this then congratulations! You've successfully setup your computer to be able to work on Varcade Games! If you did not see this, then it's time to start investigating - but don't worry, there is opportunity here. Learning how to deal with environment specific issues when setting up / working with a project is essential for every software engineer. If you can't get to the bottom of the issue yourself you can go ahead and create and issue on the Github Repo .","title":"Windows"},{"location":"internship/setup/environment_setup/windows/","text":"Preparing Windows for development To get your Windows environment we will do three things: Install WSL2 - Windows Subsystem for Linux. This allows you to run Linux from within Windows Install Docker for Windows - Docker is a virtualization based container management system. Install VSCode - VSCode is a popular code editor developed by Microsoft Info On a number of occasions throughout your Windows setup you will be asked to run an application as an administrator . To do this type the application's name (eg. 'notepad' or 'Powershell') into the Windows search bar, right-click the menu item that appears and select Run as administrator . Update Windows The first thing we will do is make sure our Windows system is up to date. Type updates in the Windows search bar and click the Check for updates option that appears. Install all system updates - hopefully your system is up to date already and there's nothing to do here. If you're not up to date you might have to sit through a few restarts. WSL 2 Next we need to install WSL 2, or Windows Subsystem for Linux . This basically allows us to run Linux directly within our Windows environment. There's a great guide to setting up WSL2 in the official Microsoft docs . Info The above guide will ask you to run commands in Windows Powershell . You will likely want to copy and paste these commands as they can be quite long. To paste any text that you have copied into powershell simply right-click within the Powershell window. Follow those steps before continuing here (up to install windows terminal ). You can pick whichever Linux distro you like, though I recommend Ubuntu 20.04 LTS if you're new to Linux. Ubuntu Setup Once that process is done we can start setting up our Linux environment - which is where we will run the actual Varcade Games project. If you correctly followed the Microsoft guide, you should already have your Linux terminal open, but if not open up the Ubuntu app (or whichever distro you installed) and get your user setup. To do this you can simply type Ubuntu in the Windows search bar, and select the app. You will be greeted by a terminal, which will prompt you to enter user information: While we're here we should also install Docker Compose - which is a tool that helps us manage Docker containers. Follow the official installation guide, but remember you are running this in your Linux terminal, so you need to select the Linux instructions. Official install guide . Docker Next install Docker for Windows . The default install configuration is fine for our needs, so just go with defaults - but make sure that the Install required Windows components for WSL 2 option is checked: Once the install is complete you will need to log out and back in again. Then Docker should start up automatically. It will offer you a tutorial... you can skip that, we can figure this out on our own. Info If you are running on a low powered device (limited memory in particular), you should create a .wslconfig file to limit the amount of resources that Docker uses. To do this simply put a file called .wslconfig in your Windows home ( C:\\Users\\<your user name> ) directory with the following values saved in the file: 1 2 3 [wsl2] memory=2gb processors=2 You can modify the above values as needed for your environment. VSCode and Git Next download and install VSCode (default settings are all fine). You will also need a Github account - so if you haven't got one you'll need to create one now. That's it for the installation part - most of our software dependencies are now sorted. To test that it's all working properly head over to the guide for doing that .","title":"Windows"},{"location":"internship/setup/environment_setup/windows/#preparing-windows-for-development","text":"To get your Windows environment we will do three things: Install WSL2 - Windows Subsystem for Linux. This allows you to run Linux from within Windows Install Docker for Windows - Docker is a virtualization based container management system. Install VSCode - VSCode is a popular code editor developed by Microsoft Info On a number of occasions throughout your Windows setup you will be asked to run an application as an administrator . To do this type the application's name (eg. 'notepad' or 'Powershell') into the Windows search bar, right-click the menu item that appears and select Run as administrator .","title":"Preparing Windows for development"},{"location":"internship/setup/environment_setup/windows/#update-windows","text":"The first thing we will do is make sure our Windows system is up to date. Type updates in the Windows search bar and click the Check for updates option that appears. Install all system updates - hopefully your system is up to date already and there's nothing to do here. If you're not up to date you might have to sit through a few restarts.","title":"Update Windows"},{"location":"internship/setup/environment_setup/windows/#wsl-2","text":"Next we need to install WSL 2, or Windows Subsystem for Linux . This basically allows us to run Linux directly within our Windows environment. There's a great guide to setting up WSL2 in the official Microsoft docs . Info The above guide will ask you to run commands in Windows Powershell . You will likely want to copy and paste these commands as they can be quite long. To paste any text that you have copied into powershell simply right-click within the Powershell window. Follow those steps before continuing here (up to install windows terminal ). You can pick whichever Linux distro you like, though I recommend Ubuntu 20.04 LTS if you're new to Linux.","title":"WSL 2"},{"location":"internship/setup/environment_setup/windows/#ubuntu-setup","text":"Once that process is done we can start setting up our Linux environment - which is where we will run the actual Varcade Games project. If you correctly followed the Microsoft guide, you should already have your Linux terminal open, but if not open up the Ubuntu app (or whichever distro you installed) and get your user setup. To do this you can simply type Ubuntu in the Windows search bar, and select the app. You will be greeted by a terminal, which will prompt you to enter user information: While we're here we should also install Docker Compose - which is a tool that helps us manage Docker containers. Follow the official installation guide, but remember you are running this in your Linux terminal, so you need to select the Linux instructions. Official install guide .","title":"Ubuntu Setup"},{"location":"internship/setup/environment_setup/windows/#docker","text":"Next install Docker for Windows . The default install configuration is fine for our needs, so just go with defaults - but make sure that the Install required Windows components for WSL 2 option is checked: Once the install is complete you will need to log out and back in again. Then Docker should start up automatically. It will offer you a tutorial... you can skip that, we can figure this out on our own. Info If you are running on a low powered device (limited memory in particular), you should create a .wslconfig file to limit the amount of resources that Docker uses. To do this simply put a file called .wslconfig in your Windows home ( C:\\Users\\<your user name> ) directory with the following values saved in the file: 1 2 3 [wsl2] memory=2gb processors=2 You can modify the above values as needed for your environment.","title":"Docker"},{"location":"internship/setup/environment_setup/windows/#vscode-and-git","text":"Next download and install VSCode (default settings are all fine). You will also need a Github account - so if you haven't got one you'll need to create one now. That's it for the installation part - most of our software dependencies are now sorted. To test that it's all working properly head over to the guide for doing that .","title":"VSCode and Git"},{"location":"internship/setup/varcade_games/adding_a_game/","text":"Adding a game to Varcade Games Navigate your browser to localhost:8000/admin . You should be greeted by a login page. Use the credentials that you provided in the early step where you ran ./manage.py createsuperuser . Once logged in you should see a menu that looks like this: Click the add link under the GAMES category. To start with we're going to add a game in the 'Coming Soon' state, which allows us to configure and view a game without actually needing to provide a playable game. Fill in all of the fields with dummy data, for example: Game id: test_game Name: My Game Desc: A great game that you should play! Client url: placeholder_url Cover art: <See below> Stats config: <See below> Game type: SinglePlayerOnly Game State: Coming Soon Adding 'Cover Art' and 'Stats config' There is some cover art we can use in the rps_game project. You will find this file in the game_rps project in the folder: game_rps/client/assets/exrps_cover.jpg . In that same directory there is also a file called exrps_stats.json , you will need to upload that file in the stats config section of the admin panel. On Windows This might be a bit confusing on Windows. The file we want to upload to our browser lives on our Ubuntu instance, so how do we actually access it from Windows? In VSCode you can right click the image and select reveal in file explorer . This will open up a window showing the folder that contains the file. At the top of the window is a path to the file: Once you click the path it will turn into a text field that you can copy and paste: Copy that path and then select the browse button in the admin interface. You can now paste the image page in the upload window that pops up and select the desired file: Hit the save button and you're done. Viewing the game All that's left is to head back over to localhost:8002 and check out the game! Still nothing exciting going on there because we can't actually play anything - but we have verified that the Game Portal is working correctly. And that's it - you've successfully setup Varcade Games, so I guess we should talk about what to do next...","title":"Adding a game"},{"location":"internship/setup/varcade_games/adding_a_game/#adding-a-game-to-varcade-games","text":"Navigate your browser to localhost:8000/admin . You should be greeted by a login page. Use the credentials that you provided in the early step where you ran ./manage.py createsuperuser . Once logged in you should see a menu that looks like this: Click the add link under the GAMES category. To start with we're going to add a game in the 'Coming Soon' state, which allows us to configure and view a game without actually needing to provide a playable game. Fill in all of the fields with dummy data, for example: Game id: test_game Name: My Game Desc: A great game that you should play! Client url: placeholder_url Cover art: <See below> Stats config: <See below> Game type: SinglePlayerOnly Game State: Coming Soon","title":"Adding a game to Varcade Games"},{"location":"internship/setup/varcade_games/adding_a_game/#adding-cover-art-and-stats-config","text":"There is some cover art we can use in the rps_game project. You will find this file in the game_rps project in the folder: game_rps/client/assets/exrps_cover.jpg . In that same directory there is also a file called exrps_stats.json , you will need to upload that file in the stats config section of the admin panel.","title":"Adding 'Cover Art' and 'Stats config'"},{"location":"internship/setup/varcade_games/adding_a_game/#on-windows","text":"This might be a bit confusing on Windows. The file we want to upload to our browser lives on our Ubuntu instance, so how do we actually access it from Windows? In VSCode you can right click the image and select reveal in file explorer . This will open up a window showing the folder that contains the file. At the top of the window is a path to the file: Once you click the path it will turn into a text field that you can copy and paste: Copy that path and then select the browse button in the admin interface. You can now paste the image page in the upload window that pops up and select the desired file: Hit the save button and you're done.","title":"On Windows"},{"location":"internship/setup/varcade_games/adding_a_game/#viewing-the-game","text":"All that's left is to head back over to localhost:8002 and check out the game! Still nothing exciting going on there because we can't actually play anything - but we have verified that the Game Portal is working correctly. And that's it - you've successfully setup Varcade Games, so I guess we should talk about what to do next...","title":"Viewing the game"},{"location":"internship/setup/varcade_games/get_the_code/","text":"Get the code All of the code for Varcade Games is available via Github, meaning it is available to you right now! Open up your terminal. If you're running Windows this will be the Ubuntu terminal that we created in the Windows setup (you can open it by typing Ubuntu in your search bar). Forking & Cloning At this point you have two options: Fork the repo Clone the repo Forking the repo means you'll create your own copy of the entire codebase within Github. This is worth doing if you plan to plan to actively work on Varcade Games and want to save any changes you make to the code. You will have your own space to work on - you will own it. Cloning creates a copy of the codebase on your local machine. You will not be able to push changes back to the main repository, but you can make whatever changes you want locally. I recommend forking Varcade Games. It takes zero effort and you will end up with your own copy of the code that evolves over time. It also makes it easier for you to keep your changes safe and backed up in Github. Local Setup Before we fork or clone anything, we should organize our local environment a bit. First, create a directory to put all of the code in: 1 2 3 cd ~/ mkdir code cd code Info The above commands should be run in your terminal. So in Windows you should be running this from your Linux app. For Linux and MacOS you can use your standard terminal. The above is three distinct commands: cd ~/ - This C hanges D irectory to your home directory, which is represented by ~/ mkdir code - This create a new directory named code cd code - This C hanges D irectory to your new directory Next we will use Git - our Source Control Management software of choice to actually download the code. Forking To create a fork you need to open up the project repository in Github . On the project page you will find a 'Fork' button at the top right of the screen: Click that button to have Github create a copy of the repo. That copy will be stored under your account. This is the project you will be working on from here on out. Once that's done you can head back over to your terminal and clone your repo to your local machine with the following command: 1 git clone https://github.com/<your user name>/varcade_games.git This will create a new directory called varcade_games in your current directory and that directory contains all of the code. Github will also provide a handy link for you to clone if you select the Code button from the UI: Info You can make your project private in the settings screen, which would mean that only you can view and make changes to it. If you do this you will need to set up SSH keys to privately manage the repo. Github provides documentation on how to do this. Cloning To simply clone the main code repositories, copy and run the following command in your terminal: 1 git clone https://github.com/Code-Over-Time/varcade_games.git This will create a new directory called varcade_games in your current directory and that directory contains all of the code. That's it. Working with the code Now that you've got the code on your computer you are ready to start working with it. You can use the editor/IDE of your choice, I won't judge. I used Sublime text and Vim to write all of this code. VSCode is popular with a lot of developers and is probably a good choice if you don't already have a preferred setup. On Windows Once the project is cloned you can do something pretty cool on Windows. Run the following command from your Ubuntu terminal (from the same directory you ran the clone command): 1 code . This is a special program in the Windows Ubuntu app that will open up VSCode (we installed this on a previous step) on your local machine, but connect it to the Ubuntu instance so that you can modify the code that we just cloned directly from Windows! Feel free to explore the code for a while before proceeding. There are detailed README files in each project folder and in all first level sub-folders that should help you understand what each of the different pieces is doing. Once you're ready to run the actual project, move on to the next section.","title":"Get the code"},{"location":"internship/setup/varcade_games/get_the_code/#get-the-code","text":"All of the code for Varcade Games is available via Github, meaning it is available to you right now! Open up your terminal. If you're running Windows this will be the Ubuntu terminal that we created in the Windows setup (you can open it by typing Ubuntu in your search bar).","title":"Get the code"},{"location":"internship/setup/varcade_games/get_the_code/#forking-cloning","text":"At this point you have two options: Fork the repo Clone the repo Forking the repo means you'll create your own copy of the entire codebase within Github. This is worth doing if you plan to plan to actively work on Varcade Games and want to save any changes you make to the code. You will have your own space to work on - you will own it. Cloning creates a copy of the codebase on your local machine. You will not be able to push changes back to the main repository, but you can make whatever changes you want locally. I recommend forking Varcade Games. It takes zero effort and you will end up with your own copy of the code that evolves over time. It also makes it easier for you to keep your changes safe and backed up in Github.","title":"Forking &amp; Cloning"},{"location":"internship/setup/varcade_games/get_the_code/#local-setup","text":"Before we fork or clone anything, we should organize our local environment a bit. First, create a directory to put all of the code in: 1 2 3 cd ~/ mkdir code cd code Info The above commands should be run in your terminal. So in Windows you should be running this from your Linux app. For Linux and MacOS you can use your standard terminal. The above is three distinct commands: cd ~/ - This C hanges D irectory to your home directory, which is represented by ~/ mkdir code - This create a new directory named code cd code - This C hanges D irectory to your new directory Next we will use Git - our Source Control Management software of choice to actually download the code.","title":"Local Setup"},{"location":"internship/setup/varcade_games/get_the_code/#forking","text":"To create a fork you need to open up the project repository in Github . On the project page you will find a 'Fork' button at the top right of the screen: Click that button to have Github create a copy of the repo. That copy will be stored under your account. This is the project you will be working on from here on out. Once that's done you can head back over to your terminal and clone your repo to your local machine with the following command: 1 git clone https://github.com/<your user name>/varcade_games.git This will create a new directory called varcade_games in your current directory and that directory contains all of the code. Github will also provide a handy link for you to clone if you select the Code button from the UI: Info You can make your project private in the settings screen, which would mean that only you can view and make changes to it. If you do this you will need to set up SSH keys to privately manage the repo. Github provides documentation on how to do this.","title":"Forking"},{"location":"internship/setup/varcade_games/get_the_code/#cloning","text":"To simply clone the main code repositories, copy and run the following command in your terminal: 1 git clone https://github.com/Code-Over-Time/varcade_games.git This will create a new directory called varcade_games in your current directory and that directory contains all of the code. That's it.","title":"Cloning"},{"location":"internship/setup/varcade_games/get_the_code/#working-with-the-code","text":"Now that you've got the code on your computer you are ready to start working with it. You can use the editor/IDE of your choice, I won't judge. I used Sublime text and Vim to write all of this code. VSCode is popular with a lot of developers and is probably a good choice if you don't already have a preferred setup.","title":"Working with the code"},{"location":"internship/setup/varcade_games/get_the_code/#on-windows","text":"Once the project is cloned you can do something pretty cool on Windows. Run the following command from your Ubuntu terminal (from the same directory you ran the clone command): 1 code . This is a special program in the Windows Ubuntu app that will open up VSCode (we installed this on a previous step) on your local machine, but connect it to the Ubuntu instance so that you can modify the code that we just cloned directly from Windows! Feel free to explore the code for a while before proceeding. There are detailed README files in each project folder and in all first level sub-folders that should help you understand what each of the different pieces is doing. Once you're ready to run the actual project, move on to the next section.","title":"On Windows"},{"location":"internship/setup/varcade_games/intro/","text":"Varcade Games Varcade Games is an on-line gaming portal. It's a place where single and multi player Javascript games are hosted and is made up of a number of interconnected components. This gaming portal provides 'hooks' so that other developers can build and embed games within the portal, like a built in matchmaker for multi-player games and leaderboard tracking. In order to work with Varcade Games you'll need to setup the following components: The main game portal website Client & server The Matchmaker A server we use to connect players The Game A single player and multi-player fighting game... of sorts The Game Server A server that is plugged into the matchmaker Server authoritative multi-player gaming The Stats Tracker A server we use to create leaderboards Prometheus & Grafana Metrics and graphs for monitoring the project Build tools The tools needed to build and run all of the above That might seem like a lot, but there are a bunch of handy tools at your disposal to make running all of this easy. So let's go get our hands on the code and get it running!","title":"Varcade Games"},{"location":"internship/setup/varcade_games/intro/#varcade-games","text":"Varcade Games is an on-line gaming portal. It's a place where single and multi player Javascript games are hosted and is made up of a number of interconnected components. This gaming portal provides 'hooks' so that other developers can build and embed games within the portal, like a built in matchmaker for multi-player games and leaderboard tracking. In order to work with Varcade Games you'll need to setup the following components: The main game portal website Client & server The Matchmaker A server we use to connect players The Game A single player and multi-player fighting game... of sorts The Game Server A server that is plugged into the matchmaker Server authoritative multi-player gaming The Stats Tracker A server we use to create leaderboards Prometheus & Grafana Metrics and graphs for monitoring the project Build tools The tools needed to build and run all of the above That might seem like a lot, but there are a bunch of handy tools at your disposal to make running all of this easy. So let's go get our hands on the code and get it running!","title":"Varcade Games"},{"location":"internship/setup/varcade_games/running_vcg/","text":"Building the applications From your terminal, open the build_tools directory: 1 cd varcade_games/build_tools Now run the following command: 1 echo \"ENV_CODE_OVER_TIME_ROOT=~/code/varcade_games\" > .env.local There should now be a new file in the build_tools directory called .env.local . This file tells the build scripts where the code is, so it's pretty important. Info The above commands assume that you put all of the project code in the ~/code directory, as directed earlier in the course. If you cloned the code to a different location you will need to update the path of the Varcade Games directory accordingly. Building Varcade Games Next we need to install an additional tool for building and running the project: Make - A standard tool for creating and running build scripts Windows (Ubuntu terminal) / Linux 1 sudo apt install make Info This command assumes you are running on Ubuntu, you will need to update to fit your distro if you are not running Ubuntu. MacOS On MacOS you should already have the developer tools installed from a previous step. This will include Make already so you should have nothing to do here. Docker Let's also make sure Docker is running, you can check this by running the command: 1 docker ps As long as you don't see an error you should be good to go. Windows On Windows it's worth double checking our Docker settings. Open Docker and open the setting screen to: Docker > Settings > Resources > WSL Integration > Enable integration with additional distros Make sure that Ubuntu-20.04 is checked in the Enable integration with additional distros section: Running the build Back in your terminal, run: 1 make build This will kick off a build of the various different applications. This will take a few minutes as all of the dependencies will need to download. Nearly there! Running the applications All we need to do now is run make start from the terminal. That will start up all of the applications and you can check their state by running make ps . If any of the services fail to start, run make start again (game-portal will likely fail to start as it depends on the DB starting up first). Configuring the site Before we can actually interact with Varcade Games we need to initialize the database. Run the following command to connect to the game-portal application: 1 docker exec -it game-portal bash Next run: 1 ./manage.py migrate You will see some output like this: Next run: 1 ./manage.py createsuperuser You will need to follow a few steps to create your admin user account for managing Varcade Games. Once that's done type exit and hit enter to get back to your Ubuntu terminal. We have one final thing to do - that is set up our local networking environment. Connecting to Varcade Games On Windows Open notepad as administrator. Then select File > Open and navigate to C:\\Windows\\System32\\drivers\\etc\\ and open the file called hosts . The directory may appear empty, so be sure to select all files from the drop down at the bottom right that says text files . Add the following line to the bottom of the file: 1 127 .0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local Save and close notepad. On Linux / MacOS Add the following line to the bottom of /etc/hosts : 1 127 .0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local The following command will take care of that for you: 1 sudo -- sh -c 'echo \"127.0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local\" >> /etc/hosts' Viewing the site Now, if you point your browser at localhost:8002 you should arrive at the landing page for Varcade Games . You can log in with the username and password you entered in the previous step when you ran ./manage.py createsuperuser . Unfortunately there won't be much to see. We need to add game...","title":"Running Varcade Games"},{"location":"internship/setup/varcade_games/running_vcg/#building-the-applications","text":"From your terminal, open the build_tools directory: 1 cd varcade_games/build_tools Now run the following command: 1 echo \"ENV_CODE_OVER_TIME_ROOT=~/code/varcade_games\" > .env.local There should now be a new file in the build_tools directory called .env.local . This file tells the build scripts where the code is, so it's pretty important. Info The above commands assume that you put all of the project code in the ~/code directory, as directed earlier in the course. If you cloned the code to a different location you will need to update the path of the Varcade Games directory accordingly.","title":"Building the applications"},{"location":"internship/setup/varcade_games/running_vcg/#building-varcade-games","text":"Next we need to install an additional tool for building and running the project: Make - A standard tool for creating and running build scripts","title":"Building Varcade Games"},{"location":"internship/setup/varcade_games/running_vcg/#windows-ubuntu-terminal-linux","text":"1 sudo apt install make Info This command assumes you are running on Ubuntu, you will need to update to fit your distro if you are not running Ubuntu.","title":"Windows (Ubuntu terminal) / Linux"},{"location":"internship/setup/varcade_games/running_vcg/#macos","text":"On MacOS you should already have the developer tools installed from a previous step. This will include Make already so you should have nothing to do here.","title":"MacOS"},{"location":"internship/setup/varcade_games/running_vcg/#docker","text":"Let's also make sure Docker is running, you can check this by running the command: 1 docker ps As long as you don't see an error you should be good to go.","title":"Docker"},{"location":"internship/setup/varcade_games/running_vcg/#windows","text":"On Windows it's worth double checking our Docker settings. Open Docker and open the setting screen to: Docker > Settings > Resources > WSL Integration > Enable integration with additional distros Make sure that Ubuntu-20.04 is checked in the Enable integration with additional distros section:","title":"Windows"},{"location":"internship/setup/varcade_games/running_vcg/#running-the-build","text":"Back in your terminal, run: 1 make build This will kick off a build of the various different applications. This will take a few minutes as all of the dependencies will need to download. Nearly there!","title":"Running the build"},{"location":"internship/setup/varcade_games/running_vcg/#running-the-applications","text":"All we need to do now is run make start from the terminal. That will start up all of the applications and you can check their state by running make ps . If any of the services fail to start, run make start again (game-portal will likely fail to start as it depends on the DB starting up first).","title":"Running the applications"},{"location":"internship/setup/varcade_games/running_vcg/#configuring-the-site","text":"Before we can actually interact with Varcade Games we need to initialize the database. Run the following command to connect to the game-portal application: 1 docker exec -it game-portal bash Next run: 1 ./manage.py migrate You will see some output like this: Next run: 1 ./manage.py createsuperuser You will need to follow a few steps to create your admin user account for managing Varcade Games. Once that's done type exit and hit enter to get back to your Ubuntu terminal. We have one final thing to do - that is set up our local networking environment.","title":"Configuring the site"},{"location":"internship/setup/varcade_games/running_vcg/#connecting-to-varcade-games","text":"","title":"Connecting to Varcade Games"},{"location":"internship/setup/varcade_games/running_vcg/#on-windows","text":"Open notepad as administrator. Then select File > Open and navigate to C:\\Windows\\System32\\drivers\\etc\\ and open the file called hosts . The directory may appear empty, so be sure to select all files from the drop down at the bottom right that says text files . Add the following line to the bottom of the file: 1 127 .0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local Save and close notepad.","title":"On Windows"},{"location":"internship/setup/varcade_games/running_vcg/#on-linux-macos","text":"Add the following line to the bottom of /etc/hosts : 1 127 .0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local The following command will take care of that for you: 1 sudo -- sh -c 'echo \"127.0.0.1 varcade.local api.varcade.local games.varcade.local matchmaker.varcade.local rps.varcade.local\" >> /etc/hosts'","title":"On Linux / MacOS"},{"location":"internship/setup/varcade_games/running_vcg/#viewing-the-site","text":"Now, if you point your browser at localhost:8002 you should arrive at the landing page for Varcade Games . You can log in with the username and password you entered in the previous step when you ran ./manage.py createsuperuser . Unfortunately there won't be much to see. We need to add game...","title":"Viewing the site"},{"location":"internship/tasks/overview/","text":"How It Works In this section you will find hands on tasks. Each task will include a 'tag' that you can create a new branch from in order to work on your task. For example, if a task requires that you use tag v0.0.1 then you must create your development branch from that tag as follows: 1 git checkout -b <New Branch Name> v0.0.1 Each Varcade Games tag represent a version of the overall project. We need to do this because the main branch of Varcade Games will be continually evolving, but we want to have a consistent snapshot of the project to ensure that everyone who is doing the tasks is working against the same code. This saves us having to update the tasks listed here as the codebase evolves. Note: You can work on all tasks with the same tag in the same branch. So, for example - all v0.0.1 tasks will require the v0.0.1 tag. So you can create one branch as follows: 1 git checkout -b development v0.0.1 Now the development branch will be your main branch and you can work on all v0.0.1 tasks in this branch. Experience Level Each task will have an associated experience level . This will give you an idea of how challenging the task will be, depending on how much experience you have working with Varcade Games. The levels are: Junior Mid Senior Principle Junior tasks tend to be small tweaks and bug fixes that are applied to isolated parts of the projects. For example changing some UI, or adding some additional logging to one of the server projects. Mid tasks are for people that have a good working knowledge of all of the various projects within Varcade Games. These may involve updating multiple projects, for example adding a new field to the website database, updating an API to include this new field and finally updating the UI to display this new field to the user. Senior tasks will usually include some sort of architectural considerations. For example, adding an entirely new feature to Varcade Games. This work will need deep thought and consideration about the far reaching consequences of the changes you are making. Principle tasks are the most technical advanced tasks. These may include profiling and optimization work and will require deeper understanding of the underlying concepts and design of the various libraries and applications used to build Varcade Games. Needless to say, you should complete all of the tasks at each level before proceeding to the next level. Info These levels mirror the titles you may expect to find in engineering organizations, and I have tried to set the content of the tasks according to what may be expected of engineers at each level.","title":"How It Works"},{"location":"internship/tasks/overview/#how-it-works","text":"In this section you will find hands on tasks. Each task will include a 'tag' that you can create a new branch from in order to work on your task. For example, if a task requires that you use tag v0.0.1 then you must create your development branch from that tag as follows: 1 git checkout -b <New Branch Name> v0.0.1 Each Varcade Games tag represent a version of the overall project. We need to do this because the main branch of Varcade Games will be continually evolving, but we want to have a consistent snapshot of the project to ensure that everyone who is doing the tasks is working against the same code. This saves us having to update the tasks listed here as the codebase evolves. Note: You can work on all tasks with the same tag in the same branch. So, for example - all v0.0.1 tasks will require the v0.0.1 tag. So you can create one branch as follows: 1 git checkout -b development v0.0.1 Now the development branch will be your main branch and you can work on all v0.0.1 tasks in this branch.","title":"How It Works"},{"location":"internship/tasks/overview/#experience-level","text":"Each task will have an associated experience level . This will give you an idea of how challenging the task will be, depending on how much experience you have working with Varcade Games. The levels are: Junior Mid Senior Principle Junior tasks tend to be small tweaks and bug fixes that are applied to isolated parts of the projects. For example changing some UI, or adding some additional logging to one of the server projects. Mid tasks are for people that have a good working knowledge of all of the various projects within Varcade Games. These may involve updating multiple projects, for example adding a new field to the website database, updating an API to include this new field and finally updating the UI to display this new field to the user. Senior tasks will usually include some sort of architectural considerations. For example, adding an entirely new feature to Varcade Games. This work will need deep thought and consideration about the far reaching consequences of the changes you are making. Principle tasks are the most technical advanced tasks. These may include profiling and optimization work and will require deeper understanding of the underlying concepts and design of the various libraries and applications used to build Varcade Games. Needless to say, you should complete all of the tasks at each level before proceeding to the next level. Info These levels mirror the titles you may expect to find in engineering organizations, and I have tried to set the content of the tasks according to what may be expected of engineers at each level.","title":"Experience Level"},{"location":"internship/tasks/junior/001_keyboard_login/","text":"Keyboard Shortcuts Category : Web Frontend Development Level: Junior Tag: v0.0.1 Description The current login / registration form implementation does not support submitting the form by hitting the return key. Players should be able to login / register as follows: Load page Keyboard focus should default to the email field Once email is filled out players can hit tab to move to the password field Once the password is filled out players should be able to hit return to log in Deliverable Update the game portal client so that: Keyboard focus will automatically be set to the email field of the login form when the homepage is loaded The login form is submitted when a player presses enter while keyboard focus is on the username or password field Note: The submit button will be disabled if the form fields contain invalid data, which should also be the case when return is hit on the keyboard The register form is submitted when a player presses enter while keyboard focus is on one of the registration fields Acceptance Criteria Hitting the return key on the keyboard must submit the game portal login form when either field has keyboard focus and both fields contain valid data Hitting the return key on the keyboard must submit the game portal registration form when any field has keyboard focus and all fields contain valid data The form is not submitted if invalid information has been entered (currently the submit button is disabled when this is the case) Task Tips! The login/register component is in website/client/src/components/wp-login-register.vue - all of the required changes will need to happen here.","title":"Keyboard Shortcuts"},{"location":"internship/tasks/junior/001_keyboard_login/#keyboard-shortcuts","text":"Category : Web Frontend Development Level: Junior Tag: v0.0.1","title":"Keyboard Shortcuts"},{"location":"internship/tasks/junior/001_keyboard_login/#description","text":"The current login / registration form implementation does not support submitting the form by hitting the return key. Players should be able to login / register as follows: Load page Keyboard focus should default to the email field Once email is filled out players can hit tab to move to the password field Once the password is filled out players should be able to hit return to log in","title":"Description"},{"location":"internship/tasks/junior/001_keyboard_login/#deliverable","text":"Update the game portal client so that: Keyboard focus will automatically be set to the email field of the login form when the homepage is loaded The login form is submitted when a player presses enter while keyboard focus is on the username or password field Note: The submit button will be disabled if the form fields contain invalid data, which should also be the case when return is hit on the keyboard The register form is submitted when a player presses enter while keyboard focus is on one of the registration fields","title":"Deliverable"},{"location":"internship/tasks/junior/001_keyboard_login/#acceptance-criteria","text":"Hitting the return key on the keyboard must submit the game portal login form when either field has keyboard focus and both fields contain valid data Hitting the return key on the keyboard must submit the game portal registration form when any field has keyboard focus and all fields contain valid data The form is not submitted if invalid information has been entered (currently the submit button is disabled when this is the case)","title":"Acceptance Criteria"},{"location":"internship/tasks/junior/001_keyboard_login/#task-tips","text":"The login/register component is in website/client/src/components/wp-login-register.vue - all of the required changes will need to happen here.","title":"Task Tips!"},{"location":"internship/tasks/junior/002_skip_cutscene/","text":"Skip Cutscenes Category : Web Frontend Development Level: Junior Tag: v0.0.1 Description Every time a player selects Single Player mode in Rock Paper Scissors Apocalypse the 'lore' scene is loaded, which shows the back story. After reading this once players don't need to see it again, so once the skip it once (by hitting the fast forward button) we don't need to show it again. Deliverable Update the RPS game client so that it progresses directly from the VS scene to the single player character select scene after the intro lore has been skipped once already. Acceptance Criteria The player goes directly to the character select after selecting single player, if they've manually skipped the lore scene once before This behavior must persist across multiple play sessions - once the scene is skipped it is never seen again (unless the user clears their browser data). Note: The behavior does not need to persist across different browsers Update client README to include information about this behavior Task Tips! You will need to look at this line: this.scene.start('StoryIntroScene', { gameInterface: gameInterface }) in game_rps/client/src/scenes/main_menu.js You can use localstorage to store whether or not the lore scene should be skipped You can work with the game client and server directly without having to run through the actual Varcade Games website! Once you have the project running, simply point your browser at localhost:8090 to access the dev game client. Any changes you make to the client code will cause this dev client to reload automatically - so you can develop in real time!","title":"Skip, Skip Skip"},{"location":"internship/tasks/junior/002_skip_cutscene/#skip-cutscenes","text":"Category : Web Frontend Development Level: Junior Tag: v0.0.1","title":"Skip Cutscenes"},{"location":"internship/tasks/junior/002_skip_cutscene/#description","text":"Every time a player selects Single Player mode in Rock Paper Scissors Apocalypse the 'lore' scene is loaded, which shows the back story. After reading this once players don't need to see it again, so once the skip it once (by hitting the fast forward button) we don't need to show it again.","title":"Description"},{"location":"internship/tasks/junior/002_skip_cutscene/#deliverable","text":"Update the RPS game client so that it progresses directly from the VS scene to the single player character select scene after the intro lore has been skipped once already.","title":"Deliverable"},{"location":"internship/tasks/junior/002_skip_cutscene/#acceptance-criteria","text":"The player goes directly to the character select after selecting single player, if they've manually skipped the lore scene once before This behavior must persist across multiple play sessions - once the scene is skipped it is never seen again (unless the user clears their browser data). Note: The behavior does not need to persist across different browsers Update client README to include information about this behavior","title":"Acceptance Criteria"},{"location":"internship/tasks/junior/002_skip_cutscene/#task-tips","text":"You will need to look at this line: this.scene.start('StoryIntroScene', { gameInterface: gameInterface }) in game_rps/client/src/scenes/main_menu.js You can use localstorage to store whether or not the lore scene should be skipped You can work with the game client and server directly without having to run through the actual Varcade Games website! Once you have the project running, simply point your browser at localhost:8090 to access the dev game client. Any changes you make to the client code will cause this dev client to reload automatically - so you can develop in real time!","title":"Task Tips!"},{"location":"internship/tasks/junior/003_build_tools/","text":"Listing Images Category : Developer / Build Tools Level: Junior Tag: v0.0.1 Description There are a few Make commands that you have already used and will be using all the time: make ps make ls make build make start make restart make logs This covers a lot of what we need to do when working on Varcade Games, but there's another command that would be useful. Sometimes you need to access a running docker image using your command line interface. In fact, you've done this already as part of the development environment setup, when you had to initialize the game database. The command you ran looked like this: 1 docker exec -it game-portal bash What this command does is connect to a virtual machine that is running inside Docker. In this case it connected to the game portal - which is the server that runs the main Varcade Games website. This is a bit of a tedious command to have to write every time you want to connect to one of your Docker images. It would be great if we had a convenient make command to do this, just like we have convenient commands to build, start and run our services. Something like this: 1 make shell a = game-portal Deliverable Add a new makefile command that connects to a Docker image shell. This make command will mostly consist of the command listed above: docker exec -it game-portal bash - however we don't just want the 'game-portal'. We might want to connect to the matchmaker image for example, or game-rps . The format should be similar to existing commands. For example to view logs for a service the command is: 1 make logs a = game-portal So to view images for a server the command should be: 1 make shell a = game-portal You should be able to copy and existing command and make the necessary change to get the above results. Acceptance Criteria You must be able to view all of your docker images with the command make images You must be able to view all images for a specific service with a command like make images a=game-portal or make images a=matchmaker Task Tips! The Makefile is in the build_tools directory You can just copy and modify one of the existing commands (check out the 'snapshot_game_portal_db' as an example. It just runs a command, like what we need to do here)","title":"Build Tools"},{"location":"internship/tasks/junior/003_build_tools/#listing-images","text":"Category : Developer / Build Tools Level: Junior Tag: v0.0.1","title":"Listing Images"},{"location":"internship/tasks/junior/003_build_tools/#description","text":"There are a few Make commands that you have already used and will be using all the time: make ps make ls make build make start make restart make logs This covers a lot of what we need to do when working on Varcade Games, but there's another command that would be useful. Sometimes you need to access a running docker image using your command line interface. In fact, you've done this already as part of the development environment setup, when you had to initialize the game database. The command you ran looked like this: 1 docker exec -it game-portal bash What this command does is connect to a virtual machine that is running inside Docker. In this case it connected to the game portal - which is the server that runs the main Varcade Games website. This is a bit of a tedious command to have to write every time you want to connect to one of your Docker images. It would be great if we had a convenient make command to do this, just like we have convenient commands to build, start and run our services. Something like this: 1 make shell a = game-portal","title":"Description"},{"location":"internship/tasks/junior/003_build_tools/#deliverable","text":"Add a new makefile command that connects to a Docker image shell. This make command will mostly consist of the command listed above: docker exec -it game-portal bash - however we don't just want the 'game-portal'. We might want to connect to the matchmaker image for example, or game-rps . The format should be similar to existing commands. For example to view logs for a service the command is: 1 make logs a = game-portal So to view images for a server the command should be: 1 make shell a = game-portal You should be able to copy and existing command and make the necessary change to get the above results.","title":"Deliverable"},{"location":"internship/tasks/junior/003_build_tools/#acceptance-criteria","text":"You must be able to view all of your docker images with the command make images You must be able to view all images for a specific service with a command like make images a=game-portal or make images a=matchmaker","title":"Acceptance Criteria"},{"location":"internship/tasks/junior/003_build_tools/#task-tips","text":"The Makefile is in the build_tools directory You can just copy and modify one of the existing commands (check out the 'snapshot_game_portal_db' as an example. It just runs a command, like what we need to do here)","title":"Task Tips!"},{"location":"internship/tasks/junior/004_error_handling/","text":"Error Handling Category : Python Backend Development Level: Junior Tag: v0.0.1 Description When a player loads a game in Varcade Games, the web server ( website/server ) will send a couple of requests to the stats server ( stats_tracker/ ) to fetch the leaderboard and player stats for that game. If you open up website/server/game_portal/game_portal/games/services.py you will find the code that sends these requests. The problem with this code is that it does not handle error scenarios. If the request fails for any reason and an exception is thrown it will not be handled gracefully and the server will return an uninformative 500 error. Both the get_leaderboard and the get_player_stats_for_game functions need to be updated to handle error cases. If an error occurs it should be captured, and a helpful error message should be logged. Also, an error in either of these requests should not cause the whole request to fail. Instead the API should be updated so that it returns an empty response for the leaderboard or player stats (or both - depending on what failed). The API should however indicate that an error occurred so that the client can display an error if it wants. Deliverable Updated website server code that: Better handles cases where an error occurs when sending a request to the stats service. API returns empty result for either leaderboard or player stats (or both) if there is a request errors API is updated to include a flag that notifies the client that an error occurred Unit / integration tests are updated to verify the changes Acceptance Criteria The stats service can go offline without affecting the Varcade Games website The Varcade Games client is notified when leaderboard/player stat data is not returned Task Tips! When working on a task like this it is always worth reproducing the issue first. You should try and force the error scenario so you understand exactly what is happening currently, before making any changes. You can stop the stats server manually using the make commands in build tools - this will cause both requests to error, but you will still need to figure out a way to test what happens when one request errors out but the other doesn't","title":"Error Handling"},{"location":"internship/tasks/junior/004_error_handling/#error-handling","text":"Category : Python Backend Development Level: Junior Tag: v0.0.1","title":"Error Handling"},{"location":"internship/tasks/junior/004_error_handling/#description","text":"When a player loads a game in Varcade Games, the web server ( website/server ) will send a couple of requests to the stats server ( stats_tracker/ ) to fetch the leaderboard and player stats for that game. If you open up website/server/game_portal/game_portal/games/services.py you will find the code that sends these requests. The problem with this code is that it does not handle error scenarios. If the request fails for any reason and an exception is thrown it will not be handled gracefully and the server will return an uninformative 500 error. Both the get_leaderboard and the get_player_stats_for_game functions need to be updated to handle error cases. If an error occurs it should be captured, and a helpful error message should be logged. Also, an error in either of these requests should not cause the whole request to fail. Instead the API should be updated so that it returns an empty response for the leaderboard or player stats (or both - depending on what failed). The API should however indicate that an error occurred so that the client can display an error if it wants.","title":"Description"},{"location":"internship/tasks/junior/004_error_handling/#deliverable","text":"Updated website server code that: Better handles cases where an error occurs when sending a request to the stats service. API returns empty result for either leaderboard or player stats (or both) if there is a request errors API is updated to include a flag that notifies the client that an error occurred Unit / integration tests are updated to verify the changes","title":"Deliverable"},{"location":"internship/tasks/junior/004_error_handling/#acceptance-criteria","text":"The stats service can go offline without affecting the Varcade Games website The Varcade Games client is notified when leaderboard/player stat data is not returned","title":"Acceptance Criteria"},{"location":"internship/tasks/junior/004_error_handling/#task-tips","text":"When working on a task like this it is always worth reproducing the issue first. You should try and force the error scenario so you understand exactly what is happening currently, before making any changes. You can stop the stats server manually using the make commands in build tools - this will cause both requests to error, but you will still need to figure out a way to test what happens when one request errors out but the other doesn't","title":"Task Tips!"},{"location":"internship/tasks/junior/005_stats_ui_design/","text":"Stats UI Design Category : Web Frontend Development Level: Junior Tag: v0.0.1 Description When you load a game in the Varcade Games web client it will display some multi-player stats for the currently logged in player (or a message telling them there are no stats if they have yet to play). This UI is pretty boring as it stands - it simply displays a bulleted list of stats: We need to dress this UI up a little bit, make it more interesting for the user. You have creative control on this task - you are free to make this piece of UI more interesting however you please. Maybe a table would be a better way to show this data? Or try aligning the numbers to the right so that they all line up and are easier to read. Maybe a different icon instead of the single bullet (like a game controller? We already use fontawesome in the project, which has plenty of icons to play with). Deliverable Updated player stats UI in the Varcade Games web client This is a purely visual change Acceptance Criteria The stats UI has been updated and is more visually appealing (to you at least) Task Tips! In can be interesting to challenge your own creativity - software engineering doesn't have to be all technical all the time, explore creating something. Think about UI and user experience. What looks good to you? Will it look good to other people? Even if front end design is not all that interesting to you it is worth experiencing so that at the very least you can be more empathetic towards the designers you will likely end up working with some day. This component is located in website/client/src/components/wp-player-stats.vue Remember that this same UI is displayed for all games - so any visual changes that are specific to a single game will need to include server side work.","title":"Stats UI Design"},{"location":"internship/tasks/junior/005_stats_ui_design/#stats-ui-design","text":"Category : Web Frontend Development Level: Junior Tag: v0.0.1","title":"Stats UI Design"},{"location":"internship/tasks/junior/005_stats_ui_design/#description","text":"When you load a game in the Varcade Games web client it will display some multi-player stats for the currently logged in player (or a message telling them there are no stats if they have yet to play). This UI is pretty boring as it stands - it simply displays a bulleted list of stats: We need to dress this UI up a little bit, make it more interesting for the user. You have creative control on this task - you are free to make this piece of UI more interesting however you please. Maybe a table would be a better way to show this data? Or try aligning the numbers to the right so that they all line up and are easier to read. Maybe a different icon instead of the single bullet (like a game controller? We already use fontawesome in the project, which has plenty of icons to play with).","title":"Description"},{"location":"internship/tasks/junior/005_stats_ui_design/#deliverable","text":"Updated player stats UI in the Varcade Games web client This is a purely visual change","title":"Deliverable"},{"location":"internship/tasks/junior/005_stats_ui_design/#acceptance-criteria","text":"The stats UI has been updated and is more visually appealing (to you at least)","title":"Acceptance Criteria"},{"location":"internship/tasks/junior/005_stats_ui_design/#task-tips","text":"In can be interesting to challenge your own creativity - software engineering doesn't have to be all technical all the time, explore creating something. Think about UI and user experience. What looks good to you? Will it look good to other people? Even if front end design is not all that interesting to you it is worth experiencing so that at the very least you can be more empathetic towards the designers you will likely end up working with some day. This component is located in website/client/src/components/wp-player-stats.vue Remember that this same UI is displayed for all games - so any visual changes that are specific to a single game will need to include server side work.","title":"Task Tips!"},{"location":"internship/tasks/junior/006_leaderboard_ui_design/","text":"","title":"006 leaderboard ui design"},{"location":"internship/tasks/mid/001_game_settings/","text":"Settings Menu Category : Web Frontend Development Level: Mid Tag: v0.0.1 Description In the Rock, Paper, Scissors Apocalypse client the main menu currently displays two menu options (single and multi player) as well as two settings buttons. These buttons enable and disable music and sound effects in the game. This setup is not ideal as we will likely want to add additional settings in the future and this will create a cluttered UI. For example we may want to add settings that skip cut scenes or increase/decrease game speed in single player mode. With the current UI this would result in a total of 4 settings buttons on the main menu, the function of which would be difficult to communicate to the player. What we want to do instead is have a single 'settings' button on the main menu. When the user clicks it a pop up window is displayed (this type of window is often called a 'Model'). That settings window should display the various game settings - currently limited to enable/disable music & sound effects. Deliverable Update the Rock, Paper, Scissors Apocalypse game client so that: There is a settings menu button on the main menu Clicking the settings menu button open a modal popup with options to enable/disable music and sound effects Setting selections are persisted locally in the users browser Acceptance Criteria The main menu scene has a single settings button Clicking the settings button opens a modal window in game and displays buttons for enabling disabling music and sound effects If a player refreshes the page, or closes and reopens the browser their setting selections should be preserved Task Tips! There is already a generic settings icon in game_rps/client/src/assets/packed_textures/global.png that can be used There is already logic for persisting data, see `game_rps/client/src/game_data/save_data.js You can design the modal settings window yourself - using icons or not.","title":"Settings Menu"},{"location":"internship/tasks/mid/001_game_settings/#settings-menu","text":"Category : Web Frontend Development Level: Mid Tag: v0.0.1","title":"Settings Menu"},{"location":"internship/tasks/mid/001_game_settings/#description","text":"In the Rock, Paper, Scissors Apocalypse client the main menu currently displays two menu options (single and multi player) as well as two settings buttons. These buttons enable and disable music and sound effects in the game. This setup is not ideal as we will likely want to add additional settings in the future and this will create a cluttered UI. For example we may want to add settings that skip cut scenes or increase/decrease game speed in single player mode. With the current UI this would result in a total of 4 settings buttons on the main menu, the function of which would be difficult to communicate to the player. What we want to do instead is have a single 'settings' button on the main menu. When the user clicks it a pop up window is displayed (this type of window is often called a 'Model'). That settings window should display the various game settings - currently limited to enable/disable music & sound effects.","title":"Description"},{"location":"internship/tasks/mid/001_game_settings/#deliverable","text":"Update the Rock, Paper, Scissors Apocalypse game client so that: There is a settings menu button on the main menu Clicking the settings menu button open a modal popup with options to enable/disable music and sound effects Setting selections are persisted locally in the users browser","title":"Deliverable"},{"location":"internship/tasks/mid/001_game_settings/#acceptance-criteria","text":"The main menu scene has a single settings button Clicking the settings button opens a modal window in game and displays buttons for enabling disabling music and sound effects If a player refreshes the page, or closes and reopens the browser their setting selections should be preserved","title":"Acceptance Criteria"},{"location":"internship/tasks/mid/001_game_settings/#task-tips","text":"There is already a generic settings icon in game_rps/client/src/assets/packed_textures/global.png that can be used There is already logic for persisting data, see `game_rps/client/src/game_data/save_data.js You can design the modal settings window yourself - using icons or not.","title":"Task Tips!"},{"location":"internship/tasks/principle/001_async_node/","text":"Async Node COMING SOON","title":"Async Game Server"},{"location":"internship/tasks/principle/001_async_node/#async-node","text":"COMING SOON","title":"Async Node"},{"location":"internship/tasks/senior/000_per_round_stats/","text":"Per Round Stats Category : Fullstack Development Level: Senior Tag: v0.0.1 Description When you load a game in the Varcade Games web client it will display a leaderboard and some multi-player stats for the currently logged in player. Currently the multiplayer stats sections displays the following stats: Games played Games won Games lost Number of times the player selected Rock Number of times the player selected Paper Number of times the player selected Scissors Number of times the player selected nothing We would like to add some additional stats here. Specifically we would like to track the number of rounds won/lost. Each individual game of Rock Paper Scissors can have a max of 5 rounds (if each player wins 2 rounds and then one player wins the final round to take the match). Deliverable Update the Rock Paper Scissors game server so that: It emits an event every time a player wins or loses a round Update the Stats Tracker so that: This new stat is tracked and stored The new stats are returned from the stats API Update the Varcade Games web client so that: This new stat is displayed in the UI Acceptance Criteria Two new stats are visible in the Varcade Games UI These new 'rounds won' and 'rounds lost' stats update after a multi-player game has been played Unit tests and integration tests updated on the stats tracker, rps game server and Varcade Games web server Task Tips! This is a full feature that touches three distinct sections of the project - you will want to test each of the changes independently and all together as a single feature. This can be one of the more challenging parts of working on a distributed system.","title":"Per Round Stats"},{"location":"internship/tasks/senior/000_per_round_stats/#per-round-stats","text":"Category : Fullstack Development Level: Senior Tag: v0.0.1","title":"Per Round Stats"},{"location":"internship/tasks/senior/000_per_round_stats/#description","text":"When you load a game in the Varcade Games web client it will display a leaderboard and some multi-player stats for the currently logged in player. Currently the multiplayer stats sections displays the following stats: Games played Games won Games lost Number of times the player selected Rock Number of times the player selected Paper Number of times the player selected Scissors Number of times the player selected nothing We would like to add some additional stats here. Specifically we would like to track the number of rounds won/lost. Each individual game of Rock Paper Scissors can have a max of 5 rounds (if each player wins 2 rounds and then one player wins the final round to take the match).","title":"Description"},{"location":"internship/tasks/senior/000_per_round_stats/#deliverable","text":"Update the Rock Paper Scissors game server so that: It emits an event every time a player wins or loses a round Update the Stats Tracker so that: This new stat is tracked and stored The new stats are returned from the stats API Update the Varcade Games web client so that: This new stat is displayed in the UI","title":"Deliverable"},{"location":"internship/tasks/senior/000_per_round_stats/#acceptance-criteria","text":"Two new stats are visible in the Varcade Games UI These new 'rounds won' and 'rounds lost' stats update after a multi-player game has been played Unit tests and integration tests updated on the stats tracker, rps game server and Varcade Games web server","title":"Acceptance Criteria"},{"location":"internship/tasks/senior/000_per_round_stats/#task-tips","text":"This is a full feature that touches three distinct sections of the project - you will want to test each of the changes independently and all together as a single feature. This can be one of the more challenging parts of working on a distributed system.","title":"Task Tips!"},{"location":"internship/tasks/senior/001_deduplication/","text":"De-duplication Category : Backend Development Level: Senior Tag: v0.0.1 Description The Matchmaker and Stats Tracker projects are quite similar in how they operate. Both are web servers that use Flask. Both store data in Redis. And both also have a background process that runs independently of the web server, processing data in the background. Currently both projects actually use the exact same code to run their background processes - however is code is duplicated across both projects, which is a problem. If we want to change this code we have to do it in two places, which results in additional development overhead and can lead to inconsistencies (imagine if you make a change in one place but forget to update the other, resulting in different behaviour from what you thought was the same code!). We need to extract this code out of both the matchmaker and stat tracker projects, create a library from it and then use that library in both projects. This way if we need to make changes to this code we only need to do it once, and then run that code in both projects. The code in question exists in: matchmaker/matchmaker/workers/worker_manager.py stats_tracker/stats_tracker/workers/worker_manager.py If you open both those files you should find them to be exactly the same. Deliverable A new Python library that contains the worker_manager code that is currently duplicated in both the matchmaker and stats_tracker projects. This library should also include tests (there are existing tests for the worker manager). Updated matchmaker project that: Has a dependency on your new library Updated stats_tracker project that: Has a dependency on your new library Updated build scripts to ensure the new library is loaded correctly as a dependency when building new docker images. Acceptance Criteria Varcade Games must work exactly the same as it did before, end to end - but using a shared library for the worker process, not code duplicated in two places. Task Tips! You will sometimes find code duplication like this in real world projects. Sometimes it's done in an attempt to save some time, but in the long run it will almost always end up costing far more time in maintenance overhead You will need to create a Python library to solve this problem - you will be able to find plenty of resources online that explain exactly how to do this. The first step will be taking this duplicate file and putting it in a new folder at the root of the project (ie. in the varcade_games folder). You can name this folder whatever you want, but it should be somewhat descriptive of the functionality of the code. There are a number of ways you can handle including your new library in the matchmaker / stats tracker projects. You could create an 'artifact' that lives in Github that is downloaded and installed like the rest of your Python dependencies. You could also just update the local build scripts to include the dependency from the local file system. There is actually an example of sharing code like this already in Varcade Games. The game engine for Rock, Paper, Scissors Apocalypse is shared between both the client and the server. See game_rps/game_engine and how it is integrated in both the client and server projects.","title":"De-duplication"},{"location":"internship/tasks/senior/001_deduplication/#de-duplication","text":"Category : Backend Development Level: Senior Tag: v0.0.1","title":"De-duplication"},{"location":"internship/tasks/senior/001_deduplication/#description","text":"The Matchmaker and Stats Tracker projects are quite similar in how they operate. Both are web servers that use Flask. Both store data in Redis. And both also have a background process that runs independently of the web server, processing data in the background. Currently both projects actually use the exact same code to run their background processes - however is code is duplicated across both projects, which is a problem. If we want to change this code we have to do it in two places, which results in additional development overhead and can lead to inconsistencies (imagine if you make a change in one place but forget to update the other, resulting in different behaviour from what you thought was the same code!). We need to extract this code out of both the matchmaker and stat tracker projects, create a library from it and then use that library in both projects. This way if we need to make changes to this code we only need to do it once, and then run that code in both projects. The code in question exists in: matchmaker/matchmaker/workers/worker_manager.py stats_tracker/stats_tracker/workers/worker_manager.py If you open both those files you should find them to be exactly the same.","title":"Description"},{"location":"internship/tasks/senior/001_deduplication/#deliverable","text":"A new Python library that contains the worker_manager code that is currently duplicated in both the matchmaker and stats_tracker projects. This library should also include tests (there are existing tests for the worker manager). Updated matchmaker project that: Has a dependency on your new library Updated stats_tracker project that: Has a dependency on your new library Updated build scripts to ensure the new library is loaded correctly as a dependency when building new docker images.","title":"Deliverable"},{"location":"internship/tasks/senior/001_deduplication/#acceptance-criteria","text":"Varcade Games must work exactly the same as it did before, end to end - but using a shared library for the worker process, not code duplicated in two places.","title":"Acceptance Criteria"},{"location":"internship/tasks/senior/001_deduplication/#task-tips","text":"You will sometimes find code duplication like this in real world projects. Sometimes it's done in an attempt to save some time, but in the long run it will almost always end up costing far more time in maintenance overhead You will need to create a Python library to solve this problem - you will be able to find plenty of resources online that explain exactly how to do this. The first step will be taking this duplicate file and putting it in a new folder at the root of the project (ie. in the varcade_games folder). You can name this folder whatever you want, but it should be somewhat descriptive of the functionality of the code. There are a number of ways you can handle including your new library in the matchmaker / stats tracker projects. You could create an 'artifact' that lives in Github that is downloaded and installed like the rest of your Python dependencies. You could also just update the local build scripts to include the dependency from the local file system. There is actually an example of sharing code like this already in Varcade Games. The game engine for Rock, Paper, Scissors Apocalypse is shared between both the client and the server. See game_rps/game_engine and how it is integrated in both the client and server projects.","title":"Task Tips!"},{"location":"reading_material/coding/","text":"In this section we will talk about code. This will include: Basics Programming languages Syntax Design patterns Refactoring Debugging Data structures Algorithms Data modelling And much more... Stay tuned for more!","title":"Introduction"},{"location":"reading_material/coding/frameworks/","text":"Frameworks","title":"Frameworks"},{"location":"reading_material/coding/frameworks/#frameworks","text":"","title":"Frameworks"},{"location":"reading_material/coding/languages/","text":"What language should I learn? What programming language should I learn first? This is possibly the most common question I see from beginners. I also see that question's cousin quite a bit: What is the best programming language for beginners. And like most questions, the right but unsatisfying answer is it depends . What does it depend on? It depends on a lot of things. On you. On your goals and interests. On your knowledge of and experience with computers. Maybe you're passionate about the Web and want to spend the rest of your life building web sites that users love using. Or maybe you want to be a game developer, so you plan to create stunningly realistic 3D graphics simulations. Perhaps AI and Machine Learning tickle your fancy. Depending on your interests, like in the above example, I might recommend a completely different path, which is why what programming language should I learn first is a difficult question to answer. Regardless of all of that, however, there are some pieces of advice that I'd give to anyone, regardless of their goals and interests. Fundamentals Focus on the fundamentals. People say this all the time - and it seems to me to be decent advice in all things. After all, if you can't do the fundamentals well, what hope have you got doing more complex things? But this statement does beg the question: \"What are the fundamentals?\" And depending on who you ask you might get a different answer. This is partly because we tend to think of programming, computer science, software engineering, web development etc... as all kind of being the same thing, when really they are different. So lets start with some definitions: Computer Science - The study of computation and computer technology, hardware, and software. Programming - The process of designing, writing, testing, debugging, and maintaining the source code of computer programs. Software Engineering - The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software, and the study of these approaches. That is the application of engineering to software. Web Development - Building, creating, and maintaining websites. It includes aspects such as web design , web publishing , web programming, and database management. So as you can see there are some differences. Some are subtle, like the difference between programming and software engineering. Programming is definitely a part of software engineering, it's how we create software in the first place. But software engineering is more than just programming. Computer science is very much concerned with the hardware and low level details of how a computer works, but web development is more focused on what a web browser can do, rather than what the computer can do. Web development could be considered a specialization of software engineering and also requires programming. The waters here appear pretty muddy, but these distinctions are important as they will impact where you focus your energy. Let's get back to the fundamentals. I think it's worth defining some fundamentals for each, but it's important to note that different people may have different opinions on this, and what follows is just my opinion. Computer Science These are all low level topics and I think most programmers should endeavor to get at least a basic understanding of most of them. If you want to work on low level software like operating systems, databases, embedded systems or game engines you will need a good understanding of all of these. Hardware design - how CPUs, RAM, graphics cards etc... actually work, the electronics Logic & Binary arithmetic - understanding binary and logic, and how both relate to design computer hardware and software Data structures & Algorithms - efficiently operating on data, vital for computer performance (in fact alot of the progress around making computers faster comes from the creation of more efficient algorithms) Computational complexity - how to we quantify how efficient and algorithm is Compiler design - writing code to generate code that machines understand I have highlighted Data Structures and Algorithms and Computational Complexity here, as I think these are the most important topics for generalists to have a good understanding of. Programming When it comes to programming, actually creating a piece of functionality within a piece of software, this is my list of important fundamentals. This list is geared much more towards concepts that help create clean code that is maintainable and extensible. Logic & Control flow - controlling how, when and how many times various parts of your code are actually executed (think if statements and loops) Standard library usage - most programming languages come with a set of libraries that do common things (like working with dates and time). Use and learn the std lib for your chosen language, they will have thought more about these things and done it better than you would Memory management - yes, even in memory managed languages Data modelling - how do you structure data in a way that it is efficient to create, store and manipulate it Abstraction - more on this below Modularity - more on this below Testing - writing code to test your code, you should start doing this on day one Refactoring - more on this below Profiling / performance analysis - understanding how efficient your code is and what you can do to get rid of bottlenecks I've highlighted the three topics that I think are some of the more important but often less discussed topics when it comes to programming. Abstraction is about taking complexity and representing it in a way that is easier to work with. Functions and classes are where you usually see complexity abstracted away. For example, creating an algorithm that rotates objects in 3D space can be complex, but calling a function called rotate() isn't complex at all. When you write code you want to do so in a way that you abstract the complexity away as much as possible. It will still be in there - but it shouldn't be constantly in your face. Modularity can be defined as Designed with standardized units or dimensions, as for easy assembly and repair or flexible arrangement and use . I like this definition. Code should be written in a way that you can take it apart, rearrange it and isolate pieces for functionality for testing. Again this can be achieved by good use of functions, classes, structs and creation of libraries. Refactoring is one of the more important topics in programming that I don't think gets anywhere near enough time and attention, especially with beginners. When you write a piece of code you will probably not get it 'right' the first time. It will likely be more verbose than it needs to be, not quite as performant, readable or extensible as it should be either. Writing a piece of code can be thought of as a discovery process. Once you have something working you have discovered how to do it - the next step is to refine it. Refactoring is that refinement and is something you should be doing constantly. A codebase evolves and changes over time - the code you wrote yesterday, last week or last year is not immune to that change, and you should make time for it. Software Engineering Here we venture much more into the business side of things. How do we actually deliver, operate and maintain software. I've heard software engineering be defined as 'programming integrated over time'. Meaning that programming is one thing, working on code that needs to last for years, that other programmers, users and businesses depend on is another. System analysis - looking at a problem or real world system and understanding the various modes of operation, constraints and challenges so that you can effectively design software to solve that problem or represent that real world system System design - beyond software, this is about designing systems of various pieces of software that all have to work together effectively Continuous integration - more on this below Code management - how do you store and build your code? How do you ensure there is consistency of style across your codebase? How do you keep it clean? Deployment / release management - How do you release new versions of software, ideally with minimal disruption to your users? Version management - how do you track changes to your software and communicate those changes to the people who care, and in some cases are deeply financially invested in your software? Load testing - for systems that have the potential to be utilised by tens of thousands of users, you need to be able to test and verify that it won't fall over under load. It's important to understand that everything changes when a system is under stress. A car traveling at 100mph handles a lot differently than a car travelling at 10. The one standout topic here for me is continuous integration. A book was released not too long ago called 'Accelerate; The Science of Lean Software and DevOps: Building and Scaling High Performing Technology Organizations'. It's a pretty heavy read, full of data gathered by analyzing both high and low performing software teams. The bottom line is this: the more frequently you are building and releasing code to your users, the more stable and higher quality your software will be. It's also vital to remember that we rarely create software for the sake of creating it - we create it for the people that will be using it. The user is everything, don't forget that. Web Development When it comes to web development I think it's easier to define a list of fundamentals, because without understanding the things on this list you simply won't be effective and I think there's little room for argument here. HTTP - how browsers communicate with server to get the data they need to display and run your site HTML - how your content is structured CSS - how your content is styled Dom structure - Document Object Model, how do you interact with and manipulate your HTML pages to create a dynamic web experience Javascript - adding behaviour to your websites SQL - How do you store and access the data used to drive your website Web security - you really should think about keeping your users and their data safe from online predators Not much else to say on this - if you want to be a web developer, get good at all of these things. That's it for the fundamentals. If there is any word up there that you don't understand, I suggest going and researching it - there are plenty of resources online to learn all of these things. Don't be an X developer I don't like the idea of being a 'Python developer' or a 'C++ developer'. People do this with frameworks too. \"I'm a React developer\" or \"I'm an IOS developer\". I think you should avoid pigeonholing yourself like this. Become a developer, or a software engineer, a programmer, whatever you want to call it, but don't tie yourself to a technology that may or may not exist in ten years. Over your career you will be exposed to many new technologies and you will have to learn and adapt constantly. Focus on concepts and ideas instead of specific technologies. Find patterns and commonalities in what you are doing. Think critically about the technologies you are using. This will allow you to pick up the right tool for the job when you need it. None of this means you can't become an expert in one thing. I'd just avoid limiting yourself to that one thing. There is a saying you sometimes hear that goes like this: A jack of all trades is a master of none. This makes it seem as if knowing a little about a lot of things is bad. However, the full original saying actually goes like this: A jack of all trades is a master of none, but oftentimes better than a master of one. In other words - generalists are often more useful than specialists. Pick something and finish it You will likely need to do some sort of course to learn to program. Whether this is an online course, a bootcamp or a college degree I think you should commit to it and finish it. It will be hard. It will be uncomfortable. There will be times you feel like an idiot (you're not). But there will be moments of extreme satisfaction as things finally click for you. Like most things in life, what will get out what you put in. If you put in the time, effort and focus you will get there - you just need to commit and stick to it. Trust the process and the results will take care of themselves. To make the process a little easier I think it helps to have a goal. Something you want to do with your growing skillset. Maybe you want to build a game or create a social media site that doesn't destroy society. Maybe you want to create educational software to help children with autism learn more effectively or use software to empower people struggling through poverty or war. Whatever it is - having a thing you want to build makes learning the how to do it much easier. In other words, it helps to have a why . And for what it's worth, I reckon having 'to make lots of money' as your why is far less motivating than you might think. Just tell me what language to learn This is something I definitely don't want to be prescriptive about, but here are some thoughts on what language might be right for you... If you're into computers, hardware, operating systems etc... it would probably be a good idea to start with C. It gets you close to the hardware and is very powerful. After that you can move in to the more complex world of C++. Are you interested primarily in web development and less interested in everything going on behind the browser? I'd probably go for Javascript. Are you itching to just build software? Then I think Python is a great choice. It was specifically designed to read like a natural language (ie. English) so it is quite approachable, and you can build desktop apps, simple games, server applications, system automation, machine learning etc... using it. It's my favourite language because it is so quick to prototype with and it's standard library is the best I've used. But don't be fooled - writing Python is different to writing good Python, and there is still complexity there when writing real world software. Do you want to build games but don't want to worry about the complexities of building a game engine? C# is a good choice as it is the language of choice for the popular engine Unity3D. Want to build games from the ground up? C++ is probably a good choice. That's more or less all I have to say on this topic and I hope it was helpful. I know this question isn't going anywhere and my thoughts on how to answer it may evolve over time, but I think the important point to remember is that there isn't really a 'right' answer, regardless of the answer I give.","title":"Where to start"},{"location":"reading_material/coding/languages/#what-language-should-i-learn","text":"What programming language should I learn first? This is possibly the most common question I see from beginners. I also see that question's cousin quite a bit: What is the best programming language for beginners. And like most questions, the right but unsatisfying answer is it depends .","title":"What language should I learn?"},{"location":"reading_material/coding/languages/#what-does-it-depend-on","text":"It depends on a lot of things. On you. On your goals and interests. On your knowledge of and experience with computers. Maybe you're passionate about the Web and want to spend the rest of your life building web sites that users love using. Or maybe you want to be a game developer, so you plan to create stunningly realistic 3D graphics simulations. Perhaps AI and Machine Learning tickle your fancy. Depending on your interests, like in the above example, I might recommend a completely different path, which is why what programming language should I learn first is a difficult question to answer. Regardless of all of that, however, there are some pieces of advice that I'd give to anyone, regardless of their goals and interests.","title":"What does it depend on?"},{"location":"reading_material/coding/languages/#fundamentals","text":"Focus on the fundamentals. People say this all the time - and it seems to me to be decent advice in all things. After all, if you can't do the fundamentals well, what hope have you got doing more complex things? But this statement does beg the question: \"What are the fundamentals?\" And depending on who you ask you might get a different answer. This is partly because we tend to think of programming, computer science, software engineering, web development etc... as all kind of being the same thing, when really they are different. So lets start with some definitions: Computer Science - The study of computation and computer technology, hardware, and software. Programming - The process of designing, writing, testing, debugging, and maintaining the source code of computer programs. Software Engineering - The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software, and the study of these approaches. That is the application of engineering to software. Web Development - Building, creating, and maintaining websites. It includes aspects such as web design , web publishing , web programming, and database management. So as you can see there are some differences. Some are subtle, like the difference between programming and software engineering. Programming is definitely a part of software engineering, it's how we create software in the first place. But software engineering is more than just programming. Computer science is very much concerned with the hardware and low level details of how a computer works, but web development is more focused on what a web browser can do, rather than what the computer can do. Web development could be considered a specialization of software engineering and also requires programming. The waters here appear pretty muddy, but these distinctions are important as they will impact where you focus your energy. Let's get back to the fundamentals. I think it's worth defining some fundamentals for each, but it's important to note that different people may have different opinions on this, and what follows is just my opinion.","title":"Fundamentals"},{"location":"reading_material/coding/languages/#computer-science","text":"These are all low level topics and I think most programmers should endeavor to get at least a basic understanding of most of them. If you want to work on low level software like operating systems, databases, embedded systems or game engines you will need a good understanding of all of these. Hardware design - how CPUs, RAM, graphics cards etc... actually work, the electronics Logic & Binary arithmetic - understanding binary and logic, and how both relate to design computer hardware and software Data structures & Algorithms - efficiently operating on data, vital for computer performance (in fact alot of the progress around making computers faster comes from the creation of more efficient algorithms) Computational complexity - how to we quantify how efficient and algorithm is Compiler design - writing code to generate code that machines understand I have highlighted Data Structures and Algorithms and Computational Complexity here, as I think these are the most important topics for generalists to have a good understanding of.","title":"Computer Science"},{"location":"reading_material/coding/languages/#programming","text":"When it comes to programming, actually creating a piece of functionality within a piece of software, this is my list of important fundamentals. This list is geared much more towards concepts that help create clean code that is maintainable and extensible. Logic & Control flow - controlling how, when and how many times various parts of your code are actually executed (think if statements and loops) Standard library usage - most programming languages come with a set of libraries that do common things (like working with dates and time). Use and learn the std lib for your chosen language, they will have thought more about these things and done it better than you would Memory management - yes, even in memory managed languages Data modelling - how do you structure data in a way that it is efficient to create, store and manipulate it Abstraction - more on this below Modularity - more on this below Testing - writing code to test your code, you should start doing this on day one Refactoring - more on this below Profiling / performance analysis - understanding how efficient your code is and what you can do to get rid of bottlenecks I've highlighted the three topics that I think are some of the more important but often less discussed topics when it comes to programming. Abstraction is about taking complexity and representing it in a way that is easier to work with. Functions and classes are where you usually see complexity abstracted away. For example, creating an algorithm that rotates objects in 3D space can be complex, but calling a function called rotate() isn't complex at all. When you write code you want to do so in a way that you abstract the complexity away as much as possible. It will still be in there - but it shouldn't be constantly in your face. Modularity can be defined as Designed with standardized units or dimensions, as for easy assembly and repair or flexible arrangement and use . I like this definition. Code should be written in a way that you can take it apart, rearrange it and isolate pieces for functionality for testing. Again this can be achieved by good use of functions, classes, structs and creation of libraries. Refactoring is one of the more important topics in programming that I don't think gets anywhere near enough time and attention, especially with beginners. When you write a piece of code you will probably not get it 'right' the first time. It will likely be more verbose than it needs to be, not quite as performant, readable or extensible as it should be either. Writing a piece of code can be thought of as a discovery process. Once you have something working you have discovered how to do it - the next step is to refine it. Refactoring is that refinement and is something you should be doing constantly. A codebase evolves and changes over time - the code you wrote yesterday, last week or last year is not immune to that change, and you should make time for it.","title":"Programming"},{"location":"reading_material/coding/languages/#software-engineering","text":"Here we venture much more into the business side of things. How do we actually deliver, operate and maintain software. I've heard software engineering be defined as 'programming integrated over time'. Meaning that programming is one thing, working on code that needs to last for years, that other programmers, users and businesses depend on is another. System analysis - looking at a problem or real world system and understanding the various modes of operation, constraints and challenges so that you can effectively design software to solve that problem or represent that real world system System design - beyond software, this is about designing systems of various pieces of software that all have to work together effectively Continuous integration - more on this below Code management - how do you store and build your code? How do you ensure there is consistency of style across your codebase? How do you keep it clean? Deployment / release management - How do you release new versions of software, ideally with minimal disruption to your users? Version management - how do you track changes to your software and communicate those changes to the people who care, and in some cases are deeply financially invested in your software? Load testing - for systems that have the potential to be utilised by tens of thousands of users, you need to be able to test and verify that it won't fall over under load. It's important to understand that everything changes when a system is under stress. A car traveling at 100mph handles a lot differently than a car travelling at 10. The one standout topic here for me is continuous integration. A book was released not too long ago called 'Accelerate; The Science of Lean Software and DevOps: Building and Scaling High Performing Technology Organizations'. It's a pretty heavy read, full of data gathered by analyzing both high and low performing software teams. The bottom line is this: the more frequently you are building and releasing code to your users, the more stable and higher quality your software will be. It's also vital to remember that we rarely create software for the sake of creating it - we create it for the people that will be using it. The user is everything, don't forget that.","title":"Software Engineering"},{"location":"reading_material/coding/languages/#web-development","text":"When it comes to web development I think it's easier to define a list of fundamentals, because without understanding the things on this list you simply won't be effective and I think there's little room for argument here. HTTP - how browsers communicate with server to get the data they need to display and run your site HTML - how your content is structured CSS - how your content is styled Dom structure - Document Object Model, how do you interact with and manipulate your HTML pages to create a dynamic web experience Javascript - adding behaviour to your websites SQL - How do you store and access the data used to drive your website Web security - you really should think about keeping your users and their data safe from online predators Not much else to say on this - if you want to be a web developer, get good at all of these things. That's it for the fundamentals. If there is any word up there that you don't understand, I suggest going and researching it - there are plenty of resources online to learn all of these things.","title":"Web Development"},{"location":"reading_material/coding/languages/#dont-be-an-x-developer","text":"I don't like the idea of being a 'Python developer' or a 'C++ developer'. People do this with frameworks too. \"I'm a React developer\" or \"I'm an IOS developer\". I think you should avoid pigeonholing yourself like this. Become a developer, or a software engineer, a programmer, whatever you want to call it, but don't tie yourself to a technology that may or may not exist in ten years. Over your career you will be exposed to many new technologies and you will have to learn and adapt constantly. Focus on concepts and ideas instead of specific technologies. Find patterns and commonalities in what you are doing. Think critically about the technologies you are using. This will allow you to pick up the right tool for the job when you need it. None of this means you can't become an expert in one thing. I'd just avoid limiting yourself to that one thing. There is a saying you sometimes hear that goes like this: A jack of all trades is a master of none. This makes it seem as if knowing a little about a lot of things is bad. However, the full original saying actually goes like this: A jack of all trades is a master of none, but oftentimes better than a master of one. In other words - generalists are often more useful than specialists.","title":"Don't be an X developer"},{"location":"reading_material/coding/languages/#pick-something-and-finish-it","text":"You will likely need to do some sort of course to learn to program. Whether this is an online course, a bootcamp or a college degree I think you should commit to it and finish it. It will be hard. It will be uncomfortable. There will be times you feel like an idiot (you're not). But there will be moments of extreme satisfaction as things finally click for you. Like most things in life, what will get out what you put in. If you put in the time, effort and focus you will get there - you just need to commit and stick to it. Trust the process and the results will take care of themselves. To make the process a little easier I think it helps to have a goal. Something you want to do with your growing skillset. Maybe you want to build a game or create a social media site that doesn't destroy society. Maybe you want to create educational software to help children with autism learn more effectively or use software to empower people struggling through poverty or war. Whatever it is - having a thing you want to build makes learning the how to do it much easier. In other words, it helps to have a why . And for what it's worth, I reckon having 'to make lots of money' as your why is far less motivating than you might think.","title":"Pick something and finish it"},{"location":"reading_material/coding/languages/#just-tell-me-what-language-to-learn","text":"This is something I definitely don't want to be prescriptive about, but here are some thoughts on what language might be right for you... If you're into computers, hardware, operating systems etc... it would probably be a good idea to start with C. It gets you close to the hardware and is very powerful. After that you can move in to the more complex world of C++. Are you interested primarily in web development and less interested in everything going on behind the browser? I'd probably go for Javascript. Are you itching to just build software? Then I think Python is a great choice. It was specifically designed to read like a natural language (ie. English) so it is quite approachable, and you can build desktop apps, simple games, server applications, system automation, machine learning etc... using it. It's my favourite language because it is so quick to prototype with and it's standard library is the best I've used. But don't be fooled - writing Python is different to writing good Python, and there is still complexity there when writing real world software. Do you want to build games but don't want to worry about the complexities of building a game engine? C# is a good choice as it is the language of choice for the popular engine Unity3D. Want to build games from the ground up? C++ is probably a good choice. That's more or less all I have to say on this topic and I hope it was helpful. I know this question isn't going anywhere and my thoughts on how to answer it may evolve over time, but I think the important point to remember is that there isn't really a 'right' answer, regardless of the answer I give.","title":"Just tell me what language to learn"},{"location":"reading_material/hardware/","text":"In this section we will be looking at computer hardware. CPUs RAM Monitors Keyboards Mice Transistors Logic Gates Modems And much more... Without hardware, software could not exist - so it's worth scratching beneath the surface of this complex and often intimidating subject. Stay tuned for more!","title":"Introduction"},{"location":"reading_material/hardware/keyboards_and_mice/","text":"Mouse and Keyboard I'm going to go ahead and assume you know what a mouse and keyboard are and what they do. So you might be wondering why I'd bother writing a whole post about them. Well, what I actually want to do is get you excited about your keyboard... and learn to despise your mouse. Maybe despise is too strong a word... Mice are great and absolutely have a place. But if you're going to be spending a lot of time with your computer, it's worth really getting to know your keyboard. But why? You might ask. Let's think about it for a second. When you are sitting at your computer and writing some code or typing up a document, you will have both of your hands on the keyboard. If you then want to use your mouse to do something, like change to a different window or select a menu option, you need to lift your hand off the keyboard and move it over to the mouse. Then you need to move that mouse so that your pointer moves to the desired location. Finally, you can click the thing. This is slow, and more often than not you can avoid that hand relocation entirely by using keyboard shortcuts. The amount of information you can send to your computer through your keyboard vastly outweighs the information you can send via a mouse. You just need to learn how to unlock the power of your keyboard. Touch Typing Touch Typing is the ability to type without looking at the keyboard. It's an invaluable skill and is worth spending some time on. I won't lie, it can be painful to learn, but there are plenty of tools online to help you improve your typing. My personal favourite is a version of the arcade shooter 'House of the Dead' called 'The Typing of the Dead', where you type words to fend off an incoming horde of zombies. Navigating Text Since writing code is essentially manipulating a bunch of text files, it's definitely worth spending some time learning how to efficiently navigate a text file using just your keyboard. Shifting The shift key on your keyboard is interesting. Most of the time, people use it purely for the purpose of capitalizing a letter. You hold shift, type a letter, and on the screen you will see the capital version of that letter. But that is just one example of what Shift can do. More generally speaking, what the shift key actually does is 'invert' the functionality of the operation you are performing. Open up a text editor a type out a sentence, any sentence. Now use your arrow keys to move the caret (the little vertical bar that tells you where your text will be entered) around. Now try moving the caret around with the arrow keys, but this time hold down shift while you do it. What happened? Instead of just repositioning the caret, your computer will now highlight any letters in its path. If you press the up arrow, all of the text between where the caret started and ended up will be selected. This is incredibly useful, especially when writing code. Later on, we will couple this functionality with some shortcuts to unleash some real power! Controlling Another important key on your keyboard is control or ctrl . If you're using a Mac you will want to use the Command key for the most part (though in some cases, you will want to use the option key. I switch between a Mac and my Linux PC a lot - and it really messes me up because I have to rethink how I use the keyboard). Anyway, using control you can really increase the speed with which you can move around in your text editor. For example, in Windows/Linux if you hold control while using the forward / back arrow keys, the caret will jump around one word at the time. Combine that with the shift key and you will select each word as you jump over it. Info On Mac you will need to use option to get this same behavior. Home and End A couple of keys on the keyboard that don't get used often are the 'home' and 'end' keys. Pressing home will move the caret to the start of the current line. Pressing end will move it to the end. Pressing shift while using either of these keys will, you've guessed it, highlight the whole line from the point where the caret started to either the start or end, depending on which key you hit. Info On Mac you don't need home and end, cmd + <arrow> will do the same thing. Manipulation Now let's put the above to good use and actually manipulate some text. The most commonly used text manipulation shortcuts on a keyboard are probably: ctrl + c - copy the highlighted text ctrl + x - cut the highlighted text (like copy, but removes the text) ctrl + v - paste whatever you last copied or cut ctrl + z - undo the last change you made ctrl + a - select all text in your editor Info On Mac use Command in place of ctrl for all of the above So - now we can combine everything we've learned so far and enable some lightning fast text manipulation. Let's say you have a few paragraphs of text, with your caret at the beginning. If you want to delete the first line (on Windows) you can simply issue the following commands on your keyboard: shift + end then backspace . If you want to take the first line and move it to the very bottom of the text, simply do the following: shift + end to select the first line ctrl + x to cut the text out ctrl + end to jump to the end of the text ctrl + v to paste the text at the end To really optimize this you don't even need to take your finger off the ctrl key once you've first pressed it. If you tried to do the same with your mouse it would likely take a few seconds. Using the keyboard I can do all of this in less than a second. This time really adds up when you spend 8 hours a day at your computer for an entire career. Something really important to note here is that just reading about these sorts of shortcuts and text manipulation tools really won't do you any good. You need to practice this. You need to force yourself to use these shortcuts - resist the urge to use your mouse. Even if you forget a shortcut, stop what you are doing it, go search the internet to figure it out and then do it. After a while it will become second nature. While writing this post I used all of the above tricks to move bits of text around, select chunks of text to delete, and much more. Info Note that these text manipulation shortcuts will work in any text field on your computer! So, for example, you can use all of the above when typing a URL into your browser. Shortcuts We've already touched on a bunch of shortcuts, and they are exactly what their names suggest. Quick ways to achieve a desired result. It's important to note that most applications you use will support what has become a fairly standard set of shortcuts. So ctrl + z , for example, will usually mean undo , no matter what application you are using. In a text editor, it will remove the last word or letter you typed. In an image editor, like Photoshop, ctrl + z will undo whatever the last change you made to the image was. You don't need to learn and memorize all of these commands now, that would be tedious and annoying, but you should be aware they are there. Every time you reach for the mouse think to yourself 'could I have done that faster with my keyboard?' The answer is probably yes. System Level There are some shortcuts that exist at the level of your operating system that will be extremely useful as you begin to spend more time on your computer. The one I use most is probably alt + tab . This will switch between whatever the two most recently active open windows are. For example, if you have your browser open and you have a text editor open, alt + tab will switch between them. If you have two windows of the same application open you can also switch between the two of those by using alt + ` (that is the key above your tab key). Info On Mac you need to use the Command key for the above. On Windows and Linux one of the more useful keys is the Windows Key . Usually this is between the ctrl and alt keys. On my Linux machine this will display all currently open applications. On Windows it will open your start menu. Either way, you can push this button and start typing the name of the application you want and the system will find it for you. On Mac you can achieve similar using cmd + space . There are many more system level shortcuts you can explore yourself, these are probably the two I use most frequently myself. Application Level At the application level there are a few shortcuts you can probably count on being there. For example: ctrl + s - save your changes ctrl + q - close the application ctrl + n - create a 'new' document, file etc... ctrl + o - open an existing file Another useful trick is if you want to access the menu along the top of the window is you hold down the alt key. This should result in each word in the menu having a single letter underlined. You can then hit that key to open that menu. From there you can use your arrow keys to navigate around the menu. For example, opening the 'File' menu usually involves using alt + f . Info Mac OS doesn't have this exact functionality. You can use ctrl + f2 to send focus to the menu bar at the top of the screen and go from there. Vim Vim is a text editor that is popular among many programmers. It is known for having an incredibly steep learning curve - but once mastered it can result in serious productivity gains. This is because it is set up to utilize only a keyboard (it has been around since before mice) and does this job amazingly well. Watching an experienced Vim using is like watching a sort of black magic ritual - files are created, modified and saved with speed and precision like you've never seen before. I'm not going to get into Vim here because many books and tutorials have been written on this application that do a far better job than I ever could. I just wanted to highlight it here because it is an extreme example of what you can do with just a keyboard. If you're using Linux or MacOS and want to try out Vim you can do so by typing vimtutor in your terminal. This will open up a tutorial for you to get hands on with Vim right away (it is build into Linux and Mac). On Windows you can use a Linux VM (see the Setup section of Your Apprenticeship ). In Closing I could spend hours talking about keyboard shortcuts and efficiency - but I won't. What I wanted to do here was simply plant a thought. A thought that will sit there in the back of your mind and tingle ever so slightly every time you reach for your mouse. 'Could I have done that faster with my keyboard', it will say. And I hope you will respond with curiosity, and go explore ways to make your workflows more efficient. Remember, if you spend 10 seconds every hour doing something that you could do in 1 second, over the course of a 40 hour work week you will be wasting 6 whole minutes. Over the course of a year that will add up to 5 hours. Over the course of a career you're looking at 8 or 9 days!","title":"Mouse & Keyboard"},{"location":"reading_material/hardware/keyboards_and_mice/#mouse-and-keyboard","text":"I'm going to go ahead and assume you know what a mouse and keyboard are and what they do. So you might be wondering why I'd bother writing a whole post about them. Well, what I actually want to do is get you excited about your keyboard... and learn to despise your mouse. Maybe despise is too strong a word... Mice are great and absolutely have a place. But if you're going to be spending a lot of time with your computer, it's worth really getting to know your keyboard. But why? You might ask. Let's think about it for a second. When you are sitting at your computer and writing some code or typing up a document, you will have both of your hands on the keyboard. If you then want to use your mouse to do something, like change to a different window or select a menu option, you need to lift your hand off the keyboard and move it over to the mouse. Then you need to move that mouse so that your pointer moves to the desired location. Finally, you can click the thing. This is slow, and more often than not you can avoid that hand relocation entirely by using keyboard shortcuts. The amount of information you can send to your computer through your keyboard vastly outweighs the information you can send via a mouse. You just need to learn how to unlock the power of your keyboard.","title":"Mouse and Keyboard"},{"location":"reading_material/hardware/keyboards_and_mice/#touch-typing","text":"Touch Typing is the ability to type without looking at the keyboard. It's an invaluable skill and is worth spending some time on. I won't lie, it can be painful to learn, but there are plenty of tools online to help you improve your typing. My personal favourite is a version of the arcade shooter 'House of the Dead' called 'The Typing of the Dead', where you type words to fend off an incoming horde of zombies.","title":"Touch Typing"},{"location":"reading_material/hardware/keyboards_and_mice/#navigating-text","text":"Since writing code is essentially manipulating a bunch of text files, it's definitely worth spending some time learning how to efficiently navigate a text file using just your keyboard.","title":"Navigating Text"},{"location":"reading_material/hardware/keyboards_and_mice/#shifting","text":"The shift key on your keyboard is interesting. Most of the time, people use it purely for the purpose of capitalizing a letter. You hold shift, type a letter, and on the screen you will see the capital version of that letter. But that is just one example of what Shift can do. More generally speaking, what the shift key actually does is 'invert' the functionality of the operation you are performing. Open up a text editor a type out a sentence, any sentence. Now use your arrow keys to move the caret (the little vertical bar that tells you where your text will be entered) around. Now try moving the caret around with the arrow keys, but this time hold down shift while you do it. What happened? Instead of just repositioning the caret, your computer will now highlight any letters in its path. If you press the up arrow, all of the text between where the caret started and ended up will be selected. This is incredibly useful, especially when writing code. Later on, we will couple this functionality with some shortcuts to unleash some real power!","title":"Shifting"},{"location":"reading_material/hardware/keyboards_and_mice/#controlling","text":"Another important key on your keyboard is control or ctrl . If you're using a Mac you will want to use the Command key for the most part (though in some cases, you will want to use the option key. I switch between a Mac and my Linux PC a lot - and it really messes me up because I have to rethink how I use the keyboard). Anyway, using control you can really increase the speed with which you can move around in your text editor. For example, in Windows/Linux if you hold control while using the forward / back arrow keys, the caret will jump around one word at the time. Combine that with the shift key and you will select each word as you jump over it. Info On Mac you will need to use option to get this same behavior.","title":"Controlling"},{"location":"reading_material/hardware/keyboards_and_mice/#home-and-end","text":"A couple of keys on the keyboard that don't get used often are the 'home' and 'end' keys. Pressing home will move the caret to the start of the current line. Pressing end will move it to the end. Pressing shift while using either of these keys will, you've guessed it, highlight the whole line from the point where the caret started to either the start or end, depending on which key you hit. Info On Mac you don't need home and end, cmd + <arrow> will do the same thing.","title":"Home and End"},{"location":"reading_material/hardware/keyboards_and_mice/#manipulation","text":"Now let's put the above to good use and actually manipulate some text. The most commonly used text manipulation shortcuts on a keyboard are probably: ctrl + c - copy the highlighted text ctrl + x - cut the highlighted text (like copy, but removes the text) ctrl + v - paste whatever you last copied or cut ctrl + z - undo the last change you made ctrl + a - select all text in your editor Info On Mac use Command in place of ctrl for all of the above So - now we can combine everything we've learned so far and enable some lightning fast text manipulation. Let's say you have a few paragraphs of text, with your caret at the beginning. If you want to delete the first line (on Windows) you can simply issue the following commands on your keyboard: shift + end then backspace . If you want to take the first line and move it to the very bottom of the text, simply do the following: shift + end to select the first line ctrl + x to cut the text out ctrl + end to jump to the end of the text ctrl + v to paste the text at the end To really optimize this you don't even need to take your finger off the ctrl key once you've first pressed it. If you tried to do the same with your mouse it would likely take a few seconds. Using the keyboard I can do all of this in less than a second. This time really adds up when you spend 8 hours a day at your computer for an entire career. Something really important to note here is that just reading about these sorts of shortcuts and text manipulation tools really won't do you any good. You need to practice this. You need to force yourself to use these shortcuts - resist the urge to use your mouse. Even if you forget a shortcut, stop what you are doing it, go search the internet to figure it out and then do it. After a while it will become second nature. While writing this post I used all of the above tricks to move bits of text around, select chunks of text to delete, and much more. Info Note that these text manipulation shortcuts will work in any text field on your computer! So, for example, you can use all of the above when typing a URL into your browser.","title":"Manipulation"},{"location":"reading_material/hardware/keyboards_and_mice/#shortcuts","text":"We've already touched on a bunch of shortcuts, and they are exactly what their names suggest. Quick ways to achieve a desired result. It's important to note that most applications you use will support what has become a fairly standard set of shortcuts. So ctrl + z , for example, will usually mean undo , no matter what application you are using. In a text editor, it will remove the last word or letter you typed. In an image editor, like Photoshop, ctrl + z will undo whatever the last change you made to the image was. You don't need to learn and memorize all of these commands now, that would be tedious and annoying, but you should be aware they are there. Every time you reach for the mouse think to yourself 'could I have done that faster with my keyboard?' The answer is probably yes.","title":"Shortcuts"},{"location":"reading_material/hardware/keyboards_and_mice/#system-level","text":"There are some shortcuts that exist at the level of your operating system that will be extremely useful as you begin to spend more time on your computer. The one I use most is probably alt + tab . This will switch between whatever the two most recently active open windows are. For example, if you have your browser open and you have a text editor open, alt + tab will switch between them. If you have two windows of the same application open you can also switch between the two of those by using alt + ` (that is the key above your tab key). Info On Mac you need to use the Command key for the above. On Windows and Linux one of the more useful keys is the Windows Key . Usually this is between the ctrl and alt keys. On my Linux machine this will display all currently open applications. On Windows it will open your start menu. Either way, you can push this button and start typing the name of the application you want and the system will find it for you. On Mac you can achieve similar using cmd + space . There are many more system level shortcuts you can explore yourself, these are probably the two I use most frequently myself.","title":"System Level"},{"location":"reading_material/hardware/keyboards_and_mice/#application-level","text":"At the application level there are a few shortcuts you can probably count on being there. For example: ctrl + s - save your changes ctrl + q - close the application ctrl + n - create a 'new' document, file etc... ctrl + o - open an existing file Another useful trick is if you want to access the menu along the top of the window is you hold down the alt key. This should result in each word in the menu having a single letter underlined. You can then hit that key to open that menu. From there you can use your arrow keys to navigate around the menu. For example, opening the 'File' menu usually involves using alt + f . Info Mac OS doesn't have this exact functionality. You can use ctrl + f2 to send focus to the menu bar at the top of the screen and go from there.","title":"Application Level"},{"location":"reading_material/hardware/keyboards_and_mice/#vim","text":"Vim is a text editor that is popular among many programmers. It is known for having an incredibly steep learning curve - but once mastered it can result in serious productivity gains. This is because it is set up to utilize only a keyboard (it has been around since before mice) and does this job amazingly well. Watching an experienced Vim using is like watching a sort of black magic ritual - files are created, modified and saved with speed and precision like you've never seen before. I'm not going to get into Vim here because many books and tutorials have been written on this application that do a far better job than I ever could. I just wanted to highlight it here because it is an extreme example of what you can do with just a keyboard. If you're using Linux or MacOS and want to try out Vim you can do so by typing vimtutor in your terminal. This will open up a tutorial for you to get hands on with Vim right away (it is build into Linux and Mac). On Windows you can use a Linux VM (see the Setup section of Your Apprenticeship ).","title":"Vim"},{"location":"reading_material/hardware/keyboards_and_mice/#in-closing","text":"I could spend hours talking about keyboard shortcuts and efficiency - but I won't. What I wanted to do here was simply plant a thought. A thought that will sit there in the back of your mind and tingle ever so slightly every time you reach for your mouse. 'Could I have done that faster with my keyboard', it will say. And I hope you will respond with curiosity, and go explore ways to make your workflows more efficient. Remember, if you spend 10 seconds every hour doing something that you could do in 1 second, over the course of a 40 hour work week you will be wasting 6 whole minutes. Over the course of a year that will add up to 5 hours. Over the course of a career you're looking at 8 or 9 days!","title":"In Closing"},{"location":"reading_material/software/","text":"In this section we will be looking at different types of software and the differences between them. Software is more than just code. It encompasses computer science, user interface design, user experience design, standards and interoperability. As a software engineer it can be useful understand software from a more philosophical point of view. Here we will explore exactly that. More specifically we will look at: Terminal Browsers IDEs Source Control Database software Operating systems Client side software Server side software Productivity software And much more... Stay tuned for more!","title":"Introduction"},{"location":"reading_material/software/terminal/","text":"Command Line Interface A friend once said to me \"Your computer screen looks like my computer when it's broken\". They were talking about this: This is what we call the 'command line'. You may also hear people refer to it as a 'shell' or 'terminal'. It can be confusing and complicated at first, but really it's no different to a standard Windows computer with a desktop, folders and pretty icons. The key difference is that rather than clicking on things to interact with them, we have to type commands. In the above image you can see that I issued three commands. Two of which gave me some output, one of which didn't. Don't worry about the specifics of those commands for now - just know that interacting with the terminal involves typing commands and hitting enter. These commands may produce some output or may not - it depends on the command. This might seem like a difficult way to work, and it can be - in the beginning. The learning curve is steep, but once you learn you can become a lot faster and more efficient by using the command line. One reason for this is automation. If I'm just typing commands, I can write down a series of commands and tell the command line to run them one after another. If I save those commands to a file I can re-run them whenever I want. That file would be called a 'script'. Here is a very basic but valid script that simply tells me what folder I'm looking at and what files are in that folder: 1 2 pwd ls This is a lot harder to do with clicks and graphics. Having said all of that, working with the terminal day to day is not a requirement. I know plenty of engineers who rarely touch the terminal. However when working on a server it usually will be a requirement.","title":"Command Line Interface"},{"location":"reading_material/software/terminal/#command-line-interface","text":"A friend once said to me \"Your computer screen looks like my computer when it's broken\". They were talking about this: This is what we call the 'command line'. You may also hear people refer to it as a 'shell' or 'terminal'. It can be confusing and complicated at first, but really it's no different to a standard Windows computer with a desktop, folders and pretty icons. The key difference is that rather than clicking on things to interact with them, we have to type commands. In the above image you can see that I issued three commands. Two of which gave me some output, one of which didn't. Don't worry about the specifics of those commands for now - just know that interacting with the terminal involves typing commands and hitting enter. These commands may produce some output or may not - it depends on the command. This might seem like a difficult way to work, and it can be - in the beginning. The learning curve is steep, but once you learn you can become a lot faster and more efficient by using the command line. One reason for this is automation. If I'm just typing commands, I can write down a series of commands and tell the command line to run them one after another. If I save those commands to a file I can re-run them whenever I want. That file would be called a 'script'. Here is a very basic but valid script that simply tells me what folder I'm looking at and what files are in that folder: 1 2 pwd ls This is a lot harder to do with clicks and graphics. Having said all of that, working with the terminal day to day is not a requirement. I know plenty of engineers who rarely touch the terminal. However when working on a server it usually will be a requirement.","title":"Command Line Interface"},{"location":"reading_material/systems/","text":"This section is all about Systems . To begin with, a system is: a regularly interacting or interdependent group of items forming a unified whole I will be posting various articles here about systems, and their properties, that will be useful in framing our thinking about working with computers. Stay tuned for more!","title":"Introduction"},{"location":"reading_material/systems/io/","text":"Inputs and Outputs My First Job When I was a teenager, I worked at a local petrol station ('gas station' for any Americans that might be reading this). I started on the forecourts at the illegal age of 15, pumping petrol, washing cars and generally keeping things clean and tidy. One day, as I arrived for my afternoon shift, I noticed a couple of people grouped around a black Honda Civic. The group's attention was directed down towards the ground. One of the other guys I worked with was with them. From time to time, someone would lift their head, say something, and get a bit of a chuckle from the group. A little bit of banter would follow, but it would be brief, and attention would return to the ground. As I got closer, it became clear what was going on. There was a man laying on his side, by the back right wheel, below the fuel pipe. In his right hand was a rubber tube, the other end of which was in the fuel pipe. The other arm was propping him up a little. His cheeks were pink. He had mistakenly pumped diesel into his petrol engine'd car. And now he was sat there on the ground, desperately sucking on a hose pipe trying to siphon the fuel back out. The goal was to suck on the hose pipe hard enough to create a flow of diesel. Once flowing, it would continue to flow until the tank was emptied (amazingly, scientists have not yet figured out exactly how this siphon effect actually works!). The unfortunate car owner did, however, realize his mistake before trying to start the engine, which could have seriously damaged it, resulting in an expensive repair bill. The Car as a System If we stand back and look at a car, it appears to be a pretty simple system. You put petrol in. The engine does something. The car can then move and will spit some exhaust out the back. 1 2 3 Petrol in. Movement and exhaust out. Conversely: 1 2 3 No petrol in. No movement, no exhaust out. So, when we think about our car (in these grossly oversimplified terms), what we have is a thing that requires some input, performs some action, and produces some output. 1 2 3 4 5 Input: Petrol Action: Running engine Output: Movement and exhaust We've also seen that a bad input to our car results in that bad output: 1 2 3 4 5 Input: Diesel Action: Engine stalls Output: No movement, damaged engine What we've got here is an 'Open System': An open system is a system that has external interactions. Such interactions can take the form of information, energy, or material transfers into or out of the system boundary, depending on the discipline which defines the concept. Systems in General If we stick with this fairly general view of things, it's easy to see that we can apply our thinking about the car to a whole range of different things. Why don't you have a think about some of the following examples and what would happen if you gave them bad inputs: The human body : Food goes in, metabolic things happen, energy and waste come out. Light bulbs : Electricity in, filament is heated, light and heat come out. Plants : Sunlight and carbon dioxide in, photosynthesis happens, energy and oxygen out. Paper shredder : Paper goes in, shredding happens, shredded paper comes out. The water cycle : Water evaporates from lakes, oceans etc..., condensation happens, clouds and rain out. You might be thinking that all of the above is overly simplistic. And you'd be right. So what happens when you start to dig in a little bit. After all, we know there is a bit more to a car than 'Petrol go in, car go vrooom'. Going Deeper If we look closer at a car what we will see is that it is actually made up of many smaller systems, all interconnected, exchanging inputs and outputs. We can look at an engine as a holistic system or we can think about the various individual components. There's the cylinder and piston, the combustion chamber, exhaust values etc... Each smaller system will have its own inputs, some action to perform, and some outputs. Those outputs may then be fed into another system. Our bodies are the same. Air enters your respiratory system as you breath. Some filtering and various other things happen to that air before the output, oxygen, is absorbed directly into your circulatory system. From there, it is pumped around the rest of your body by your heart. Many more systems are waiting - the brain, the liver, muscles etc... How about a vending machine? You input a coin and select your drink (that selection is an input too). The output is the snack of your choosing. In between the inputs and outputs of this system, there is likely a system for checking the money that was inserted. Another system for displaying how much you still have to pay. On more modern machines, there will be a system for handling contactless payments with your phone. That payment system will then tell another system, let's call it the 'item getter' system, that the payment is complete. The 'item getter' system will then actually get the item. This might involve twirling a small coil until a chocolate bar drops, or moving a robotic arm up and over to your drink selection, before picking it up and dropping it at some outlet. What's even more interesting about the vending machine with the contactless payment system is just how complex it gets when you really start digging. That system needs to connect to the bank somehow. To do this, it will use the internet. The internet itself is another system. It's composed of millions of connected computers, each of which can be divided into smaller systems. That quick tap of your card triggers an event that will likely propagate through thousands of specialized computers, over public and private networks, until it arrives at the banks' computer system. The complexity of it all is staggering - BUT it's manageable if you break it all into small chunks. Small systems. Inputs and outputs. One final thing on the vending machine. Its input is variable. Unlike the car's fuel tank, which expects only one type of fuel, the vending machine has an array of different items to choose from. You could use the machine ten times with ten different, equally valid inputs. And as you might imagine, the more available inputs there are, the more complicated things get. With a single acceptable input, you only need to check one thing. With multiple valid inputs, you need to check that the input is contained within the set of valid inputs. And what if our vending machine was really fancy and could make any food you wanted? You just need to enter all of the ingredients in their correct amounts. The room for error starts to grow. What if you get an input wrong? It's getting easier and easier to make mistakes as we scale this up. Now think about what would happen if you had millions of different inputs, all with millions of valid input values? Well, in that case, you'd have a computer... That's part of why computers can feel so daunting and complicated - BUT, once again, it's manageable if you break it all into small chunks. Small systems. Inputs and outputs. What about Computers When it comes to computers, you will often hear people talking about IO. IO or I/O simply refers to 'Input Output'. When you look at your computer, what are the inputs and outputs? With your mouse, you can input clicks. With your keyboard, you can input characters and numbers. The screen is an input too, if it's a touch screen. These are all things that allow you to provide some input to your computer. So naturally, they are often called 'input devices'. What about outputs and output devices? Your monitor or screen seems like the obvious one. This is where the computer shows you webpages or games. The output of the computer is whatever is displayed on the screen. So technically, the output is just light, various different colors of light. It's also worth thinking about the fact that your screen can act as both an input and an output device. Your phone is the perfect example of this. A printer is also an output device. As are your speakers. Within the computer, all of the most important components - the CPU, RAM, graphics card, sound card - all act as both input and output devices. Each one is its own system, and each one receives inputs from and sends outputs to the others. We won't get into the low level details of this just yet - what's important here is establishing a way of thinking. Of looking at small discrete systems and their inputs/outputs. Once you get used to thinking about things in this way, computers and software engineering become a lot more approachable. Homework Over the next week, take a deeper look at your surroundings, wherever you are. Think about the various systems at play. Their inputs and outputs. Their internals and their inputs and outputs. We're training your brain to think systematically. To break things down into logical, discrete chunks before piecing them back together to reveal the holistic whole.","title":"Inputs & Outputs"},{"location":"reading_material/systems/io/#inputs-and-outputs","text":"","title":"Inputs and Outputs"},{"location":"reading_material/systems/io/#my-first-job","text":"When I was a teenager, I worked at a local petrol station ('gas station' for any Americans that might be reading this). I started on the forecourts at the illegal age of 15, pumping petrol, washing cars and generally keeping things clean and tidy. One day, as I arrived for my afternoon shift, I noticed a couple of people grouped around a black Honda Civic. The group's attention was directed down towards the ground. One of the other guys I worked with was with them. From time to time, someone would lift their head, say something, and get a bit of a chuckle from the group. A little bit of banter would follow, but it would be brief, and attention would return to the ground. As I got closer, it became clear what was going on. There was a man laying on his side, by the back right wheel, below the fuel pipe. In his right hand was a rubber tube, the other end of which was in the fuel pipe. The other arm was propping him up a little. His cheeks were pink. He had mistakenly pumped diesel into his petrol engine'd car. And now he was sat there on the ground, desperately sucking on a hose pipe trying to siphon the fuel back out. The goal was to suck on the hose pipe hard enough to create a flow of diesel. Once flowing, it would continue to flow until the tank was emptied (amazingly, scientists have not yet figured out exactly how this siphon effect actually works!). The unfortunate car owner did, however, realize his mistake before trying to start the engine, which could have seriously damaged it, resulting in an expensive repair bill.","title":"My First Job"},{"location":"reading_material/systems/io/#the-car-as-a-system","text":"If we stand back and look at a car, it appears to be a pretty simple system. You put petrol in. The engine does something. The car can then move and will spit some exhaust out the back. 1 2 3 Petrol in. Movement and exhaust out. Conversely: 1 2 3 No petrol in. No movement, no exhaust out. So, when we think about our car (in these grossly oversimplified terms), what we have is a thing that requires some input, performs some action, and produces some output. 1 2 3 4 5 Input: Petrol Action: Running engine Output: Movement and exhaust We've also seen that a bad input to our car results in that bad output: 1 2 3 4 5 Input: Diesel Action: Engine stalls Output: No movement, damaged engine What we've got here is an 'Open System': An open system is a system that has external interactions. Such interactions can take the form of information, energy, or material transfers into or out of the system boundary, depending on the discipline which defines the concept.","title":"The Car as a System"},{"location":"reading_material/systems/io/#systems-in-general","text":"If we stick with this fairly general view of things, it's easy to see that we can apply our thinking about the car to a whole range of different things. Why don't you have a think about some of the following examples and what would happen if you gave them bad inputs: The human body : Food goes in, metabolic things happen, energy and waste come out. Light bulbs : Electricity in, filament is heated, light and heat come out. Plants : Sunlight and carbon dioxide in, photosynthesis happens, energy and oxygen out. Paper shredder : Paper goes in, shredding happens, shredded paper comes out. The water cycle : Water evaporates from lakes, oceans etc..., condensation happens, clouds and rain out. You might be thinking that all of the above is overly simplistic. And you'd be right. So what happens when you start to dig in a little bit. After all, we know there is a bit more to a car than 'Petrol go in, car go vrooom'.","title":"Systems in General"},{"location":"reading_material/systems/io/#going-deeper","text":"If we look closer at a car what we will see is that it is actually made up of many smaller systems, all interconnected, exchanging inputs and outputs. We can look at an engine as a holistic system or we can think about the various individual components. There's the cylinder and piston, the combustion chamber, exhaust values etc... Each smaller system will have its own inputs, some action to perform, and some outputs. Those outputs may then be fed into another system. Our bodies are the same. Air enters your respiratory system as you breath. Some filtering and various other things happen to that air before the output, oxygen, is absorbed directly into your circulatory system. From there, it is pumped around the rest of your body by your heart. Many more systems are waiting - the brain, the liver, muscles etc... How about a vending machine? You input a coin and select your drink (that selection is an input too). The output is the snack of your choosing. In between the inputs and outputs of this system, there is likely a system for checking the money that was inserted. Another system for displaying how much you still have to pay. On more modern machines, there will be a system for handling contactless payments with your phone. That payment system will then tell another system, let's call it the 'item getter' system, that the payment is complete. The 'item getter' system will then actually get the item. This might involve twirling a small coil until a chocolate bar drops, or moving a robotic arm up and over to your drink selection, before picking it up and dropping it at some outlet. What's even more interesting about the vending machine with the contactless payment system is just how complex it gets when you really start digging. That system needs to connect to the bank somehow. To do this, it will use the internet. The internet itself is another system. It's composed of millions of connected computers, each of which can be divided into smaller systems. That quick tap of your card triggers an event that will likely propagate through thousands of specialized computers, over public and private networks, until it arrives at the banks' computer system. The complexity of it all is staggering - BUT it's manageable if you break it all into small chunks. Small systems. Inputs and outputs. One final thing on the vending machine. Its input is variable. Unlike the car's fuel tank, which expects only one type of fuel, the vending machine has an array of different items to choose from. You could use the machine ten times with ten different, equally valid inputs. And as you might imagine, the more available inputs there are, the more complicated things get. With a single acceptable input, you only need to check one thing. With multiple valid inputs, you need to check that the input is contained within the set of valid inputs. And what if our vending machine was really fancy and could make any food you wanted? You just need to enter all of the ingredients in their correct amounts. The room for error starts to grow. What if you get an input wrong? It's getting easier and easier to make mistakes as we scale this up. Now think about what would happen if you had millions of different inputs, all with millions of valid input values? Well, in that case, you'd have a computer... That's part of why computers can feel so daunting and complicated - BUT, once again, it's manageable if you break it all into small chunks. Small systems. Inputs and outputs.","title":"Going Deeper"},{"location":"reading_material/systems/io/#what-about-computers","text":"When it comes to computers, you will often hear people talking about IO. IO or I/O simply refers to 'Input Output'. When you look at your computer, what are the inputs and outputs? With your mouse, you can input clicks. With your keyboard, you can input characters and numbers. The screen is an input too, if it's a touch screen. These are all things that allow you to provide some input to your computer. So naturally, they are often called 'input devices'. What about outputs and output devices? Your monitor or screen seems like the obvious one. This is where the computer shows you webpages or games. The output of the computer is whatever is displayed on the screen. So technically, the output is just light, various different colors of light. It's also worth thinking about the fact that your screen can act as both an input and an output device. Your phone is the perfect example of this. A printer is also an output device. As are your speakers. Within the computer, all of the most important components - the CPU, RAM, graphics card, sound card - all act as both input and output devices. Each one is its own system, and each one receives inputs from and sends outputs to the others. We won't get into the low level details of this just yet - what's important here is establishing a way of thinking. Of looking at small discrete systems and their inputs/outputs. Once you get used to thinking about things in this way, computers and software engineering become a lot more approachable.","title":"What about Computers"},{"location":"reading_material/systems/io/#homework","text":"Over the next week, take a deeper look at your surroundings, wherever you are. Think about the various systems at play. Their inputs and outputs. Their internals and their inputs and outputs. We're training your brain to think systematically. To break things down into logical, discrete chunks before piecing them back together to reveal the holistic whole.","title":"Homework"},{"location":"reading_material/systems/numbers/","text":"","title":"Numbers"}]}